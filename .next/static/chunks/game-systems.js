"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRSxZQUFZLENBQUNILFVBQVUsQ0FBQ0M7UUFFN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRSxJQUFJLENBQUM7SUFFWjtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUN2QixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsS0FBSztRQUNuQixJQUFJLENBQUNELElBQUksQ0FBQztJQUdaO0lBRU9LLE9BQWE7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0YsU0FBUyxFQUFFO1FBRXJCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1FBQ2xCLElBQUksQ0FBQ0wsSUFBSSxDQUFDO0lBR1o7SUFFT00sUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQ0gsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxDQUFDRSxLQUFLO1lBQ25CLElBQUksQ0FBQ04sSUFBSSxDQUFDO1FBQ1o7SUFDRjtJQUVPTyxTQUFlO1FBQ3BCLElBQUksSUFBSSxDQUFDSixTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNHLE1BQU07WUFDcEIsSUFBSSxDQUFDUCxJQUFJLENB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bkM7SUFFT0MsYUFBYUMsR0FBVyxFQUFXO1FBQ3hDLE9BQU8sSUFBSSxDQUFDeEMsWUFBWSxDQUFDdUMsWUFBWSxDQUFDQztJQUN4QztJQUVPQyxxQkFBcUJDLE1BQWMsRUFBVztRQUNuRCxPQUFPLElBQUksQ0FBQzFDLFlBQVksQ0FBQ3lDLG9CQUFvQixDQUFDQztJQUNoRDtJQUVPQyxnQkFBMEM7UUFDL0MsT0FBTyxJQUFJLENBQUMzQyxZQUFZLENBQUMyQyxhQUFhO0lBQ3hDO0lBbExBQyxZQUFZQyxTQUF1QixDQUFDLENBQUMsQ0FBRTtRQUNyQyxLQUFLO2FBWEMvQyxTQUFtQzthQUNuQ0MsZ0JBQWdCO2FBQ2hCSyxZQUFZO2FBQ1prQixZQUFZO1FBRXBCLHlCQUF5QjthQUNqQkwsWUFBWTthQUNaQyxhQUFhO2FBQ2JDLGFBQWE7UUFLbkIsSUFBSSxDQUFDVCxLQUFLLEdBQUcsSUFBSWxCLDZDQUFLQTtRQUN0QixJQUFJLENBQUNhLFFBQVEsR0FBRyxJQUFJWiwrQ0FBUUE7UUFDNUIsSUFBSSxDQUFDTyxZQUFZLEdBQUcsSUFBSU4sdURBQVlBO1FBQ3BDLElBQUksQ0FBQzRCLFNBQVMsR0FBR3VCLE9BQU9DLFdBQVcsSUFBSTtRQUV2QyxJQUFJLENBQUN0QixhQUFhO0lBQ3BCO0FBMEtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0VuZ2luZS50cz8yZjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1haW4gZ2FtZSBlbmdpbmUgd2l0aCBFQ1MgaW50ZWdyYXRpb25cbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgR2FtZUxvb3AgfSBmcm9tICcuL0dhbWVMb29wJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJy4vSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0AvdXRpbHMvRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBFbmdpbmVDb25maWcge1xuICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgZW5hYmxlRGVidWc/OiBib29sZWFuO1xuICB0YXJnZXRGUFM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFbmdpbmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBnYW1lTG9vcDogR2FtZUxvb3A7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gIHByaXZhdGUgZnJhbWVUaW1lID0gMDtcbiAgcHJpdmF0ZSB1cGRhdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSByZW5kZXJUaW1lID0gMDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEVuZ2luZUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgdGhpcy5nYW1lTG9vcCA9IG5ldyBHYW1lTG9vcCgpO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gbmV3IElucHV0TWFuYWdlcigpO1xuICAgIHRoaXMuZGVidWdNb2RlID0gY29uZmlnLmVuYWJsZURlYnVnIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5zZXR1cEdhbWVMb29wKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLmluaXRpYWxpemUoY2FudmFzKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnKTtcbiAgICBcbiAgfVxuXG4gIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmdpbmUgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3RhcnRpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJpbnB1dE1hbmFnZXIiLCJlbWl0Iiwic3RhcnQiLCJFcnJvciIsImlzUnVubmluZyIsImdhbWVMb29wIiwic3RvcCIsInBhdXNlIiwicmVzdW1lIiwiZ2V0V29ybGQiLCJ3b3JsZCIsImdldElucHV0TWFuYWdlciIsImdldENhbnZhcyIsImlzRW5naW5lUnVubmluZyIsImdldEN1cnJlbnRGUFMiLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwiZnBzIiwiZnJhbWVUaW1lIiwidXBkYXRlVGltZSIsInJlbmRlclRpbWUiLCJlbmFibGVEZWJ1Z01vZGUiLCJlbmFibGVkIiwiZGVidWdNb2RlIiwiaXNEZWJ1Z01vZGUiLCJzZXR1cEdhbWVMb29wIiwib24iLCJmaXhlZERlbHRhVGltZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZml4ZWRVcGRhdGUiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJpbnRlcnBvbGF0aW9uIiwicmVuZGVyIiwiZGVzdHJveSIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlcXVlc3RQb2ludGVyTG9jayIsImV4aXRQb2ludGVyTG9jayIsImlzS2V5UHJlc3NlZCIsImtleSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwiZ2V0TW91c2VEZWx0YSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiZW5hYmxlRGVidWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        // console.warn('Pointer lock failed');\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJLEdBQUc7WUFBRUksU0FBUztRQUFNO1FBQzNFUCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNPLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Usa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FB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Q1ksSUFBSSxDQUFDdUUsS0FBSztRQUNmLElBQUksQ0FBQ2xFLFlBQVksQ0FBQ2tFLEtBQUs7UUFDdkIsSUFBSSxDQUFDbEQsVUFBVSxDQUFDa0QsS0FBSztRQUNyQixJQUFJLENBQUNLLGtCQUFrQjtJQUN6QjtJQXBYQUMsYUFBYztRQUNaLEtBQUs7YUFuQkM3RSxPQUFPLElBQUlXO2FBQ1hOLGVBQWUsSUFBSU07YUFDbkJKLGdCQUFnQjtZQUFFTSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUM3QkwsYUFBYTtZQUFFSSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUMxQnNELHdCQUF3QjtZQUFFdkQsR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDckNtRCxrQkFBa0I7YUFDbEJoRixTQUFtQztRQUUzQyx1Q0FBdUM7YUFDL0JvQyxhQUFhLElBQUl5RDthQU9SaEQsdUJBQXVCLElBQUssbURBQW1EOztRQUk5RixJQUFJLENBQUNrQixtQkFBbUI7SUFDMUI7QUFrWEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvSW5wdXRNYW5hZ2VyLnRzPzBkMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VudHJhbGl6ZWQgaW5wdXQgaGFuZGxpbmcgc3lzdGVtXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRFdmVudHMge1xuICBrZXlEb3duOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAga2V5VXA6IHsga2V5OiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9O1xuICBtb3VzZURvd246IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlVXA6IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlTW92ZTogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgZGVsdGFYOiBudW1iZXI7IGRlbHRhWTogbnVtYmVyIH07XG4gIHdoZWVsOiB7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlcjsgZGVsdGFaOiBudW1iZXIgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dFN0YXRlIHtcbiAga2V5czogU2V0PHN0cmluZz47XG4gIG1vdXNlOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBkZWx0YVg6IG51bWJlcjtcbiAgICBkZWx0YVk6IG51bWJlcjtcbiAgICBidXR0b25zOiBTZXQ8bnVtYmVyPjtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIG1vdXNlQnV0dG9ucyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwcml2YXRlIG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgcHJpdmF0ZSBtb3VzZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgcHJldmlvdXNNb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIERvdWJsZS10YXAgZGV0ZWN0aW9uIGZvciBkYXNoIHN5c3RlbVxuICBwcml2YXRlIGtleVRpbWluZ3MgPSBuZXcgTWFwPHN0cmluZywgeyBcbiAgICBmaXJzdFByZXNzVGltZTogbnVtYmVyO1xuICAgIGZpcnN0UmVsZWFzZVRpbWU6IG51bWJlcjtcbiAgICBzZWNvbmRQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IGJvb2xlYW47XG4gICAgaGFzVmFsaWRGaXJzdFRhcDogYm9vbGVhbjtcbiAgfT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBET1VCTEVfVEFQX1RIUkVTSE9MRCA9IDIwMDsgLy8gMjAwbXMgd2luZG93IGZvciBkb3VibGUtdGFwIChyZWR1Y2VkIGZyb20gMjUwbXMpXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICAvLyBBZGQgY2FudmFzLXNwZWNpZmljIGV2ZW50IGxpc3RlbmVycyB0byBlbnN1cmUgd2UgY2FwdHVyZSBldmVudHNcbiAgICAvLyB0aGF0IG1pZ2h0IGJlIGhhbmRsZWQgYnkgUmVhY3QgVGhyZWUgRmliZXJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIFxuICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgcmVxdWVzdCBwb2ludGVyIGxvY2sgLSBsZXQgc3lzdGVtcyBoYW5kbGUgdGhpc1xuICAgIC8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAvLyAgIGlmICghdGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAvLyAgICAgdGhpcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1ZXN0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZXhpdFBvaW50ZXJMb2NrKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICB9XG5cbiAgcHVibGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmtleXMuaGFzKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdXNlQnV0dG9uUHJlc3NlZChidXR0b246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vdXNlQnV0dG9ucy5oYXMoYnV0dG9uKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb3VzZVBvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMubW91c2VEZWx0YSB9O1xuICB9XG5cbiAgcHVibGljIGdldElucHV0U3RhdGUoKTogSW5wdXRTdGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IG5ldyBTZXQodGhpcy5rZXlzKSxcbiAgICAgIG1vdXNlOiB7XG4gICAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgICB5OiB0aGlzLm1vdXNlUG9zaXRpb24ueSxcbiAgICAgICAgZGVsdGFYOiB0aGlzLm1vdXNlRGVsdGEueCxcbiAgICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICAgICAgYnV0dG9uczogbmV3IFNldCh0aGlzLm1vdXNlQnV0dG9ucyksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY2hlY2tEb3VibGVUYXAoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIE9ubHkgcmV0dXJuIHRydWUgaWYgd2UgaGF2ZSBhIHZhbGlkIGRvdWJsZS10YXAgc2VxdWVuY2U6XG4gICAgLy8gMS4gV2UgaGF2ZSBhIHZhbGlkIGZpcnN0IHRhcCAocHJlc3MgKyByZWxlYXNlKVxuICAgIC8vIDIuIFdlJ3JlIGN1cnJlbnRseSBpbiBhIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAvLyAzLiBUaGUgc2Vjb25kIHByZXNzIGhhcHBlbmVkIHdpdGhpbiB0aGUgdGhyZXNob2xkIGFmdGVyIHRoZSBmaXJzdCByZWxlYXNlXG4gICAgaWYgKHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwICYmIFxuICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlICYmIFxuICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID4gMCkge1xuICAgICAgXG4gICAgICBjb25zdCB0aW1lQmV0d2VlblRhcHMgPSB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lIC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWU7XG4gICAgICByZXR1cm4gdGltZUJldHdlZW5UYXBzIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldERvdWJsZVRhcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gMDtcbiAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gMDtcbiAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIGVhY2ggZnJhbWVcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIG9sZCB0aW1pbmcgZW50cmllcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgIHRoaXMuY2xlYW51cE9sZFRpbWluZ3MoKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBjbGVhbnVwT2xkVGltaW5ncygpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IENMRUFOVVBfVEhSRVNIT0xEID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSBmb3JFYWNoIGluc3RlYWQgb2YgZm9yLi4ub2YgdG8gYXZvaWQgRVMyMDE1IGl0ZXJhdGlvbiBpc3N1ZXNcbiAgICB0aGlzLmtleVRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBrZXkpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgaW4gYSB3aGlsZVxuICAgICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gTWF0aC5tYXgoXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSwgXG4gICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLCBcbiAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGxhc3RBY3Rpdml0eSA+IDAgJiYgbm93IC0gbGFzdEFjdGl2aXR5ID4gQ0xFQU5VUF9USFJFU0hPTEQpIHtcbiAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIGtleXMgYWZ0ZXIgaXRlcmF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyBtYXAgZHVyaW5nIGl0ZXJhdGlvblxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiB0aGlzLmtleVRpbWluZ3MuZGVsZXRlKGtleSkpO1xuICB9XG4gIFxuICAvLyBEZWJ1ZyBtZXRob2QgdG8gaGVscCB0cmFjayBkb3VibGUgdGFwIGRldGVjdGlvblxuICBwdWJsaWMgZ2V0RG91YmxlVGFwRGVidWdJbmZvKGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleUxvd2VyLFxuICAgICAgZmlyc3RQcmVzc1RpbWU6IHRpbWluZy5maXJzdFByZXNzVGltZSxcbiAgICAgIGZpcnN0UmVsZWFzZVRpbWU6IHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLFxuICAgICAgc2Vjb25kUHJlc3NUaW1lOiB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lLFxuICAgICAgaGFzVmFsaWRGaXJzdFRhcDogdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAsXG4gICAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UsXG4gICAgICB0aW1lU2luY2VGaXJzdFByZXNzOiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UHJlc3NUaW1lIDogMCxcbiAgICAgIHRpbWVTaW5jZUZpcnN0UmVsZWFzZTogdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgOiAwLFxuICAgICAgdGltZVNpbmNlU2Vjb25kUHJlc3M6IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLnNlY29uZFByZXNzVGltZSA6IDAsXG4gICAgICB0aHJlc2hvbGQ6IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTERcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIC8vIFBvaW50ZXIgbG9jayBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IGZvY3VzL2JsdXIgdG8gcmVzZXQgaW5wdXQgc3RhdGVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKCF0aGlzLmtleXMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMua2V5cy5hZGQoa2V5KTtcbiAgICAgIHRoaXMuZW1pdCgna2V5RG93bicsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSB0aW1pbmcgZm9yIGRvdWJsZS10YXAgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgdGltaW5nID0geyBcbiAgICAgICAgICBmaXJzdFByZXNzVGltZTogMCwgXG4gICAgICAgICAgZmlyc3RSZWxlYXNlVGltZTogMCwgXG4gICAgICAgICAgc2Vjb25kUHJlc3NUaW1lOiAwLFxuICAgICAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgaGFzVmFsaWRGaXJzdFRhcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlUaW1pbmdzLnNldChrZXksIHRpbWluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBkb3VibGUtdGFwIHNlcXVlbmNlIGxvZ2ljXG4gICAgICBpZiAoIXRpbWluZy5oYXNWYWxpZEZpcnN0VGFwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHByZXNzXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlOyAvLyBXaWxsIGJlIHNldCB0byB0cnVlIG9uIHJlbGVhc2VcbiAgICAgIH0gZWxzZSBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgIXRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB0aGUgc2Vjb25kIHByZXNzIC0gY2hlY2sgaWYgaXQncyB3aXRoaW4gdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA9IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgICBpZiAodGltZVNpbmNlRmlyc3RSZWxlYXNlIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBWYWxpZCBzZWNvbmQgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBsYXRlIGZvciBkb3VibGUtdGFwLCB0cmVhdCBhcyBuZXcgZmlyc3QgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGZvciBnYW1lIGtleXNcbiAgICBpZiAodGhpcy5pc0dhbWVLZXkoa2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleVVwJywgeyBrZXk6IGV2ZW50LmtleSwgY29kZTogZXZlbnQuY29kZSB9KTtcblxuICAgICAgLy8gVHJhY2sga2V5IHJlbGVhc2UgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXkpO1xuICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGZpcnN0IHRhcFxuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAgICAgICAvLyBUaGUgZG91YmxlLXRhcCBkZXRlY3Rpb24gc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIFJlc2V0IGZvciBuZXh0IHBvdGVudGlhbCBzZXF1ZW5jZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgZGFzaCBzeXN0ZW0gdG8gcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmFkZChldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VEb3duJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZVVwKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuZGVsZXRlKGV2ZW50LmJ1dHRvbik7XG4gICAgdGhpcy5lbWl0KCdtb3VzZVVwJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAgIC8vIFVzZSBtb3ZlbWVudCBkZWx0YXMgd2hlbiBwb2ludGVyIGlzIGxvY2tlZFxuICAgICAgdGhpcy5tb3VzZURlbHRhLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5tb3VzZURlbHRhLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgcG9zaXRpb24gd2hlbiBub3QgbG9ja2VkXG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54ID0gdGhpcy5tb3VzZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55ID0gdGhpcy5tb3VzZVBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBmcm9tIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1vdXNlUG9zaXRpb24ueCAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1vdXNlUG9zaXRpb24ueSAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIC8vIEFjY3VtdWxhdGUgZGVsdGEgZm9yIHRoaXMgZnJhbWVcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGRlbHRhWDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGRlbHRhWTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ21vdXNlTW92ZScsIHtcbiAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnd2hlZWwnLCB7XG4gICAgICBkZWx0YVg6IGV2ZW50LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuICAgICAgZGVsdGFaOiBldmVudC5kZWx0YVosXG4gICAgfSk7XG4gICAgXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0Vycm9yKCk6IHZvaWQge1xuICAgIC8vIGNvbnNvbGUud2FybignUG9pbnRlciBsb2NrIGZhaWxlZCcpO1xuICAgIHRoaXMuaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgaW5wdXQgc3RhdGUgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0ZvY3VzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIHdoZW4gd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dhbWVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBEZWZpbmUgd2hpY2gga2V5cyBzaG91bGQgaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIHByZXZlbnRlZFxuICAgIGNvbnN0IGdhbWVLZXlzID0gWyd3JywgJ2EnLCAncycsICdkJywgJyAnLCAnc2hpZnQnLCAndGFiJywgJ2VzY2FwZSddO1xuICAgIHJldHVybiBnYW1lS2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vblBvaW50ZXJMb2NrQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrZXJyb3InLCB0aGlzLm9uUG9pbnRlckxvY2tFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFJlbW92ZSBjYW52YXMgZXZlbnQgbGlzdGVuZXJzIGlmIGNhbnZhcyBleGlzdHNcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhdGVcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJJbnB1dE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VVcCIsIm9uTW91c2VNb3ZlIiwib25XaGVlbCIsInBhc3NpdmUiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZXF1ZXN0UG9pbnRlckxvY2siLCJleGl0UG9pbnRlckxvY2siLCJkb2N1bWVudCIsImlzS2V5UHJlc3NlZCIsImtleSIsImtleXMiLCJoYXMiLCJ0b0xvd2VyQ2FzZSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwibW91c2VCdXR0b25zIiwiZ2V0TW91c2VQb3NpdGlvbiIsIm1vdXNlUG9zaXRpb24iLCJnZXRNb3VzZURlbHRhIiwibW91c2VEZWx0YSIsImdldElucHV0U3RhdGUiLCJTZXQiLCJtb3VzZSIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYnV0dG9ucyIsImNoZWNrRG91YmxlVGFwIiwia2V5TG93ZXIiLCJ0aW1pbmciLCJrZXlUaW1pbmdzIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImhhc1ZhbGlkRmlyc3RUYXAiLCJpc0luRG91YmxlVGFwU2VxdWVuY2UiLCJzZWNvbmRQcmVzc1RpbWUiLCJ0aW1lQmV0d2VlblRhcHMiLCJmaXJzdFJlbGVhc2VUaW1lIiwiRE9VQkxFX1RBUF9USFJFU0hPTEQiLCJyZXNldERvdWJsZVRhcCIsImZpcnN0UHJlc3NUaW1lIiwidXBkYXRlIiwiY2xlYW51cE9sZFRpbWluZ3MiLCJDTEVBTlVQX1RIUkVTSE9MRCIsImtleXNUb0RlbGV0ZSIsImZvckVhY2giLCJsYXN0QWN0aXZpdHkiLCJNYXRoIiwibWF4IiwicHVzaCIsImRlbGV0ZSIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsInRpbWVTaW5jZUZpcnN0UHJlc3MiLCJ0aW1lU2luY2VGaXJzdFJlbGVhc2UiLCJ0aW1lU2luY2VTZWNvbmRQcmVzcyIsInRocmVzaG9sZCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Qb2ludGVyTG9ja0NoYW5nZSIsIm9uUG9pbnRlckxvY2tFcnJvciIsIndpbmRvdyIsIm9uV2luZG93Qmx1ciIsIm9uV2luZG93Rm9jdXMiLCJldmVudCIsImFkZCIsImVtaXQiLCJjb2RlIiwic2V0IiwiaXNHYW1lS2V5Iiwic2V0VGltZW91dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNQb2ludGVyTG9ja2VkIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwicHJldmlvdXNNb3VzZVBvc2l0aW9uIiwiZGVsdGFaIiwicG9pbnRlckxvY2tFbGVtZW50IiwiY2xlYXIiLCJnYW1lS2V5cyIsImluY2x1ZGVzIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {}\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component && componentType) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {}\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n            // Only warn if it's not a minified single-letter class name\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {}\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        if (componentType) {\n            const components = Array.from(this.components.values());\n            for (const comp of components){\n                if (comp instanceof componentType) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.userData = {} // For storing arbitrary data like player IDs\n        ;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksQ0FBQ1QsVUFBVSxDQUFDeUIsSUFBSTtJQUN4QztJQUVPQyxXQUFvQjtRQUN6QixPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUNwQjtJQUVPQyxVQUFVRCxNQUFlLEVBQVE7UUFDdEMsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2hCO0lBRU9FLFVBQWdCO1FBQ3JCLElBQUksQ0FBQzdCLFVBQVUsQ0FBQzhCLEtBQUs7UUFDckIsSUFBSSxDQUFDSCxNQUFNLEdBQUc7SUFDaEI7SUF6R0E3QixhQUFjO2FBSk5FLGFBQWEsSUFBSStCO2FBQ2pCSixTQUFTO2FBQ1ZLLFdBQWdCLENBQUMsRUFBRyw2Q0FBNkM7O1FBR3RFLElBQUksQ0FBQ0MsRUFBRSxHQUFHeEMsT0FBT3lDLE1BQU07SUFDekI7QUF3R0Y7QUFqSGF6QyxPQUNJeUMsU0FBbUI7QUFrSDdCLE1BQWVDOzthQUNiQyxVQUFVOztBQUduQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL0VudGl0eS50cz81ZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gRW50aXR5IE1hbmFnZW1lbnRcbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gbnVtYmVyO1xuXG5leHBvcnQgY2xhc3MgRW50aXR5IHtcbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dElkOiBFbnRpdHlJZCA9IDE7XG4gIHB1YmxpYyByZWFkb25seSBpZDogRW50aXR5SWQ7XG4gIHByaXZhdGUgY29tcG9uZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBDb21wb25lbnQ+KCk7XG4gIHByaXZhdGUgYWN0aXZlID0gdHJ1ZTtcbiAgcHVibGljIHVzZXJEYXRhOiBhbnkgPSB7fTsgLy8gRm9yIHN0b3JpbmcgYXJiaXRyYXJ5IGRhdGEgbGlrZSBwbGF5ZXIgSURzXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IEVudGl0eS5uZXh0SWQrKztcbiAgfVxuXG4gIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50OiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzLmdldChyZXF1ZXN0ZWRUeXBlKTtcbiAgICBcbiAgICAvLyBJZiBub3QgZm91bmQgd2l0aCBleHBsaWNpdCB0eXBlLCB0cnkgc2VhcmNoaW5nIGJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoIWNvbXBvbmVudCAmJiAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgY29tcG9uZW50cyB0byBmaW5kIGEgbWF0Y2ggYnkgdHlwZVxuICAgIGlmICghY29tcG9uZW50ICYmIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuY29tcG9uZW50cy5lbnRyaWVzKCkpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBjb21wXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChjb21wIGluc3RhbmNlb2YgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgIC8vIFJlZHVjZSBzcGFtIC0gb25seSBsb2cgb2NjYXNpb25hbGx5IGZvciBpbnN0YW5jZW9mIGZhbGxiYWNrIHVzYWdlXG4gICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxKSB7IC8vIE9ubHkgbG9nIDElIG9mIHRoZSB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHJlcXVlc3RlZFR5cGUgJiYgIWNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lLm1hdGNoKC9eW2Etel0kLykpIHtcbiAgICAgICAgLy8gT25seSB3YXJuIGlmIGl0J3Mgbm90IGEgbWluaWZpZWQgc2luZ2xlLWxldHRlciBjbGFzcyBuYW1lXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZHVjZSBzcGFtIC0gb25seSBsb2cgb2NjYXNpb25hbGx5IGZvciBtaXNzaW5nIGNvbXBvbmVudHNcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMDEpIHsgLy8gT25seSBsb2cgMC4xJSBvZiB0aGUgdGltZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY29tcG9uZW50IGFzIFQ7XG4gIH1cblxuICBwdWJsaWMgaGFzQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogYm9vbGVhbiB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgcmVxdWVzdGVkVHlwZSA9IChjb21wb25lbnRUeXBlIGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnRUeXBlLm5hbWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgd2l0aCBleHBsaWNpdCB0eXBlIGZpcnN0XG4gICAgaWYgKHRoaXMuY29tcG9uZW50cy5oYXMocmVxdWVzdGVkVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBub3QgZm91bmQgd2l0aCBleHBsaWNpdCB0eXBlLCB0cnkgY29uc3RydWN0b3IgbmFtZSBhcyBmYWxsYmFja1xuICAgIGlmICgoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgJiYgdGhpcy5jb21wb25lbnRzLmhhcyhjb21wb25lbnRUeXBlLm5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgY29tcG9uZW50cyB0byBmaW5kIGEgbWF0Y2ggYnkgdHlwZVxuICAgIGlmIChjb21wb25lbnRUeXBlKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICAgICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGhhc0NvbXBvbmVudHMoY29tcG9uZW50VHlwZXM6IChuZXcgKCkgPT4gQ29tcG9uZW50KVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNvbXBvbmVudFR5cGVzLmV2ZXJ5KHR5cGUgPT4gdGhpcy5oYXNDb21wb25lbnQodHlwZSkpO1xuICB9XG5cbiAgcHVibGljIGdldEFsbENvbXBvbmVudHMoKTogQ29tcG9uZW50W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29tcG9uZW50cy52YWx1ZXMoKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29tcG9uZW50TmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29tcG9uZW50cy5rZXlzKCkpO1xuICB9XG5cbiAgcHVibGljIGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBY3RpdmUoYWN0aXZlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmNvbXBvbmVudHMuY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21wb25lbnQge1xuICBwdWJsaWMgZW5hYmxlZCA9IHRydWU7XG4gIFxuICBwdWJsaWMgYWJzdHJhY3QgcmVzZXQoKTogdm9pZDsgLy8gRm9yIG9iamVjdCBwb29saW5nXG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiYWRkQ29tcG9uZW50IiwiY29tcG9uZW50IiwiY29tcG9uZW50TmFtZSIsImNvbXBvbmVudFR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjb21wb25lbnRzIiwic2V0IiwicmVtb3ZlQ29tcG9uZW50IiwiZGVsZXRlIiwiZ2V0Q29tcG9uZW50IiwicmVxdWVzdGVkVHlwZSIsImdldCIsImVudHJpZXMiLCJBcnJheSIsImZyb20iLCJrZXkiLCJjb21wIiwiTWF0aCIsInJhbmRvbSIsImFjdHVhbFR5cGUiLCJtYXRjaCIsImhhc0NvbXBvbmVudCIsImhhcyIsInZhbHVlcyIsImhhc0NvbXBvbmVudHMiLCJjb21wb25lbnRUeXBlcyIsImV2ZXJ5IiwidHlwZSIsImdldEFsbENvbXBvbmVudHMiLCJnZXRDb21wb25lbnROYW1lcyIsImtleXMiLCJpc0FjdGl2ZSIsImFjdGl2ZSIsInNldEFjdGl2ZSIsImRlc3Ryb3kiLCJjbGVhciIsIk1hcCIsInVzZXJEYXRhIiwiaWQiLCJuZXh0SWQiLCJDb21wb25lbnQiLCJlbmFibGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBRTtnQkFDakNEO2FBQUFBLG9CQUFBQSxPQUFPMEIsU0FBUyxjQUFoQjFCLHdDQUFBQSx1QkFBQUE7UUFDRjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUQsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQzNDLGFBQWEsQ0FBQzJDLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUMxQyxjQUFjLENBQUMwQyxNQUFNLEdBQUc7UUFFN0Isd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3JCLGNBQWMsQ0FBQ2lDLEtBQUs7UUFFekIsZUFBZTtRQUNmLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxLQUFLO0lBQ25COzthQTNOUTlFLFdBQVcsSUFBSStFO2FBQ2Z0RSxVQUFvQixFQUFFO2FBQ3RCYyxnQkFBZ0MsRUFBRTthQUNsQ0MsaUJBQWtDLEVBQUU7YUFDcENxQixpQkFBaUIsSUFBSWtDO2FBQ3JCMUUsb0JBQWdDLEVBQUU7YUFDbENxRSxTQUFTLElBQUlLOztBQXNOdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9Xb3JsZC50cz8zMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gV29ybGQgTWFuYWdlbWVudFxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlJZCwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgU3lzdGVtLCBSZW5kZXJTeXN0ZW0sIFBoeXNpY3NTeXN0ZW0gfSBmcm9tICcuL1N5c3RlbSc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuZXhwb3J0IGNsYXNzIFdvcmxkIHtcbiAgcHJpdmF0ZSBlbnRpdGllcyA9IG5ldyBNYXA8RW50aXR5SWQsIEVudGl0eT4oKTtcbiAgcHJpdmF0ZSBzeXN0ZW1zOiBTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHJlbmRlclN5c3RlbXM6IFJlbmRlclN5c3RlbVtdID0gW107XG4gIHByaXZhdGUgcGh5c2ljc1N5c3RlbXM6IFBoeXNpY3NTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudFBvb2xzID0gbmV3IE1hcDxzdHJpbmcsIE9iamVjdFBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSBlbnRpdGllc1RvRGVzdHJveTogRW50aXR5SWRbXSA9IFtdO1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcblxuICAvLyBFbnRpdHkgbWFuYWdlbWVudFxuICBwdWJsaWMgY3JlYXRlRW50aXR5KCk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSgpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lFbnRpdHkoZW50aXR5SWQ6IEVudGl0eUlkKTogdm9pZCB7XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5wdXNoKGVudGl0eUlkKTtcbiAgfVxuXG4gIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgYW4gZW50aXR5IGhhcyBiZWVuIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIGlzIHJlYWR5XG4gIHB1YmxpYyBub3RpZnlFbnRpdHlBZGRlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eUFkZGVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLm9uRW50aXR5QWRkZWQoZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IEVudGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxFbnRpdGllcygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTeXN0ZW0gbWFuYWdlbWVudFxuICBwdWJsaWMgYWRkU3lzdGVtKHN5c3RlbTogU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFJlbmRlclN5c3RlbSkge1xuICAgICAgdGhpcy5yZW5kZXJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFBoeXNpY3NTeXN0ZW0pIHtcbiAgICAgIHRoaXMucGh5c2ljc1N5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIHN5c3RlbS5vbkVuYWJsZT8uKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtPFQgZXh0ZW5kcyBTeXN0ZW0+KHN5c3RlbUNsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3lzdGVtcy5maW5kKHN5c3RlbSA9PiBzeXN0ZW0gaW5zdGFuY2VvZiBzeXN0ZW1DbGFzcykgYXMgVCB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTeXN0ZW0oc3lzdGVtVHlwZTogbmV3ICgpID0+IFN5c3RlbSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbXNbaW5kZXhdO1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gc3BlY2lhbGl6ZWQgYXJyYXlzXG4gICAgICBjb25zdCByZW5kZXJJbmRleCA9IHRoaXMucmVuZGVyU3lzdGVtcy5maW5kSW5kZXgocyA9PiBzID09PSBzeXN0ZW0pO1xuICAgICAgaWYgKHJlbmRlckluZGV4ICE9PSAtMSkgdGhpcy5yZW5kZXJTeXN0ZW1zLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG5cbiAgICAgIGNvbnN0IHBoeXNpY3NJbmRleCA9IHRoaXMucGh5c2ljc1N5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChwaHlzaWNzSW5kZXggIT09IC0xKSB0aGlzLnBoeXNpY3NTeXN0ZW1zLnNwbGljZShwaHlzaWNzSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBvbmVudCBwb29saW5nIGZvciBwZXJmb3JtYW5jZVxuICBwdWJsaWMgY3JlYXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgdHlwZU5hbWUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIERpc2FibGUgcG9vbGluZyBmb3IgY29tcG9uZW50cyB0aGF0IGhhdmUgcHJvdG90eXBlIG1ldGhvZCBpc3N1ZXMgaW4gcHJvZHVjdGlvblxuICAgIGNvbnN0IHByb2JsZW1hdGljQ29tcG9uZW50cyA9IFsnSGVhbHRoJywgJ0hlYWx0aEJhcicsICdUcmFuc2Zvcm0nLCAnTW92ZW1lbnQnLCAnQ29sbGlkZXInLCAnUmVuZGVyZXInLCAnRW5lbXknLCAnUHJvamVjdGlsZScsICdBbmltYXRpb24nXTtcbiAgICBpZiAocHJvYmxlbWF0aWNDb21wb25lbnRzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnRUeXBlKCk7XG4gICAgfVxuICAgIFxuICAgIGxldCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQodHlwZU5hbWUpO1xuICAgIFxuICAgIGlmICghcG9vbCkge1xuICAgICAgcG9vbCA9IG5ldyBPYmplY3RQb29sPFQ+KCgpID0+IG5ldyBjb21wb25lbnRUeXBlKCksIChvYmopID0+IG9iai5yZXNldCgpLCAxMDApO1xuICAgICAgdGhpcy5jb21wb25lbnRQb29scy5zZXQodHlwZU5hbWUsIHBvb2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9vbC5hY3F1aXJlKCk7XG4gIH1cblxuICBwdWJsaWMgcmV0dXJuQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmNvbXBvbmVudFBvb2xzLmdldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHBvb2wucmVsZWFzZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1haW4gdXBkYXRlIGxvb3BcbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICAgIHRoaXMuY2xlYW51cERlc3Ryb3llZEVudGl0aWVzKCk7XG5cbiAgICAvLyBVcGRhdGUgYWxsIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnVwZGF0ZShtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHBoeXNpY3MgdXBkYXRlXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5waHlzaWNzU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0uZml4ZWRVcGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB1cGRhdGVcbiAgcHVibGljIHJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucmVuZGVyU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ucmVuZGVyKG1hdGNoaW5nRW50aXRpZXMsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggYSBzeXN0ZW0ncyByZXF1aXJlbWVudHNcbiAgcHJpdmF0ZSBnZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKSB7XG4gICAgICBpZiAoc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICBwcml2YXRlIGNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgLy8gTm90aWZ5IHN5c3RlbXMgYWJvdXQgZW50aXR5IHJlbW92YWxcbiAgICAgICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eVJlbW92ZWQgJiYgc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICAgICAgc3lzdGVtLm9uRW50aXR5UmVtb3ZlZChlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGNvbXBvbmVudHMgdG8gcG9vbHNcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmdldEFsbENvbXBvbmVudHMoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gUXVlcnkgZW50aXRpZXMgYnkgY29tcG9uZW50c1xuICBwdWJsaWMgcXVlcnlFbnRpdGllcyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzKSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIEV2ZW50IHN5c3RlbVxuICBwdWJsaWMgZW1pdEV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudERhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSkhLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIHx8IFtdO1xuICB9XG5cbiAgcHVibGljIGNsZWFyRXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgW10pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGVudGl0aWVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYW4gdXAgc3lzdGVtc1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVuZGVyU3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGh5c2ljc1N5c3RlbXMubGVuZ3RoID0gMDtcblxuICAgIC8vIENsZWFyIGNvbXBvbmVudCBwb29sc1xuICAgIHRoaXMuY29tcG9uZW50UG9vbHMuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBDbGVhciBldmVudHNcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSIsIk9iamVjdFBvb2wiLCJXb3JsZCIsImNyZWF0ZUVudGl0eSIsImVudGl0eSIsImVudGl0aWVzIiwic2V0IiwiaWQiLCJkZXN0cm95RW50aXR5IiwiZW50aXR5SWQiLCJlbnRpdGllc1RvRGVzdHJveSIsInB1c2giLCJub3RpZnlFbnRpdHlBZGRlZCIsInN5c3RlbSIsInN5c3RlbXMiLCJvbkVudGl0eUFkZGVkIiwibWF0Y2hlc0VudGl0eSIsImdldEVudGl0eSIsImdldCIsImdldEFsbEVudGl0aWVzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYWRkU3lzdGVtIiwic29ydCIsImEiLCJiIiwicHJpb3JpdHkiLCJyZW5kZXJTeXN0ZW1zIiwicGh5c2ljc1N5c3RlbXMiLCJvbkVuYWJsZSIsImdldFN5c3RlbSIsInN5c3RlbUNsYXNzIiwiZmluZCIsInJlbW92ZVN5c3RlbSIsInN5c3RlbVR5cGUiLCJpbmRleCIsImZpbmRJbmRleCIsInMiLCJvbkRpc2FibGUiLCJzcGxpY2UiLCJyZW5kZXJJbmRleCIsInBoeXNpY3NJbmRleCIsImNyZWF0ZUNvbXBvbmVudCIsImNvbXBvbmVudFR5cGUiLCJ0eXBlTmFtZSIsIm5hbWUiLCJwcm9ibGVtYXRpY0NvbXBvbmVudHMiLCJpbmNsdWRlcyIsInBvb2wiLCJjb21wb25lbnRQb29scyIsIm9iaiIsInJlc2V0IiwiYWNxdWlyZSIsInJldHVybkNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsInVwZGF0ZSIsImRlbHRhVGltZSIsImNsZWFudXBEZXN0cm95ZWRFbnRpdGllcyIsImVuYWJsZWQiLCJtYXRjaGluZ0VudGl0aWVzIiwiZ2V0RW50aXRpZXNGb3JTeXN0ZW0iLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwicmVuZGVyIiwib25FbnRpdHlSZW1vdmVkIiwiZ2V0QWxsQ29tcG9uZW50cyIsImRlc3Ryb3kiLCJkZWxldGUiLCJsZW5ndGgiLCJxdWVyeUVudGl0aWVzIiwiY29tcG9uZW50VHlwZXMiLCJpc0FjdGl2ZSIsImhhc0NvbXBvbmVudHMiLCJlbWl0RXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJldmVudHMiLCJoYXMiLCJnZXRFdmVudHMiLCJjbGVhckV2ZW50cyIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n        // Clear corrupted status on respawn\n        this.removeCorrupted();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    getEffectiveMovementSpeed() {\n        if (this.isDead || this.isFrozen) {\n            return 0;\n        }\n        let speed = this.movementSpeed;\n        // Apply corrupted debuff slow effect\n        if (this.isCorrupted) {\n            const slowMultiplier = this.getCorruptedSlowMultiplier();\n            speed *= 1 - slowMultiplier;\n        }\n        return speed;\n    }\n    getCorruptedSlowMultiplier() {\n        if (!this.isCorrupted) return 0;\n        const currentTime = Date.now() / 1000;\n        const elapsed = currentTime - this.corruptedStartTime;\n        // Calculate current slow percentage based on gradual recovery\n        // Initial: 90% slow, recovers 10% per second\n        const currentSlowPercent = Math.max(0, this.corruptedInitialSlowPercent - elapsed * this.corruptedRecoveryRate);\n        return currentSlowPercent;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    applySunderStack(currentTime) {\n        if (this.isDead) return; // Can't apply sunder to dead enemies\n        // Check if existing stacks have expired\n        if (this.sunderStacks > 0 && currentTime - this.sunderLastApplied > this.sunderDuration) {\n            this.sunderStacks = 0;\n        }\n        // Add new stack (max 3)\n        if (this.sunderStacks < 3) {\n            this.sunderStacks++;\n        }\n        // Update timing\n        this.sunderLastApplied = currentTime;\n    }\n    getSunderStacks() {\n        return this.sunderStacks;\n    }\n    clearSunderStacks() {\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    updateSunderStatus(currentTime) {\n        if (this.sunderStacks <= 0) return;\n        const elapsed = currentTime - this.sunderLastApplied;\n        if (elapsed >= this.sunderDuration) {\n            this.clearSunderStacks();\n        }\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Reset sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        // Clone sunder stacks\n        clone.sunderStacks = this.sunderStacks;\n        clone.sunderLastApplied = this.sunderLastApplied;\n        // Clone corrupted status\n        clone.isCorrupted = this.isCorrupted;\n        clone.corruptedStartTime = this.corruptedStartTime;\n        clone.corruptedDuration = this.corruptedDuration;\n        clone.corruptedInitialSlowPercent = this.corruptedInitialSlowPercent;\n        clone.corruptedRecoveryRate = this.corruptedRecoveryRate;\n        return clone;\n    }\n    applyCorrupted(duration, currentTime) {\n        if (this.isDead) return; // Can't apply corrupted to dead enemies\n        this.isCorrupted = true;\n        this.corruptedStartTime = currentTime;\n        this.corruptedDuration = duration;\n        console.log(\"\\uD83D\\uDC7B Applied Corrupted debuff to \".concat(this.getDisplayName(), \" for \").concat(duration, \" seconds\"));\n    }\n    removeCorrupted() {\n        this.isCorrupted = false;\n        this.corruptedStartTime = 0;\n        this.corruptedDuration = 0;\n    }\n    updateCorruptedStatus(currentTime) {\n        if (!this.isCorrupted) return;\n        const elapsed = currentTime - this.corruptedStartTime;\n        if (elapsed >= this.corruptedDuration) {\n            this.removeCorrupted();\n            console.log(\"\\uD83D\\uDC7B Corrupted debuff expired on \".concat(this.getDisplayName()));\n        }\n    }\n    getCorruptedTimeRemaining(currentTime) {\n        if (!this.isCorrupted) return 0;\n        const elapsed = currentTime - this.corruptedStartTime;\n        return Math.max(0, this.corruptedDuration - elapsed);\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Initialize sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n        this.sunderDuration = 10.0; // 10 seconds\n        // Initialize burning stacks\n        this.burningStacks = 0;\n        this.burningLastApplied = 0;\n        this.burningDuration = 5.0; // 5 seconds\n        // Initialize corrupted debuff\n        this.isCorrupted = false;\n        this.corruptedStartTime = 0;\n        this.corruptedDuration = 8.0; // 8 seconds\n        this.corruptedInitialSlowPercent = 0.9; // 90% slow initially\n        this.corruptedRecoveryRate = 0.1; // 10% recovery per second\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQW9HMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixF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QUNLLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ2tDLGlCQUFpQixHQUFHLEtBQUssWUFBWTtRQUMxQyxJQUFJLENBQUM5QiwyQkFBMkIsR0FBRyxLQUFLLHFCQUFxQjtRQUM3RCxJQUFJLENBQUNDLHFCQUFxQixHQUFHLEtBQUssMEJBQTBCO0lBQzlEO0FBdVdGO0FBemNhdEQsTUFDWTBGLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcbiAgXG4gIC8vIFN1bmRlciBzdGFja3MgZWZmZWN0XG4gIHB1YmxpYyBzdW5kZXJTdGFja3M6IG51bWJlcjtcbiAgcHVibGljIHN1bmRlckxhc3RBcHBsaWVkOiBudW1iZXI7XG4gIHB1YmxpYyBzdW5kZXJEdXJhdGlvbjogbnVtYmVyO1xuICBcbiAgLy8gQnVybmluZyBzdGFja3MgZWZmZWN0IChFbnRyb3BpYyBCb2x0IC8gQ3Jvc3NlbnRyb3B5IEJvbHQpXG4gIHB1YmxpYyBidXJuaW5nU3RhY2tzOiBudW1iZXI7XG4gIHB1YmxpYyBidXJuaW5nTGFzdEFwcGxpZWQ6IG51bWJlcjtcbiAgcHVibGljIGJ1cm5pbmdEdXJhdGlvbjogbnVtYmVyO1xuICBcbiAgLy8gQ29ycnVwdGVkIGRlYnVmZiBlZmZlY3QgKFdyYWl0aFN0cmlrZSlcbiAgcHVibGljIGlzQ29ycnVwdGVkOiBib29sZWFuO1xuICBwdWJsaWMgY29ycnVwdGVkU3RhcnRUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyBjb3JydXB0ZWREdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgY29ycnVwdGVkSW5pdGlhbFNsb3dQZXJjZW50OiBudW1iZXI7IC8vIEluaXRpYWwgc2xvdyBwZXJjZW50YWdlICg5MCUpXG4gIHB1YmxpYyBjb3JydXB0ZWRSZWNvdmVyeVJhdGU6IG51bWJlcjsgLy8gUmVjb3ZlcnkgcmF0ZSBwZXIgc2Vjb25kICgxMCUpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdHlwZTogRW5lbXlUeXBlID0gRW5lbXlUeXBlLkRVTU1ZLFxuICAgIGxldmVsOiBudW1iZXIgPSAxXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5jYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk7XG4gICAgdGhpcy5pc0FnZ3Jlc3NpdmUgPSB0eXBlICE9PSBFbmVteVR5cGUuRFVNTVk7XG4gICAgdGhpcy5hZ2dyb1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBZ2dyb1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24oKTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSB0aGlzLmNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLnJlc3Bhd25UaW1lID0gMzA7IC8vIDMwIHNlY29uZHMgZGVmYXVsdCByZXNwYXduIHRpbWVcbiAgICB0aGlzLmNhblJlc3Bhd24gPSB0cnVlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgZnJlZXplIHN0YXR1c1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyZWV6ZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm1vdmVtZW50U3BlZWQ7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB2ZW5vbSBzdGF0dXNcbiAgICB0aGlzLmlzVmVub21vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnZlbm9tU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSAwO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IDA7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBzdW5kZXIgc3RhY2tzXG4gICAgdGhpcy5zdW5kZXJTdGFja3MgPSAwO1xuICAgIHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQgPSAwO1xuICAgIHRoaXMuc3VuZGVyRHVyYXRpb24gPSAxMC4wOyAvLyAxMCBzZWNvbmRzXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBidXJuaW5nIHN0YWNrc1xuICAgIHRoaXMuYnVybmluZ1N0YWNrcyA9IDA7XG4gICAgdGhpcy5idXJuaW5nTGFzdEFwcGxpZWQgPSAwO1xuICAgIHRoaXMuYnVybmluZ0R1cmF0aW9uID0gNS4wOyAvLyA1IHNlY29uZHNcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGNvcnJ1cHRlZCBkZWJ1ZmZcbiAgICB0aGlzLmlzQ29ycnVwdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb3JydXB0ZWRTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuY29ycnVwdGVkRHVyYXRpb24gPSA4LjA7IC8vIDggc2Vjb25kc1xuICAgIHRoaXMuY29ycnVwdGVkSW5pdGlhbFNsb3dQZXJjZW50ID0gMC45OyAvLyA5MCUgc2xvdyBpbml0aWFsbHlcbiAgICB0aGlzLmNvcnJ1cHRlZFJlY292ZXJ5UmF0ZSA9IDAuMTsgLy8gMTAlIHJlY292ZXJ5IHBlciBzZWNvbmRcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VFeHAgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogNSxcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxMCxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAyNSxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VFeHBbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhZ2dyb1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogOCxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEyXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja1JhbmdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVJhbmdlID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDIsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAzXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VEYW1hZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBkZWFsIGRhbWFnZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDE1LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogNTBcbiAgICB9O1xuICAgIHJldHVybiBiYXNlRGFtYWdlW3RoaXMudHlwZV0gKiB0aGlzLmxldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdHRhY2tDb29sZG93bigpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VDb29sZG93biA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGF0dGFja1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDIsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VDb29sZG93blt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVNwZWVkID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgbW92ZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDMsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMCwgLy8gRWxpdGUgZW5lbWllcyBhcmUgc3RhdGlvbmFyeSBsaWtlIHRyYWluaW5nIGR1bW1pZXNcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDIuNVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VTcGVlZFt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWdncmVzc2l2ZSB8fCB0aGlzLmlzRGVhZCB8fCB0aGlzLmF0dGFja0RhbWFnZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgdGFrZURhbWFnZSgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgSGVhbHRoIGNvbXBvbmVudFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGZvciBlbmVteS1zcGVjaWZpYyBkYW1hZ2UgcmVhY3Rpb25zXG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FuUmVzcGF3biB8fCAhdGhpcy5pc0RlYWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMuZGVhdGhUaW1lKSA+PSB0aGlzLnJlc3Bhd25UaW1lO1xuICB9XG5cbiAgcHVibGljIHJlc3Bhd24oKTogdm9pZCB7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgLy8gQ2xlYXIgZnJlZXplIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy51bmZyZWV6ZSgpO1xuICAgIC8vIENsZWFyIHZlbm9tIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICAgIC8vIENsZWFyIGNvcnJ1cHRlZCBzdGF0dXMgb24gcmVzcGF3blxuICAgIHRoaXMucmVtb3ZlQ29ycnVwdGVkKCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBmcmVlemUoZHVyYXRpb246IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBmcmVlemUgZGVhZCBlbmVtaWVzXG4gICAgXG4gICAgdGhpcy5pc0Zyb3plbiA9IHRydWU7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgLy8gU2V0IG1vdmVtZW50IHNwZWVkIHRvIDAgd2hlbiBmcm96ZW5cbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdW5mcmVlemUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1vdmVtZW50IHNwZWVkXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVGcmVlemVTdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc0Zyb3plbikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMuZnJlZXplRHVyYXRpb24pIHtcbiAgICAgIHRoaXMudW5mcmVlemUoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHB1YmxpYyBjYW5Nb3ZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc0Zyb3plbiAmJiAhdGhpcy5pc0RlYWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXRFZmZlY3RpdmVNb3ZlbWVudFNwZWVkKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNEZWFkIHx8IHRoaXMuaXNGcm96ZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBcbiAgICBsZXQgc3BlZWQgPSB0aGlzLm1vdmVtZW50U3BlZWQ7XG4gICAgXG4gICAgLy8gQXBwbHkgY29ycnVwdGVkIGRlYnVmZiBzbG93IGVmZmVjdFxuICAgIGlmICh0aGlzLmlzQ29ycnVwdGVkKSB7XG4gICAgICBjb25zdCBzbG93TXVsdGlwbGllciA9IHRoaXMuZ2V0Q29ycnVwdGVkU2xvd011bHRpcGxpZXIoKTtcbiAgICAgIHNwZWVkICo9ICgxIC0gc2xvd011bHRpcGxpZXIpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3BlZWQ7XG4gIH1cbiAgXG4gIHByaXZhdGUgZ2V0Q29ycnVwdGVkU2xvd011bHRpcGxpZXIoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuaXNDb3JydXB0ZWQpIHJldHVybiAwO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5jb3JydXB0ZWRTdGFydFRpbWU7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgc2xvdyBwZXJjZW50YWdlIGJhc2VkIG9uIGdyYWR1YWwgcmVjb3ZlcnlcbiAgICAvLyBJbml0aWFsOiA5MCUgc2xvdywgcmVjb3ZlcnMgMTAlIHBlciBzZWNvbmRcbiAgICBjb25zdCBjdXJyZW50U2xvd1BlcmNlbnQgPSBNYXRoLm1heCgwLCB0aGlzLmNvcnJ1cHRlZEluaXRpYWxTbG93UGVyY2VudCAtIChlbGFwc2VkICogdGhpcy5jb3JydXB0ZWRSZWNvdmVyeVJhdGUpKTtcbiAgICBcbiAgICByZXR1cm4gY3VycmVudFNsb3dQZXJjZW50O1xuICB9XG4gIFxuICBwdWJsaWMgYXBwbHlWZW5vbShkdXJhdGlvbjogbnVtYmVyLCBkYW1hZ2VQZXJTZWNvbmQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSB2ZW5vbSB0byBkZWFkIGVuZW1pZXNcbiAgICBcbiAgICB0aGlzLmlzVmVub21vdXMgPSB0cnVlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gZGFtYWdlUGVyU2Vjb25kO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgcmVtb3ZlVmVub20oKTogdm9pZCB7XG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVmVub21TdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHsgc2hvdWxkRGVhbERhbWFnZTogYm9vbGVhbjsgZGFtYWdlOiBudW1iZXIgfSB7XG4gICAgaWYgKCF0aGlzLmlzVmVub21vdXMpIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLnZlbm9tU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMudmVub21EdXJhdGlvbikge1xuICAgICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZGVhbCBkYW1hZ2UgKGV2ZXJ5IHNlY29uZClcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0RGFtYWdlID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3REYW1hZ2UgPj0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IHRydWUsIGRhbWFnZTogdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gIH1cbiAgXG4gIHB1YmxpYyBhcHBseVN1bmRlclN0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RlYWQpIHJldHVybjsgLy8gQ2FuJ3QgYXBwbHkgc3VuZGVyIHRvIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGV4aXN0aW5nIHN0YWNrcyBoYXZlIGV4cGlyZWRcbiAgICBpZiAodGhpcy5zdW5kZXJTdGFja3MgPiAwICYmIChjdXJyZW50VGltZSAtIHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQpID4gdGhpcy5zdW5kZXJEdXJhdGlvbikge1xuICAgICAgdGhpcy5zdW5kZXJTdGFja3MgPSAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgbmV3IHN0YWNrIChtYXggMylcbiAgICBpZiAodGhpcy5zdW5kZXJTdGFja3MgPCAzKSB7XG4gICAgICB0aGlzLnN1bmRlclN0YWNrcysrO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdGltaW5nXG4gICAgdGhpcy5zdW5kZXJMYXN0QXBwbGllZCA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgZ2V0U3VuZGVyU3RhY2tzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3VuZGVyU3RhY2tzO1xuICB9XG4gIFxuICBwdWJsaWMgY2xlYXJTdW5kZXJTdGFja3MoKTogdm9pZCB7XG4gICAgdGhpcy5zdW5kZXJTdGFja3MgPSAwO1xuICAgIHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlU3VuZGVyU3RhdHVzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdW5kZXJTdGFja3MgPD0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQ7XG4gICAgaWYgKGVsYXBzZWQgPj0gdGhpcy5zdW5kZXJEdXJhdGlvbikge1xuICAgICAgdGhpcy5jbGVhclN1bmRlclN0YWNrcygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRMZXZlbChuZXdMZXZlbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sZXZlbCA9IE1hdGgubWF4KDEsIG5ld0xldmVsKTtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGlzcGxheU5hbWUoKTogc3RyaW5nIHtcbiAgICBjb25zdCB0eXBlTmFtZXMgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogJ1RyYWluaW5nIER1bW15JyxcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAnR3J1bnQnLFxuICAgICAgW0VuZW15VHlwZS5FTElURV06ICdFbGl0ZScsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAnQm9zcydcbiAgICB9O1xuICAgIHJldHVybiBgJHt0eXBlTmFtZXNbdGhpcy50eXBlXX0gKEx2LiR7dGhpcy5sZXZlbH0pYDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnR5cGUgPSBFbmVteVR5cGUuRFVNTVk7XG4gICAgdGhpcy5sZXZlbCA9IDE7XG4gICAgdGhpcy5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5jYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk7XG4gICAgdGhpcy5pc0FnZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmFnZ3JvUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tSYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tDb29sZG93bigpO1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMuY2FsY3VsYXRlTW92ZW1lbnRTcGVlZCgpO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMucmVzcGF3blRpbWUgPSAzMDtcbiAgICB0aGlzLmNhblJlc3Bhd24gPSB0cnVlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgZnJlZXplIHN0YXR1c1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyZWV6ZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm1vdmVtZW50U3BlZWQ7XG4gICAgXG4gICAgLy8gUmVzZXQgdmVub20gc3RhdHVzXG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICAgIFxuICAgIC8vIFJlc2V0IHN1bmRlciBzdGFja3NcbiAgICB0aGlzLnN1bmRlclN0YWNrcyA9IDA7XG4gICAgdGhpcy5zdW5kZXJMYXN0QXBwbGllZCA9IDA7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogRW5lbXkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEVuZW15KHRoaXMudHlwZSwgdGhpcy5sZXZlbCk7XG4gICAgY2xvbmUuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuZXhwZXJpZW5jZVJld2FyZDtcbiAgICBjbG9uZS5pc0FnZ3Jlc3NpdmUgPSB0aGlzLmlzQWdncmVzc2l2ZTtcbiAgICBjbG9uZS5hZ2dyb1JhbmdlID0gdGhpcy5hZ2dyb1JhbmdlO1xuICAgIGNsb25lLmF0dGFja1JhbmdlID0gdGhpcy5hdHRhY2tSYW5nZTtcbiAgICBjbG9uZS5hdHRhY2tEYW1hZ2UgPSB0aGlzLmF0dGFja0RhbWFnZTtcbiAgICBjbG9uZS5hdHRhY2tDb29sZG93biA9IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gICAgY2xvbmUubGFzdEF0dGFja1RpbWUgPSB0aGlzLmxhc3RBdHRhY2tUaW1lO1xuICAgIGNsb25lLm1vdmVtZW50U3BlZWQgPSB0aGlzLm1vdmVtZW50U3BlZWQ7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuZGVhdGhUaW1lID0gdGhpcy5kZWF0aFRpbWU7XG4gICAgY2xvbmUucmVzcGF3blRpbWUgPSB0aGlzLnJlc3Bhd25UaW1lO1xuICAgIGNsb25lLmNhblJlc3Bhd24gPSB0aGlzLmNhblJlc3Bhd247XG4gICAgXG4gICAgLy8gQ2xvbmUgZnJlZXplIHN0YXR1c1xuICAgIGNsb25lLmlzRnJvemVuID0gdGhpcy5pc0Zyb3plbjtcbiAgICBjbG9uZS5mcmVlemVTdGFydFRpbWUgPSB0aGlzLmZyZWV6ZVN0YXJ0VGltZTtcbiAgICBjbG9uZS5mcmVlemVEdXJhdGlvbiA9IHRoaXMuZnJlZXplRHVyYXRpb247XG4gICAgY2xvbmUub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQ7XG4gICAgXG4gICAgLy8gQ2xvbmUgdmVub20gc3RhdHVzXG4gICAgY2xvbmUuaXNWZW5vbW91cyA9IHRoaXMuaXNWZW5vbW91cztcbiAgICBjbG9uZS52ZW5vbVN0YXJ0VGltZSA9IHRoaXMudmVub21TdGFydFRpbWU7XG4gICAgY2xvbmUudmVub21EdXJhdGlvbiA9IHRoaXMudmVub21EdXJhdGlvbjtcbiAgICBjbG9uZS52ZW5vbURhbWFnZVBlclNlY29uZCA9IHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQ7XG4gICAgY2xvbmUubGFzdFZlbm9tRGFtYWdlVGltZSA9IHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZTtcbiAgICBcbiAgICAvLyBDbG9uZSBzdW5kZXIgc3RhY2tzXG4gICAgY2xvbmUuc3VuZGVyU3RhY2tzID0gdGhpcy5zdW5kZXJTdGFja3M7XG4gICAgY2xvbmUuc3VuZGVyTGFzdEFwcGxpZWQgPSB0aGlzLnN1bmRlckxhc3RBcHBsaWVkO1xuICAgIFxuICAgIC8vIENsb25lIGNvcnJ1cHRlZCBzdGF0dXNcbiAgICBjbG9uZS5pc0NvcnJ1cHRlZCA9IHRoaXMuaXNDb3JydXB0ZWQ7XG4gICAgY2xvbmUuY29ycnVwdGVkU3RhcnRUaW1lID0gdGhpcy5jb3JydXB0ZWRTdGFydFRpbWU7XG4gICAgY2xvbmUuY29ycnVwdGVkRHVyYXRpb24gPSB0aGlzLmNvcnJ1cHRlZER1cmF0aW9uO1xuICAgIGNsb25lLmNvcnJ1cHRlZEluaXRpYWxTbG93UGVyY2VudCA9IHRoaXMuY29ycnVwdGVkSW5pdGlhbFNsb3dQZXJjZW50O1xuICAgIGNsb25lLmNvcnJ1cHRlZFJlY292ZXJ5UmF0ZSA9IHRoaXMuY29ycnVwdGVkUmVjb3ZlcnlSYXRlO1xuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBcbiAgcHVibGljIGFwcGx5Q29ycnVwdGVkKGR1cmF0aW9uOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RlYWQpIHJldHVybjsgLy8gQ2FuJ3QgYXBwbHkgY29ycnVwdGVkIHRvIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNDb3JydXB0ZWQgPSB0cnVlO1xuICAgIHRoaXMuY29ycnVwdGVkU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jb3JydXB0ZWREdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5G7IEFwcGxpZWQgQ29ycnVwdGVkIGRlYnVmZiB0byAke3RoaXMuZ2V0RGlzcGxheU5hbWUoKX0gZm9yICR7ZHVyYXRpb259IHNlY29uZHNgKTtcbiAgfVxuICBcbiAgcHVibGljIHJlbW92ZUNvcnJ1cHRlZCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzQ29ycnVwdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb3JydXB0ZWRTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuY29ycnVwdGVkRHVyYXRpb24gPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlQ29ycnVwdGVkU3RhdHVzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNDb3JydXB0ZWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmNvcnJ1cHRlZFN0YXJ0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLmNvcnJ1cHRlZER1cmF0aW9uKSB7XG4gICAgICB0aGlzLnJlbW92ZUNvcnJ1cHRlZCgpO1xuICAgICAgY29uc29sZS5sb2coYPCfkbsgQ29ycnVwdGVkIGRlYnVmZiBleHBpcmVkIG9uICR7dGhpcy5nZXREaXNwbGF5TmFtZSgpfWApO1xuICAgIH1cbiAgfVxuICBcbiAgcHVibGljIGdldENvcnJ1cHRlZFRpbWVSZW1haW5pbmcoY3VycmVudFRpbWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLmlzQ29ycnVwdGVkKSByZXR1cm4gMDtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmNvcnJ1cHRlZFN0YXJ0VGltZTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5jb3JydXB0ZWREdXJhdGlvbiAtIGVsYXBzZWQpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiRW5lbXlUeXBlIiwiRW5lbXkiLCJjYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkIiwiYmFzZUV4cCIsInR5cGUiLCJsZXZlbCIsImNhbGN1bGF0ZUFnZ3JvUmFuZ2UiLCJiYXNlUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tSYW5nZSIsImNhbGN1bGF0ZUF0dGFja0RhbWFnZSIsImJhc2VEYW1hZ2UiLCJjYWxjdWxhdGVBdHRhY2tDb29sZG93biIsImJhc2VDb29sZG93biIsImNhbGN1bGF0ZU1vdmVtZW50U3BlZWQiLCJiYXNlU3BlZWQiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWdncmVzc2l2ZSIsImlzRGVhZCIsImF0dGFja0RhbWFnZSIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwidGFrZURhbWFnZSIsImRpZSIsImRlYXRoVGltZSIsImNhblJlc3Bhd25Ob3ciLCJjYW5SZXNwYXduIiwicmVzcGF3blRpbWUiLCJyZXNwYXduIiwidW5mcmVlemUiLCJyZW1vdmVWZW5vbSIsInJlbW92ZUNvcnJ1cHRlZCIsImZyZWV6ZSIsImR1cmF0aW9uIiwiaXNGcm96ZW4iLCJmcmVlemVTdGFydFRpbWUiLCJmcmVlemVEdXJhdGlvbiIsIm1vdmVtZW50U3BlZWQiLCJvcmlnaW5hbE1vdmVtZW50U3BlZWQiLCJ1cGRhdGVGcmVlemVTdGF0dXMiLCJlbGFwc2VkIiwiY2FuTW92ZSIsImdldEVmZmVjdGl2ZU1vdmVtZW50U3BlZWQiLCJzcGVlZCIsImlzQ29ycnVwdGVkIiwic2xvd011bHRpcGxpZXIiLCJnZXRDb3JydXB0ZWRTbG93TXVsdGlwbGllciIsIkRhdGUiLCJub3ciLCJjb3JydXB0ZWRTdGFydFRpbWUiLCJjdXJyZW50U2xvd1BlcmNlbnQiLCJNYXRoIiwibWF4IiwiY29ycnVwdGVkSW5pdGlhbFNsb3dQZXJjZW50IiwiY29ycnVwdGVkUmVjb3ZlcnlSYXRlIiwiYXBwbHlWZW5vbSIsImRhbWFnZVBlclNlY29uZCIsImlzVmVub21vdXMiLCJ2ZW5vbVN0YXJ0VGltZSIsInZlbm9tRHVyYXRpb24iLCJ2ZW5vbURhbWFnZVBlclNlY29uZCIsImxhc3RWZW5vbURhbWFnZVRpbWUiLCJ1cGRhdGVWZW5vbVN0YXR1cyIsInNob3VsZERlYWxEYW1hZ2UiLCJkYW1hZ2UiLCJ0aW1lU2luY2VMYXN0RGFtYWdlIiwiYXBwbHlTdW5kZXJTdGFjayIsInN1bmRlclN0YWNrcyIsInN1bmRlckxhc3RBcHBsaWVkIiwic3VuZGVyRHVyYXRpb24iLCJnZXRTdW5kZXJTdGFja3MiLCJjbGVhclN1bmRlclN0YWNrcyIsInVwZGF0ZVN1bmRlclN0YXR1cyIsInNldExldmVsIiwibmV3TGV2ZWwiLCJleHBlcmllbmNlUmV3YXJkIiwiZ2V0RGlzcGxheU5hbWUiLCJ0eXBlTmFtZXMiLCJyZXNldCIsImFnZ3JvUmFuZ2UiLCJhdHRhY2tSYW5nZSIsImVuYWJsZWQiLCJjbG9uZSIsImNvcnJ1cHRlZER1cmF0aW9uIiwiYXBwbHlDb3JydXB0ZWQiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlQ29ycnVwdGVkU3RhdHVzIiwiZ2V0Q29ycnVwdGVkVGltZVJlbWFpbmluZyIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSIsImJ1cm5pbmdTdGFja3MiLCJidXJuaW5nTGFzdEFwcGxpZWQiLCJidXJuaW5nRHVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0, bypassInvulnerability = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        if (this.isDead || !bypassInvulnerability && this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        const oldMaxHealth = this.maxHealth;\n        const oldCurrentHealth = this.currentHealth;\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n        console.log(\"\\uD83C\\uDFE5 Health.setMaxHealth: \".concat(oldMaxHealth, \" -> \").concat(this.maxHealth, \" (current: \").concat(oldCurrentHealth, \" -> \").concat(this.currentHealth, \", ratio: \").concat(healthRatio.toFixed(3), \")\"));\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQTBHO1lBQXhHQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQyx1REFBY0Msd0JBQUFBLGlFQUFpQztRQUN4SCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFLLENBQUNELHlCQUF5QixJQUFJLENBQUNFLGNBQWMsSUFBS1AsVUFBVSxHQUFHO1lBQ2pGLE9BQU87UUFDVDtRQUVBLElBQUlRLGNBQWNSO1FBRWxCLDRFQUE0RTtRQUM1RSxJQUFJSSxRQUFRO1lBQ1YsTUFBTUssU0FBU0wsT0FBT00sWUFBWSxDQUFDYiwyQ0FBTUE7WUFDekMsSUFBSVksUUFBUTtnQkFDVkQsY0FBY0MsT0FBT0UsWUFBWSxDQUFDWDtZQUNwQztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlRLGNBQWMsR0FBRztZQUNuQixJQUFJLENBQUNJLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixhQUFhLEdBQUdKO1lBQ3RELElBQUksQ0FBQ08sY0FBYyxHQUFHZDtZQUV0QiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDTSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRyxJQUFJLENBQUNDLHVCQUF1QjtZQUV4RCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNMLGFBQWEsSUFBSSxHQUFHO2dCQUMzQixJQUFJLENBQUNOLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRU9ZLEtBQUtsQixNQUFjLEVBQVc7UUFDbkMsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSU4sVUFBVSxHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUVBLE1BQU1tQixZQUFZLElBQUksQ0FBQ1As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O1FBQzFDLE9BQU93QztJQUNUO0lBaEtBQyxZQUFZbkMsWUFBb0IsR0FBRyxDQUFFO1FBQ25DLEtBQUs7YUFiU29DLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFlOUQsSUFBSSxDQUFDcEMsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNULGFBQWEsR0FBR1MsV0FBVyxnQ0FBZ0M7UUFDaEUsSUFBSSxDQUFDZCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDVSx1QkFBdUIsR0FBRyxLQUFLLDhDQUE4QztRQUNsRixJQUFJLENBQUNELG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDb0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0MsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxHQUFHLGtEQUFrRDtRQUM5RSxJQUFJLENBQUM3QixjQUFjLEdBQUc7SUFDeEI7QUFvSkY7QUEvS2FqQixPQUNZMkQsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHM/NWY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggY29tcG9uZW50IGZvciBkYW1hZ2UgYW5kIGhlYWxpbmdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICcuL1NoaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGggZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0hlYWx0aCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIGN1cnJlbnRIZWFsdGg6IG51bWJlcjtcbiAgcHVibGljIG1heEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW47XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaW52dWxuZXJhYmlsaXR5VGltZXI6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGNhblJlZ2VuZXJhdGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZWdlbmVyYXRpb25SYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWdlbmVyYXRpb25EZWxheTogbnVtYmVyO1xuICBwdWJsaWMgbGFzdERhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhIZWFsdGg6IG51bWJlciA9IDEwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tYXhIZWFsdGggPSBtYXhIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gbWF4SGVhbHRoOyAvLyBBbHdheXMgc3RhcnQgd2l0aCBmdWxsIGhlYWx0aFxuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gMC41OyAvLyAwLjUgc2Vjb25kcyBvZiBpbnZ1bG5lcmFiaWxpdHkgYWZ0ZXIgZGFtYWdlXG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1OyAvLyBIZWFsdGggcGVyIHNlY29uZFxuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzOyAvLyBTZWNvbmRzIGFmdGVyIGRhbWFnZSBiZWZvcmUgcmVnZW5lcmF0aW9uIHN0YXJ0c1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHRha2VEYW1hZ2UoYW1vdW50OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpIC8gMTAwMCwgZW50aXR5PzogYW55LCBieXBhc3NJbnZ1bG5lcmFiaWxpdHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzRGVhZCB8fCAoIWJ5cGFzc0ludnVsbmVyYWJpbGl0eSAmJiB0aGlzLmlzSW52dWxuZXJhYmxlKSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICBjb25zdCBvbGRNYXhIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICBjb25zdCBvbGRDdXJyZW50SGVhbHRoID0gdGhpcy5jdXJyZW50SGVhbHRoO1xuICAgIHRoaXMubWF4SGVhbHRoID0gTWF0aC5tYXgoMSwgbmV3TWF4SGVhbHRoKTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSBNYXRoLmZsb29yKHRoaXMubWF4SGVhbHRoICogaGVhbHRoUmF0aW8pO1xuICAgIGNvbnNvbGUubG9nKGDwn4+lIEhlYWx0aC5zZXRNYXhIZWFsdGg6ICR7b2xkTWF4SGVhbHRofSAtPiAke3RoaXMubWF4SGVhbHRofSAoY3VycmVudDogJHtvbGRDdXJyZW50SGVhbHRofSAtPiAke3RoaXMuY3VycmVudEhlYWx0aH0sIHJhdGlvOiAke2hlYWx0aFJhdGlvLnRvRml4ZWQoMyl9KWApO1xuICB9XG5cbiAgcHVibGljIGdldEhlYWx0aFJhdGlvKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubWF4SGVhbHRoID4gMCA/IHRoaXMuY3VycmVudEhlYWx0aCAvIHRoaXMubWF4SGVhbHRoIDogMDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhQZXJjZW50YWdlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSAqIDEwMDtcbiAgfVxuXG4gIHB1YmxpYyBpc0Z1bGxIZWFsdGgoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+PSB0aGlzLm1heEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBpc0xvd0hlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMjUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRIZWFsdGhSYXRpbygpIDw9IHRocmVzaG9sZDtcbiAgfVxuXG4gIHB1YmxpYyBpc0NyaXRpY2FsSGVhbHRoKHRocmVzaG9sZDogbnVtYmVyID0gMC4xKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgcmV2aXZlKGhlYWx0aEFtb3VudD86IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gaGVhbHRoQW1vdW50ICE9PSB1bmRlZmluZWQgPyBcbiAgICAgIE1hdGgubWluKHRoaXMubWF4SGVhbHRoLCBoZWFsdGhBbW91bnQpIDogXG4gICAgICB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyID0gRGF0ZS5ub3coKSAvIDEwMDApOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaW52dWxuZXJhYmlsaXR5IHRpbWVyXG4gICAgaWYgKHRoaXMuaXNJbnZ1bG5lcmFibGUpIHtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgLT0gZGVsdGFUaW1lO1xuICAgICAgaWYgKHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPD0gMCkge1xuICAgICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSByZWdlbmVyYXRpb25cbiAgICBpZiAodGhpcy5jYW5SZWdlbmVyYXRlICYmICF0aGlzLmlzRGVhZCAmJiAhdGhpcy5pc0Z1bGxIZWFsdGgoKSkge1xuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdERhbWFnZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGFtYWdlVGltZTtcbiAgICAgIGlmICh0aW1lU2luY2VMYXN0RGFtYWdlID49IHRoaXMucmVnZW5lcmF0aW9uRGVsYXkpIHtcbiAgICAgICAgdGhpcy5oZWFsKHRoaXMucmVnZW5lcmF0aW9uUmF0ZSAqIGRlbHRhVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEludnVsbmVyYWJsZShkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IGR1cmF0aW9uO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUludnVsbmVyYWJpbGl0eSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gIH1cblxuICBwdWJsaWMgZW5hYmxlUmVnZW5lcmF0aW9uKHJhdGU6IG51bWJlciA9IDUsIGRlbGF5OiBudW1iZXIgPSAzKTogdm9pZCB7XG4gICAgdGhpcy5jYW5SZWdlbmVyYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSByYXRlO1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSBkZWxheTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNhYmxlUmVnZW5lcmF0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IHRoaXMubWF4SGVhbHRoO1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVnZW5lcmF0aW9uUmF0ZSA9IDU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25EZWxheSA9IDM7XG4gICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBIZWFsdGgge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEhlYWx0aCh0aGlzLm1heEhlYWx0aCk7XG4gICAgY2xvbmUuY3VycmVudEhlYWx0aCA9IHRoaXMuY3VycmVudEhlYWx0aDtcbiAgICBjbG9uZS5pc0ludnVsbmVyYWJsZSA9IHRoaXMuaXNJbnZ1bG5lcmFibGU7XG4gICAgY2xvbmUuaW52dWxuZXJhYmlsaXR5RHVyYXRpb24gPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eVRpbWVyID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lcjtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5jYW5SZWdlbmVyYXRlID0gdGhpcy5jYW5SZWdlbmVyYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvblJhdGUgPSB0aGlzLnJlZ2VuZXJhdGlvblJhdGU7XG4gICAgY2xvbmUucmVnZW5lcmF0aW9uRGVsYXkgPSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5O1xuICAgIGNsb25lLmxhc3REYW1hZ2VUaW1lID0gdGhpcy5sYXN0RGFtYWdlVGltZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJTaGllbGQiLCJIZWFsdGgiLCJ0YWtlRGFtYWdlIiwiYW1vdW50IiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwiZW50aXR5IiwiYnlwYXNzSW52dWxuZXJhYmlsaXR5IiwiaXNEZWFkIiwiaXNJbnZ1bG5lcmFibGUiLCJmaW5hbERhbWFnZSIsInNoaWVsZCIsImdldENvbXBvbmVudCIsImFic29yYkRhbWFnZSIsImN1cnJlbnRIZWFsdGgiLCJNYXRoIiwibWF4IiwibGFzdERhbWFnZVRpbWUiLCJpbnZ1bG5lcmFiaWxpdHlUaW1lciIsImludnVsbmVyYWJpbGl0eUR1cmF0aW9uIiwiaGVhbCIsIm9sZEhlYWx0aCIsIm1pbiIsIm1heEhlYWx0aCIsInNldE1heEhlYWx0aCIsIm5ld01heEhlYWx0aCIsImhlYWx0aFJhdGlvIiwiZ2V0SGVhbHRoUmF0aW8iLCJvbGRNYXhIZWFsdGgiLCJvbGRDdXJyZW50SGVhbHRoIiwiZmxvb3IiLCJjb25zb2xlIiwibG9nIiwidG9GaXhlZCIsImdldEhlYWx0aFBlcmNlbnRhZ2UiLCJpc0Z1bGxIZWFsdGgiLCJpc0xvd0hlYWx0aCIsInRocmVzaG9sZCIsImlzQ3JpdGljYWxIZWFsdGgiLCJyZXZpdmUiLCJoZWFsdGhBbW91bnQiLCJ1bmRlZmluZWQiLCJ1cGRhdGUiLCJkZWx0YVRpbWUiLCJjYW5SZWdlbmVyYXRlIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuZXJhdGlvbkRlbGF5IiwicmVnZW5lcmF0aW9uUmF0ZSIsInNldEludnVsbmVyYWJsZSIsImR1cmF0aW9uIiwicmVtb3ZlSW52dWxuZXJhYmlsaXR5IiwiZW5hYmxlUmVnZW5lcmF0aW9uIiwicmF0ZSIsImRlbGF5IiwiZGlzYWJsZVJlZ2VuZXJhdGlvbiIsInJlc2V0IiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Interpolation.ts":
/*!*********************************************!*\
  !*** ./src/ecs/components/Interpolation.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationBuffer: function() { return /* binding */ InterpolationBuffer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/**\n * Entity Interpolation System for Smooth Multiplayer Movement\n *\n * This system implements client-side prediction and entity interpolation to provide\n * smooth movement in multiplayer games, eliminating jerky position updates from server snapshots.\n *\n * Features:\n * - Linear interpolation (LERP) between server states\n * - Extrapolation for missing server updates\n * - Configurable interpolation delay and buffer size\n * - Automatic fallback to direct updates if interpolation fails\n *\n * Usage:\n * 1. Add InterpolationBuffer component to entities that need smooth movement\n * 2. Add InterpolationSystem to your ECS World\n * 3. Call addServerState() whenever you receive server position updates\n * 4. The InterpolationSystem will automatically handle smooth position/rotation updates\n *\n * Debug: Use window.getInterpolationStats() in browser console to monitor performance\n */ \n\nclass InterpolationBuffer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    /**\n   * Add a new server state to the interpolation buffer\n   */ addServerState(position, rotation, timestamp) {\n        const serverTimestamp = timestamp || Date.now();\n        const newState = {\n            timestamp: serverTimestamp,\n            position: position.clone(),\n            rotation: rotation.clone()\n        };\n        // Calculate velocity if we have a previous state\n        if (this.buffer.length > 0) {\n            const lastState = this.buffer[this.buffer.length - 1];\n            const timeDiff = (serverTimestamp - lastState.timestamp) / 1000; // Convert to seconds\n            if (timeDiff > 0) {\n                newState.velocity = position.clone().sub(lastState.position).divideScalar(timeDiff);\n                // Calculate angular velocity (simplified - could be improved)\n                const angleDiff = rotation.angleTo(lastState.rotation);\n                newState.angularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, angleDiff / timeDiff, 0);\n            }\n        }\n        // Add to buffer\n        this.buffer.push(newState);\n        // Remove old states to maintain buffer size\n        while(this.buffer.length > this.maxBufferSize){\n            this.buffer.shift();\n        }\n        // Update interpolation state\n        this.updateInterpolationState(serverTimestamp);\n    }\n    /**\n   * Update the current interpolation state\n   */ updateInterpolationState(currentTime) {\n        if (this.buffer.length < 2) {\n            // Not enough states for interpolation\n            if (this.buffer.length === 1) {\n                this.currentState = {\n                    ...this.buffer[0]\n                };\n            }\n            return;\n        }\n        // Find the two states to interpolate between\n        const renderTime = currentTime - this.interpolationDelay;\n        let beforeState = null;\n        let afterState = null;\n        for(let i = 0; i < this.buffer.length - 1; i++){\n            if (this.buffer[i].timestamp <= renderTime && this.buffer[i + 1].timestamp >= renderTime) {\n                beforeState = this.buffer[i];\n                afterState = this.buffer[i + 1];\n                break;\n            }\n        }\n        if (beforeState && afterState) {\n            // We have states to interpolate between\n            this.currentState = beforeState;\n            this.targetState = afterState;\n            this.interpolationStartTime = currentTime;\n            this.interpolationDuration = afterState.timestamp - beforeState.timestamp;\n            this.extrapolationStartTime = 0; // Reset extrapolation\n        } else if (this.buffer.length > 0) {\n            // No states to interpolate - use extrapolation\n            const latestState = this.buffer[this.buffer.length - 1];\n            if (latestState.velocity) {\n                this.lastVelocity.copy(latestState.velocity);\n                this.extrapolationStartTime = currentTime;\n            }\n        }\n    }\n    /**\n   * Get the interpolated position at the current render time\n   */ getInterpolatedPosition(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state or extrapolation\n            if (this.buffer.length > 0) {\n                const latestState = this.buffer[this.buffer.length - 1];\n                if (this.extrapolationStartTime > 0 && latestState.velocity) {\n                    const extrapolationTime = (currentTime - this.extrapolationStartTime) / 1000;\n                    const maxTime = this.maxExtrapolationTime / 1000;\n                    if (extrapolationTime < maxTime) {\n                        // Extrapolate position\n                        return latestState.position.clone().add(latestState.velocity.clone().multiplyScalar(extrapolationTime));\n                    }\n                }\n                return latestState.position.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        // Clamp t between 0 and 1\n        t = Math.max(0, Math.min(1, t));\n        // Linear interpolation between current and target states\n        const interpolatedPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        interpolatedPosition.lerpVectors(this.currentState.position, this.targetState.position, t);\n        return interpolatedPosition;\n    }\n    /**\n   * Get the interpolated rotation at the current render time\n   */ getInterpolatedRotation(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state\n            if (this.buffer.length > 0) {\n                return this.buffer[this.buffer.length - 1].rotation.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        t = Math.max(0, Math.min(1, t));\n        // Spherical linear interpolation for rotations\n        const interpolatedRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        interpolatedRotation.copy(this.currentState.rotation);\n        interpolatedRotation.slerp(this.targetState.rotation, t);\n        return interpolatedRotation;\n    }\n    /**\n   * Get the interpolated transform (position and rotation) at the current render time\n   */ getInterpolatedTransform(currentTime) {\n        return {\n            position: this.getInterpolatedPosition(currentTime),\n            rotation: this.getInterpolatedRotation(currentTime)\n        };\n    }\n    /**\n   * Check if we're currently extrapolating (no recent server updates)\n   */ isExtrapolating(currentTime) {\n        return this.extrapolationStartTime > 0 && currentTime - this.extrapolationStartTime < this.maxExtrapolationTime;\n    }\n    /**\n   * Get buffer statistics for debugging\n   */ getBufferStats() {\n        return {\n            bufferSize: this.buffer.length,\n            maxBufferSize: this.maxBufferSize,\n            interpolationDelay: this.interpolationDelay,\n            isInterpolating: this.currentState !== null && this.targetState !== null,\n            isExtrapolating: this.extrapolationStartTime > 0,\n            latestTimestamp: this.buffer.length > 0 ? this.buffer[this.buffer.length - 1].timestamp : null\n        };\n    }\n    /**\n   * Clear the interpolation buffer\n   */ clearBuffer() {\n        this.buffer.length = 0;\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.extrapolationStartTime = 0;\n    }\n    reset() {\n        this.clearBuffer();\n        this.lastVelocity.set(0, 0, 0);\n        this.lastAngularVelocity.set(0, 0, 0);\n        this.enabled = true;\n    }\n    constructor(){\n        super();\n        this.componentType = \"InterpolationBuffer\";\n        // Buffer to store recent server states\n        this.buffer = [];\n        this.maxBufferSize = 10 // Keep last 10 states for interpolation\n        ;\n        this.interpolationDelay = 100 // ms delay for interpolation (100ms = ~6-7 frames at 60fps)\n        ;\n        // Current interpolation state\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.interpolationDuration = 0;\n        // Extrapolation settings\n        this.lastVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.lastAngularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.extrapolationStartTime = 0;\n        this.maxExtrapolationTime = 500 // Max time to extrapolate before snapping (500ms)\n        ;\n    }\n}\nInterpolationBuffer.componentType = \"InterpolationBuffer\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQzJEO0FBQ3RCO0FBVS9CLE1BQU1HLDRCQUE0QkQsOENBQVNBO0lBeUJoRDs7R0FFQyxHQUNELGVBQXNCRyxRQUFpQixFQUFFQyxRQUFvQixFQUFFQyxTQUFrQixFQUFRO1FBQ3ZGLE1BQU1DLGtCQUFrQkQsYUFBYUUsS0FBS0MsR0FBRztRQUU3QyxNQUFNQyxXQUF3QjtZQUM1QkosV0FBV0M7WUFDWEgsVUFBVUEsU0FBU08sS0FBSztZQUN4Qk4sVUFBVUEsU0FBU00sS0FBSztRQUMxQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLEdBQUcsR0FBRztZQUMxQixNQUFNQyxZQUFZLElBQUksQ0FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtZQUNyRCxNQUFNRSxXQUFXLENBQUNSLGtCQUFrQk8sVUFBVVIsU0FBUyxJQUFJLE1BQU0scUJBQXFCO1lBRXRGLElBQUlTLFdBQVcsR0FBRztnQkFDaEJMLFNBQVNNLFFBQVEsR0FBR1osU0FBU08sS0FBSyxHQUFHTSxHQUFHLENBQUNILFVBQVVWLFFBQVEsRUFBRWMsWUFBWSxDQUFDSDtnQkFFMUUsOERBQThEO2dCQUM5RCxNQUFNSSxZQUFZZCxTQUFTZSxPQUFPLENBQUNOLFVBQVVULFFBQVE7Z0JBQ3JESyxTQUFTVyxlQUFlLEdBQUcsSUFBSXRCLHlEQUFPQSxDQUFDLEdBQUdvQixZQUFZSixVQUFVO1lBQ2xFO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDSCxNQUFNLENBQUNVLElBQUksQ0FBQ1o7UUFFakIsNENBQTRDO1FBQzVDLE1BQU8sSUFBSSxDQUFDRSxNQUFNLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNVLGFBQWEs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SUFDaEM7SUFFTzJCLFFBQWM7UUFDbkIsSUFBSSxDQUFDRCxXQUFXO1FBQ2hCLElBQUksQ0FBQ3hCLFlBQVksQ0FBQzBCLEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0QsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUNuQyxJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNqQjtJQXJNQUMsYUFBYztRQUNaLEtBQUs7YUFwQlNDLGdCQUFnQjtRQUVoQyx1Q0FBdUM7YUFDL0J4RCxTQUF3QixFQUFFO2FBQ2pCVyxnQkFBZ0IsR0FBSSx3Q0FBd0M7O2FBQzVETSxxQkFBcUIsSUFBSyw0REFBNEQ7O1FBRXZHLDhCQUE4QjthQUN0QkYsZUFBbUM7YUFDbkNNLGNBQWtDO2FBQ2xDQyx5QkFBeUI7YUFDekJDLHdCQUF3QjtRQUVoQyx5QkFBeUI7YUFDakJHLGVBQXdCLElBQUl2Qyx5REFBT0E7YUFDbkNrRSxzQkFBK0IsSUFBSWxFLHlEQUFPQTthQUMxQ3FDLHlCQUF5QjthQUN6Qk8sdUJBQXVCLElBQUssa0RBQWtEOztJQUl0RjtBQW9NRjtBQTNOYXpDLG9CQUNZa0UsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzP2FkZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbnRpdHkgSW50ZXJwb2xhdGlvbiBTeXN0ZW0gZm9yIFNtb290aCBNdWx0aXBsYXllciBNb3ZlbWVudFxuICpcbiAqIFRoaXMgc3lzdGVtIGltcGxlbWVudHMgY2xpZW50LXNpZGUgcHJlZGljdGlvbiBhbmQgZW50aXR5IGludGVycG9sYXRpb24gdG8gcHJvdmlkZVxuICogc21vb3RoIG1vdmVtZW50IGluIG11bHRpcGxheWVyIGdhbWVzLCBlbGltaW5hdGluZyBqZXJreSBwb3NpdGlvbiB1cGRhdGVzIGZyb20gc2VydmVyIHNuYXBzaG90cy5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gTGluZWFyIGludGVycG9sYXRpb24gKExFUlApIGJldHdlZW4gc2VydmVyIHN0YXRlc1xuICogLSBFeHRyYXBvbGF0aW9uIGZvciBtaXNzaW5nIHNlcnZlciB1cGRhdGVzXG4gKiAtIENvbmZpZ3VyYWJsZSBpbnRlcnBvbGF0aW9uIGRlbGF5IGFuZCBidWZmZXIgc2l6ZVxuICogLSBBdXRvbWF0aWMgZmFsbGJhY2sgdG8gZGlyZWN0IHVwZGF0ZXMgaWYgaW50ZXJwb2xhdGlvbiBmYWlsc1xuICpcbiAqIFVzYWdlOlxuICogMS4gQWRkIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50IHRvIGVudGl0aWVzIHRoYXQgbmVlZCBzbW9vdGggbW92ZW1lbnRcbiAqIDIuIEFkZCBJbnRlcnBvbGF0aW9uU3lzdGVtIHRvIHlvdXIgRUNTIFdvcmxkXG4gKiAzLiBDYWxsIGFkZFNlcnZlclN0YXRlKCkgd2hlbmV2ZXIgeW91IHJlY2VpdmUgc2VydmVyIHBvc2l0aW9uIHVwZGF0ZXNcbiAqIDQuIFRoZSBJbnRlcnBvbGF0aW9uU3lzdGVtIHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgc21vb3RoIHBvc2l0aW9uL3JvdGF0aW9uIHVwZGF0ZXNcbiAqXG4gKiBEZWJ1ZzogVXNlIHdpbmRvdy5nZXRJbnRlcnBvbGF0aW9uU3RhdHMoKSBpbiBicm93c2VyIGNvbnNvbGUgdG8gbW9uaXRvciBwZXJmb3JtYW5jZVxuICovXG5pbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyU3RhdGUge1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgcG9zaXRpb246IFZlY3RvcjM7XG4gIHJvdGF0aW9uOiBRdWF0ZXJuaW9uO1xuICB2ZWxvY2l0eT86IFZlY3RvcjM7XG4gIGFuZ3VsYXJWZWxvY2l0eT86IFZlY3RvcjM7XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uQnVmZmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0ludGVycG9sYXRpb25CdWZmZXInO1xuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdJbnRlcnBvbGF0aW9uQnVmZmVyJztcblxuICAvLyBCdWZmZXIgdG8gc3RvcmUgcmVjZW50IHNlcnZlciBzdGF0ZXNcbiAgcHJpdmF0ZSBidWZmZXI6IFNlcnZlclN0YXRlW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhCdWZmZXJTaXplID0gMTA7IC8vIEtlZXAgbGFzdCAxMCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcnBvbGF0aW9uRGVsYXkgPSAxMDA7IC8vIG1zIGRlbGF5IGZvciBpbnRlcnBvbGF0aW9uICgxMDBtcyA9IH42LTcgZnJhbWVzIGF0IDYwZnBzKVxuXG4gIC8vIEN1cnJlbnQgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICBwcml2YXRlIGN1cnJlbnRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0YXJnZXRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uRHVyYXRpb24gPSAwO1xuXG4gIC8vIEV4dHJhcG9sYXRpb24gc2V0dGluZ3NcbiAgcHJpdmF0ZSBsYXN0VmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGxhc3RBbmd1bGFyVmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIG1heEV4dHJhcG9sYXRpb25UaW1lID0gNTAwOyAvLyBNYXggdGltZSB0byBleHRyYXBvbGF0ZSBiZWZvcmUgc25hcHBpbmcgKDUwMG1zKVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHNlcnZlciBzdGF0ZSB0byB0aGUgaW50ZXJwb2xhdGlvbiBidWZmZXJcbiAgICovXG4gIHB1YmxpYyBhZGRTZXJ2ZXJTdGF0ZShwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNlcnZlclRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgY29uc3QgbmV3U3RhdGU6IFNlcnZlclN0YXRlID0ge1xuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24uY2xvbmUoKSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbi5jbG9uZSgpXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB2ZWxvY2l0eSBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgc3RhdGVcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChzZXJ2ZXJUaW1lc3RhbXAgLSBsYXN0U3RhdGUudGltZXN0YW1wKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgICBpZiAodGltZURpZmYgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlLnZlbG9jaXR5ID0gcG9zaXRpb24uY2xvbmUoKS5zdWIobGFzdFN0YXRlLnBvc2l0aW9uKS5kaXZpZGVTY2FsYXIodGltZURpZmYpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbmd1bGFyIHZlbG9jaXR5IChzaW1wbGlmaWVkIC0gY291bGQgYmUgaW1wcm92ZWQpXG4gICAgICAgIGNvbnN0IGFuZ2xlRGlmZiA9IHJvdGF0aW9uLmFuZ2xlVG8obGFzdFN0YXRlLnJvdGF0aW9uKTtcbiAgICAgICAgbmV3U3RhdGUuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgYW5nbGVEaWZmIC8gdGltZURpZmYsIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBidWZmZXJcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKG5ld1N0YXRlKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgc3RhdGVzIHRvIG1haW50YWluIGJ1ZmZlciBzaXplXG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgdGhpcy5idWZmZXIuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICAgIHRoaXMudXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKHNlcnZlclRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IGludGVycG9sYXRpb24gc3RhdGVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgMikge1xuICAgICAgLy8gTm90IGVub3VnaCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB7IC4uLnRoaXMuYnVmZmVyWzBdIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgdHdvIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG4gICAgY29uc3QgcmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5pbnRlcnBvbGF0aW9uRGVsYXk7XG4gICAgbGV0IGJlZm9yZVN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBhZnRlclN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcltpXS50aW1lc3RhbXAgPD0gcmVuZGVyVGltZSAmJiB0aGlzLmJ1ZmZlcltpICsgMV0udGltZXN0YW1wID49IHJlbmRlclRpbWUpIHtcbiAgICAgICAgYmVmb3JlU3RhdGUgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgYWZ0ZXJTdGF0ZSA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZVN0YXRlICYmIGFmdGVyU3RhdGUpIHtcbiAgICAgIC8vIFdlIGhhdmUgc3RhdGVzIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gYmVmb3JlU3RhdGU7XG4gICAgICB0aGlzLnRhcmdldFN0YXRlID0gYWZ0ZXJTdGF0ZTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRHVyYXRpb24gPSBhZnRlclN0YXRlLnRpbWVzdGFtcCAtIGJlZm9yZVN0YXRlLnRpbWVzdGFtcDtcbiAgICAgIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA9IDA7IC8vIFJlc2V0IGV4dHJhcG9sYXRpb25cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE5vIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSAtIHVzZSBleHRyYXBvbGF0aW9uXG4gICAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhdGVzdFN0YXRlLnZlbG9jaXR5KSB7XG4gICAgICAgIHRoaXMubGFzdFZlbG9jaXR5LmNvcHkobGF0ZXN0U3RhdGUudmVsb2NpdHkpO1xuICAgICAgICB0aGlzLmV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlIG9yIGV4dHJhcG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiYgbGF0ZXN0U3RhdGUudmVsb2NpdHkpIHtcbiAgICAgICAgICBjb25zdCBleHRyYXBvbGF0aW9uVGltZSA9IChjdXJyZW50VGltZSAtIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICAgIGNvbnN0IG1heFRpbWUgPSB0aGlzLm1heEV4dHJhcG9sYXRpb25UaW1lIC8gMTAwMDtcblxuICAgICAgICAgIGlmIChleHRyYXBvbGF0aW9uVGltZSA8IG1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhcG9sYXRlIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0U3RhdGUucG9zaXRpb24uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgIGxhdGVzdFN0YXRlLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZXh0cmFwb2xhdGlvblRpbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXRlc3RTdGF0ZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcblxuICAgIC8vIENsYW1wIHQgYmV0d2VlbiAwIGFuZCAxXG4gICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcblxuICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gY3VycmVudCBhbmQgdGFyZ2V0IHN0YXRlc1xuICAgIGNvbnN0IGludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBpbnRlcnBvbGF0ZWRQb3NpdGlvbi5sZXJwVmVjdG9ycyh0aGlzLmN1cnJlbnRTdGF0ZS5wb3NpdGlvbiwgdGhpcy50YXJnZXRTdGF0ZS5wb3NpdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcm90YXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRSb3RhdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogUXVhdGVybmlvbiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV0ucm90YXRpb24uY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuXG4gICAgLy8gU3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciByb3RhdGlvbnNcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uY29weSh0aGlzLmN1cnJlbnRTdGF0ZS5yb3RhdGlvbik7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uc2xlcnAodGhpcy50YXJnZXRTdGF0ZS5yb3RhdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtIChwb3NpdGlvbiBhbmQgcm90YXRpb24pIGF0IHRoZSBjdXJyZW50IHJlbmRlciB0aW1lXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB7IHBvc2l0aW9uOiBWZWN0b3IzOyByb3RhdGlvbjogUXVhdGVybmlvbiB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUG9zaXRpb24oY3VycmVudFRpbWUpLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24oY3VycmVudFRpbWUpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSdyZSBjdXJyZW50bHkgZXh0cmFwb2xhdGluZyAobm8gcmVjZW50IHNlcnZlciB1cGRhdGVzKVxuICAgKi9cbiAgcHVibGljIGlzRXh0cmFwb2xhdGluZyhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiZcbiAgICAgICAgICAgKGN1cnJlbnRUaW1lIC0gdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lKSA8IHRoaXMubWF4RXh0cmFwb2xhdGlvblRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIHB1YmxpYyBnZXRCdWZmZXJTdGF0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyU2l6ZTogdGhpcy5idWZmZXIubGVuZ3RoLFxuICAgICAgbWF4QnVmZmVyU2l6ZTogdGhpcy5tYXhCdWZmZXJTaXplLFxuICAgICAgaW50ZXJwb2xhdGlvbkRlbGF5OiB0aGlzLmludGVycG9sYXRpb25EZWxheSxcbiAgICAgIGlzSW50ZXJwb2xhdGluZzogdGhpcy5jdXJyZW50U3RhdGUgIT09IG51bGwgJiYgdGhpcy50YXJnZXRTdGF0ZSAhPT0gbnVsbCxcbiAgICAgIGlzRXh0cmFwb2xhdGluZzogdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID4gMCxcbiAgICAgIGxhdGVzdFRpbWVzdGFtcDogdGhpcy5idWZmZXIubGVuZ3RoID4gMCA/IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGNsZWFyQnVmZmVyKCk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50U3RhdGUgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U3RhdGUgPSBudWxsO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyQnVmZmVyKCk7XG4gICAgdGhpcy5sYXN0VmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGFzdEFuZ3VsYXJWZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiQ29tcG9uZW50IiwiSW50ZXJwb2xhdGlvbkJ1ZmZlciIsImFkZFNlcnZlclN0YXRlIiwicG9zaXRpb24iLCJyb3RhdGlvbiIsInRpbWVzdGFtcCIsInNlcnZlclRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJuZXdTdGF0ZSIsImNsb25lIiwiYnVmZmVyIiwibGVuZ3RoIiwibGFzdFN0YXRlIiwidGltZURpZmYiLCJ2ZWxvY2l0eSIsInN1YiIsImRpdmlkZVNjYWxhciIsImFuZ2xlRGlmZiIsImFuZ2xlVG8iLCJhbmd1bGFyVmVsb2NpdHkiLCJwdXNoIiwibWF4QnVmZmVyU2l6ZSIsInNoaWZ0IiwidXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlIiwiY3VycmVudFRpbWUiLCJjdXJyZW50U3RhdGUiLCJyZW5kZXJUaW1lIiwiaW50ZXJwb2xhdGlvbkRlbGF5IiwiYmVmb3JlU3RhdGUiLCJhZnRlclN0YXRlIiwiaSIsInRhcmdldFN0YXRlIiwiaW50ZXJwb2xhdGlvblN0YXJ0VGltZSIsImludGVycG9sYXRpb25EdXJhdGlvbiIsImV4dHJhcG9sYXRpb25TdGFydFRpbWUiLCJsYXRlc3RTdGF0ZSIsImxhc3RWZWxvY2l0eSIsImNvcHkiLCJnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImV4dHJhcG9sYXRpb25UaW1lIiwibWF4VGltZSIsIm1heEV4dHJhcG9sYXRpb25UaW1lIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJlbGFwc2VkIiwidCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJpbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImxlcnBWZWN0b3JzIiwiZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24iLCJpbnRlcnBvbGF0ZWRSb3RhdGlvbiIsInNsZXJwIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiaXNFeHRyYXBvbGF0aW5nIiwiZ2V0QnVmZmVyU3RhdHMiLCJidWZmZXJTaXplIiwiaXNJbnRlcnBvbGF0aW5nIiwibGF0ZXN0VGltZXN0YW1wIiwiY2xlYXJCdWZmZXIiLCJyZXNldCIsInNldCIsImxhc3RBbmd1bGFyVmVsb2NpdHkiLCJlbmFibGVkIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Interpolation.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n    // console.log(` Player frozen for ${duration}ms until ${this.frozenUntil} (current: ${currentTime})`);\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n    // console.log(` Player slowed to ${speedMultiplier * 100}% speed for ${duration}ms until ${this.slowedUntil}`);\n    }\n    applyCorrupted(duration) {\n        this.isCorrupted = true;\n        this.corruptedStartTime = Date.now() / 1000; // Store in seconds for easier calculations\n        this.corruptedDuration = duration / 1000; // Convert to seconds\n        this.corruptedInitialSlowPercent = 0.9; // 90% initial slow\n        this.corruptedRecoveryRate = 0.1; // 10% recovery per second\n        console.log(\"\\uD83D\\uDC7B Applied corrupted debuff for \".concat(duration, \"ms (\").concat(this.corruptedDuration, \"s)\"));\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n        }\n        // Check corrupted state\n        const currentTimeSeconds = currentTime / 1000;\n        if (this.isCorrupted) {\n            const elapsed = currentTimeSeconds - this.corruptedStartTime;\n            if (elapsed >= this.corruptedDuration) {\n                // Corrupted debuff has expired\n                this.isCorrupted = false;\n                this.corruptedStartTime = 0;\n                this.corruptedDuration = 0;\n                console.log(\"\\uD83D\\uDC7B Corrupted debuff expired\");\n            }\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        let speed = this.maxSpeed * this.movementSpeedMultiplier;\n        // Apply corrupted debuff slow effect with gradual recovery\n        if (this.isCorrupted) {\n            const currentTimeSeconds = Date.now() / 1000;\n            const elapsed = currentTimeSeconds - this.corruptedStartTime;\n            // Calculate current slow percentage based on gradual recovery\n            // Initial: 90% slow, recovers 10% per second\n            const currentSlowPercent = Math.max(0, this.corruptedInitialSlowPercent - elapsed * this.corruptedRecoveryRate);\n            // Apply the slow effect (reduce speed by the slow percentage)\n            speed *= 1 - currentSlowPercent;\n            // Debug logging for corrupted debuff (only log occasionally to avoid spam)\n            if (elapsed % 1.0 < 0.1) {\n                console.log(\"\\uD83D\\uDC7B Corrupted debuff: \".concat((currentSlowPercent * 100).toFixed(1), \"% slow (\").concat(((1 - currentSlowPercent) * 100).toFixed(1), \"% speed remaining)\"));\n            }\n        }\n        return speed;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.75, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Initialize corrupted debuff states\n        this.isCorrupted = false;\n        this.corruptedStartTime = 0;\n        this.corruptedDuration = 0;\n        this.corruptedInitialSlowPercent = 0.9; // 90% initial slow\n        this.corruptedRecoveryRate = 0.1; // 10% recovery per second\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBc0g5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtJQUNqQyx5R0FBeUc7SUFDM0c7SUFFT00sS0FBS04sUUFBZ0IsRUFBdUM7WUFBckNPLGtCQUFBQSxpRUFBMEI7UUFDdEQsTUFBTU4sY0FBY0MsS0FBS0MsR0FBRztRQUM1QixJQUFJLENBQUNLLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR1IsY0FBY0Q7UUFD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QUksQ0FBQ0MsZUFBZSxHQUFHLElBQUluRyx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDekMsSUFBSSxDQUFDb0csZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0csY0FBYyxHQUFHLE1BQU0sd0JBQXdCO1FBQ3BELElBQUksQ0FBQ0MsY0FBYyxHQUFHLEdBQUcsd0JBQXdCO1FBQ2pELElBQUksQ0FBQ0gsbUJBQW1CLEdBQUcsSUFBSXJHLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztJQUMvQztBQWdaRjtBQXBnQmFFLFNBQ1kwSCxnQkFBZ0IsV0FBWSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL01vdmVtZW50LnRzPzE4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTW92ZW1lbnQgY29tcG9uZW50IGZvciB2ZWxvY2l0eSBhbmQgbW92ZW1lbnQgcHJvcGVydGllc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgTW92ZW1lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnTW92ZW1lbnQnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnTW92ZW1lbnQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB2ZWxvY2l0eTogVmVjdG9yMztcbiAgcHVibGljIGFjY2VsZXJhdGlvbjogVmVjdG9yMztcbiAgcHVibGljIG1heFNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyBmcmljdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaXNHcm91bmRlZDogYm9vbGVhbjtcbiAgcHVibGljIGp1bXBGb3JjZTogbnVtYmVyO1xuICBwdWJsaWMgZ3Jhdml0eTogbnVtYmVyO1xuXG4gIC8vIE1vdmVtZW50IGZsYWdzXG4gIHB1YmxpYyBjYW5Nb3ZlOiBib29sZWFuO1xuICBwdWJsaWMgY2FuSnVtcDogYm9vbGVhbjtcbiAgcHVibGljIGNhbkZseTogYm9vbGVhbjtcblxuICAvLyBEZWJ1ZmYgc3RhdGVzIGZvciBQVlBcbiAgcHVibGljIGlzRnJvemVuOiBib29sZWFuO1xuICBwdWJsaWMgZnJvemVuVW50aWw6IG51bWJlcjtcbiAgcHVibGljIGlzU2xvd2VkOiBib29sZWFuO1xuICBwdWJsaWMgc2xvd2VkVW50aWw6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWRNdWx0aXBsaWVyOiBudW1iZXI7XG4gIFxuICAvLyBDb3JydXB0ZWQgZGVidWZmIHN0YXRlIChXcmFpdGhTdHJpa2UpXG4gIHB1YmxpYyBpc0NvcnJ1cHRlZDogYm9vbGVhbjtcbiAgcHVibGljIGNvcnJ1cHRlZFN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgY29ycnVwdGVkRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGNvcnJ1cHRlZEluaXRpYWxTbG93UGVyY2VudDogbnVtYmVyOyAvLyBJbml0aWFsIHNsb3cgcGVyY2VudGFnZSAoOTAlKVxuICBwdWJsaWMgY29ycnVwdGVkUmVjb3ZlcnlSYXRlOiBudW1iZXI7IC8vIFJlY292ZXJ5IHJhdGUgcGVyIHNlY29uZCAoMTAlKVxuXG4gIC8vIElucHV0LWJhc2VkIG1vdmVtZW50XG4gIHB1YmxpYyBtb3ZlRGlyZWN0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgaW5wdXRTdHJlbmd0aDogbnVtYmVyO1xuXG4gIC8vIERhc2gvVmF1bHQgc3lzdGVtXG4gIHB1YmxpYyBpc0Rhc2hpbmc6IGJvb2xlYW47XG4gIHB1YmxpYyBkYXNoRGlyZWN0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgZGFzaFN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgZGFzaER1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoRGlzdGFuY2U6IG51bWJlcjtcbiAgcHVibGljIGRhc2hTdGFydFBvc2l0aW9uOiBWZWN0b3IzO1xuICBcbiAgLy8gTXVsdGlwbGUgZGFzaCBjaGFyZ2VzIHN5c3RlbVxuICBwdWJsaWMgZGFzaENoYXJnZXM6IEFycmF5PHtcbiAgICBpc0F2YWlsYWJsZTogYm9vbGVhbjtcbiAgICBjb29sZG93blN0YXJ0VGltZTogbnVtYmVyIHwgbnVsbDtcbiAgfT47XG4gIHB1YmxpYyBtYXhEYXNoQ2hhcmdlczogbnVtYmVyO1xuXG4gIC8vIFN3b3JkIENoYXJnZSBhYmlsaXR5IHN5c3RlbSAoc2VwYXJhdGUgZnJvbSBkYXNoZXMpXG4gIHB1YmxpYyBpc0NoYXJnaW5nOiBib29sZWFuO1xuICBwdWJsaWMgY2hhcmdlRGlyZWN0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgY2hhcmdlU3RhcnRUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlRGlzdGFuY2U6IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZVN0YXJ0UG9zaXRpb246IFZlY3RvcjM7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWF4U3BlZWQ6IG51bWJlciA9IDMuNzUsXG4gICAgZnJpY3Rpb246IG51bWJlciA9IDAuOCxcbiAgICBqdW1wRm9yY2U6IG51bWJlciA9IDIwLjAsXG4gICAgZ3Jhdml0eTogbnVtYmVyID0gLTEyLjVcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLm1heFNwZWVkID0gbWF4U3BlZWQ7XG4gICAgdGhpcy5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIHRoaXMuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuanVtcEZvcmNlID0ganVtcEZvcmNlO1xuICAgIHRoaXMuZ3Jhdml0eSA9IGdyYXZpdHk7XG4gICAgXG4gICAgdGhpcy5jYW5Nb3ZlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkp1bXAgPSB0cnVlO1xuICAgIHRoaXMuY2FuRmx5ID0gZmFsc2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGRlYnVmZiBzdGF0ZXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgdGhpcy5pc1Nsb3dlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2xvd2VkVW50aWwgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSAxLjA7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBjb3JydXB0ZWQgZGVidWZmIHN0YXRlc1xuICAgIHRoaXMuaXNDb3JydXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvcnJ1cHRlZFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5jb3JydXB0ZWREdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5jb3JydXB0ZWRJbml0aWFsU2xvd1BlcmNlbnQgPSAwLjk7IC8vIDkwJSBpbml0aWFsIHNsb3dcbiAgICB0aGlzLmNvcnJ1cHRlZFJlY292ZXJ5UmF0ZSA9IDAuMTsgLy8gMTAlIHJlY292ZXJ5IHBlciBzZWNvbmRcbiAgICBcbiAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkYXNoIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1OyAvLyAzNTBtcyBkYXNoIGR1cmF0aW9uIChzYW1lIGFzIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICB0aGlzLmRhc2hEaXN0YW5jZSA9IDQ7IC8vIEluY3JlYXNlZCBmcm9tIDMuMTI1IGZvciBtb3JlIG5vdGljZWFibGUgZGFzaFxuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIG11bHRpcGxlIGRhc2ggY2hhcmdlcyAoMyBjaGFyZ2VzLCBlYWNoIHdpdGggNnMgY29vbGRvd24pXG4gICAgdGhpcy5tYXhEYXNoQ2hhcmdlcyA9IDM7XG4gICAgdGhpcy5kYXNoQ2hhcmdlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMubWF4RGFzaENoYXJnZXMgfSwgKCkgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IG51bGxcbiAgICB9KSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHN3b3JkIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5jaGFyZ2VEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGNoYXJnZSBkdXJhdGlvblxuICAgIHRoaXMuY2hhcmdlRGlzdGFuY2UgPSA5OyAvLyBTd29yZCBjaGFyZ2UgZGlzdGFuY2VcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRGb3JjZShmb3JjZTogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uLmFkZChmb3JjZSk7XG4gIH1cblxuICBwdWJsaWMgYWRkSW1wdWxzZShpbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5hZGQoaW1wdWxzZSk7XG4gIH1cblxuICBwdWJsaWMganVtcCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYW5KdW1wICYmICh0aGlzLmlzR3JvdW5kZWQgfHwgdGhpcy5jYW5GbHkpKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLmp1bXBGb3JjZTtcbiAgICAgIHRoaXMuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRNb3ZlRGlyZWN0aW9uKGRpcmVjdGlvbjogVmVjdG9yMywgc3RyZW5ndGg6IG51bWJlciA9IDEuMCk6IHZvaWQge1xuICAgIHRoaXMubW92ZURpcmVjdGlvbi5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCk7XG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc3RyZW5ndGgpKTtcbiAgfVxuXG4gIHB1YmxpYyBmcmVlemUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzRnJvemVuID0gdHJ1ZTtcbiAgICB0aGlzLmZyb3plblVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+niiBQbGF5ZXIgZnJvemVuIGZvciAke2R1cmF0aW9ufW1zIHVudGlsICR7dGhpcy5mcm96ZW5VbnRpbH0gKGN1cnJlbnQ6ICR7Y3VycmVudFRpbWV9KWApO1xuICB9XG5cbiAgcHVibGljIHNsb3coZHVyYXRpb246IG51bWJlciwgc3BlZWRNdWx0aXBsaWVyOiBudW1iZXIgPSAwLjUpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5pc1Nsb3dlZCA9IHRydWU7XG4gICAgdGhpcy5zbG93ZWRVbnRpbCA9IGN1cnJlbnRUaW1lICsgZHVyYXRpb247XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHNwZWVkTXVsdGlwbGllcjtcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+QjCBQbGF5ZXIgc2xvd2VkIHRvICR7c3BlZWRNdWx0aXBsaWVyICogMTAwfSUgc3BlZWQgZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLnNsb3dlZFVudGlsfWApO1xuICB9XG5cbiAgcHVibGljIGFwcGx5Q29ycnVwdGVkKGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzQ29ycnVwdGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvcnJ1cHRlZFN0YXJ0VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBTdG9yZSBpbiBzZWNvbmRzIGZvciBlYXNpZXIgY2FsY3VsYXRpb25zXG4gICAgdGhpcy5jb3JydXB0ZWREdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgdGhpcy5jb3JydXB0ZWRJbml0aWFsU2xvd1BlcmNlbnQgPSAwLjk7IC8vIDkwJSBpbml0aWFsIHNsb3dcbiAgICB0aGlzLmNvcnJ1cHRlZFJlY292ZXJ5UmF0ZSA9IDAuMTsgLy8gMTAlIHJlY292ZXJ5IHBlciBzZWNvbmRcbiAgICBjb25zb2xlLmxvZyhg8J+RuyBBcHBsaWVkIGNvcnJ1cHRlZCBkZWJ1ZmYgZm9yICR7ZHVyYXRpb259bXMgKCR7dGhpcy5jb3JydXB0ZWREdXJhdGlvbn1zKWApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZURlYnVmZnMoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIENoZWNrIGZyb3plbiBzdGF0ZVxuICAgIGlmICh0aGlzLmlzRnJvemVuICYmIGN1cnJlbnRUaW1lID49IHRoaXMuZnJvemVuVW50aWwpIHtcbiAgICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBzbG93ZWQgc3RhdGVcbiAgICBpZiAodGhpcy5pc1Nsb3dlZCAmJiBjdXJyZW50VGltZSA+PSB0aGlzLnNsb3dlZFVudGlsKSB7XG4gICAgICB0aGlzLmlzU2xvd2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICAgIHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSAxLjA7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGNvcnJ1cHRlZCBzdGF0ZVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lU2Vjb25kcyA9IGN1cnJlbnRUaW1lIC8gMTAwMDtcbiAgICBpZiAodGhpcy5pc0NvcnJ1cHRlZCkge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lU2Vjb25kcyAtIHRoaXMuY29ycnVwdGVkU3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWQgPj0gdGhpcy5jb3JydXB0ZWREdXJhdGlvbikge1xuICAgICAgICAvLyBDb3JydXB0ZWQgZGVidWZmIGhhcyBleHBpcmVkXG4gICAgICAgIHRoaXMuaXNDb3JydXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3JydXB0ZWRTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmNvcnJ1cHRlZER1cmF0aW9uID0gMDtcbiAgICAgICAgY29uc29sZS5sb2coYPCfkbsgQ29ycnVwdGVkIGRlYnVmZiBleHBpcmVkYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEVmZmVjdGl2ZU1heFNwZWVkKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNGcm96ZW4pIHtcbiAgICAgIHJldHVybiAwOyAvLyBDb21wbGV0ZWx5IGZyb3plblxuICAgIH1cbiAgICBcbiAgICBsZXQgc3BlZWQgPSB0aGlzLm1heFNwZWVkICogdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcbiAgICBcbiAgICAvLyBBcHBseSBjb3JydXB0ZWQgZGVidWZmIHNsb3cgZWZmZWN0IHdpdGggZ3JhZHVhbCByZWNvdmVyeVxuICAgIGlmICh0aGlzLmlzQ29ycnVwdGVkKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZVNlY29uZHMgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZVNlY29uZHMgLSB0aGlzLmNvcnJ1cHRlZFN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgc2xvdyBwZXJjZW50YWdlIGJhc2VkIG9uIGdyYWR1YWwgcmVjb3ZlcnlcbiAgICAgIC8vIEluaXRpYWw6IDkwJSBzbG93LCByZWNvdmVycyAxMCUgcGVyIHNlY29uZFxuICAgICAgY29uc3QgY3VycmVudFNsb3dQZXJjZW50ID0gTWF0aC5tYXgoMCwgdGhpcy5jb3JydXB0ZWRJbml0aWFsU2xvd1BlcmNlbnQgLSAoZWxhcHNlZCAqIHRoaXMuY29ycnVwdGVkUmVjb3ZlcnlSYXRlKSk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHRoZSBzbG93IGVmZmVjdCAocmVkdWNlIHNwZWVkIGJ5IHRoZSBzbG93IHBlcmNlbnRhZ2UpXG4gICAgICBzcGVlZCAqPSAoMSAtIGN1cnJlbnRTbG93UGVyY2VudCk7XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIGNvcnJ1cHRlZCBkZWJ1ZmYgKG9ubHkgbG9nIG9jY2FzaW9uYWxseSB0byBhdm9pZCBzcGFtKVxuICAgICAgaWYgKGVsYXBzZWQgJSAxLjAgPCAwLjEpIHsgLy8gTG9nIHJvdWdobHkgZXZlcnkgc2Vjb25kXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5G7IENvcnJ1cHRlZCBkZWJ1ZmY6ICR7KGN1cnJlbnRTbG93UGVyY2VudCAqIDEwMCkudG9GaXhlZCgxKX0lIHNsb3cgKCR7KCgxIC0gY3VycmVudFNsb3dQZXJjZW50KSAqIDEwMCkudG9GaXhlZCgxKX0lIHNwZWVkIHJlbWFpbmluZylgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNwZWVkO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0RGFzaChkaXJlY3Rpb246IFZlY3RvcjMsIGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMywgY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgZGFzaGluZ1xuICAgIGlmICh0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZpbmQgZmlyc3QgYXZhaWxhYmxlIGNoYXJnZVxuICAgIGNvbnN0IGF2YWlsYWJsZUNoYXJnZUluZGV4ID0gdGhpcy5kYXNoQ2hhcmdlcy5maW5kSW5kZXgoY2hhcmdlID0+IGNoYXJnZS5pc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUNoYXJnZUluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBjaGFyZ2VzIGF2YWlsYWJsZVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBkYXNoXG4gICAgdGhpcy5pc0Rhc2hpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGFzaERpcmVjdGlvbi5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbi5jb3B5KGN1cnJlbnRQb3NpdGlvbik7XG5cbiAgICAvLyBDb25zdW1lIHRoZSBjaGFyZ2VcbiAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5pc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaENoYXJnZXNbYXZhaWxhYmxlQ2hhcmdlSW5kZXhdLmNvb2xkb3duU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBTZXQgY29vbGRvd24gdGltZXIgZm9yIHRoaXMgc3BlY2lmaWMgY2hhcmdlICg2IHNlY29uZHMpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5pc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5jb29sZG93blN0YXJ0VGltZSA9IG51bGw7XG4gICAgfSwgNjAwMCk7IC8vIDYgc2Vjb25kIGNvb2xkb3duXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVEYXNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB7IGlzQ29tcGxldGU6IGJvb2xlYW47IG5ld1Bvc2l0aW9uOiBWZWN0b3IzIHwgbnVsbCB9IHtcbiAgICBpZiAoIXRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb246IG51bGwgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmRhc2hTdGFydFRpbWU7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gdGhpcy5kYXNoRHVyYXRpb24sIDEpO1xuXG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIC8vIERhc2ggY29tcGxldGVcbiAgICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gdGhpcy5kYXNoU3RhcnRQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgIC5hZGQodGhpcy5kYXNoRGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5kYXNoRGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IHRydWUsIG5ld1Bvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gdXNpbmcgZWFzaW5nIChlYXNlLW91dCBxdWFkLCBzYW1lIGFzIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICBjb25zdCBlYXNlT3V0UXVhZCA9IDEgLSBNYXRoLnBvdygxIC0gcHJvZ3Jlc3MsIDIpO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZGFzaERpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuZGFzaERpc3RhbmNlICogZWFzZU91dFF1YWQpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5kYXNoU3RhcnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkaXNwbGFjZW1lbnQpO1xuXG4gICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgY2FuY2VsRGFzaCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaERpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLm1vdmVEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3BlZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS5sZW5ndGgoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIb3Jpem9udGFsU3BlZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMudmVsb2NpdHkueCAqIHRoaXMudmVsb2NpdHkueCArIHRoaXMudmVsb2NpdHkueiAqIHRoaXMudmVsb2NpdHkueik7XG4gIH1cblxuICBwdWJsaWMgaXNNb3ZpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BlZWQoKSA+IDAuMDE7XG4gIH1cblxuICBwdWJsaWMgaXNNb3ZpbmdIb3Jpem9udGFsbHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SG9yaXpvbnRhbFNwZWVkKCkgPiAwLjAxO1xuICB9XG5cbiAgcHVibGljIGlzRmFsbGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS55IDwgLTAuMTtcbiAgfVxuXG4gIHB1YmxpYyBpc1Jpc2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS55ID4gMC4xO1xuICB9XG5cbiAgcHVibGljIGdldEF2YWlsYWJsZURhc2hDaGFyZ2VzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGFzaENoYXJnZXMuZmlsdGVyKGNoYXJnZSA9PiBjaGFyZ2UuaXNBdmFpbGFibGUpLmxlbmd0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREYXNoQ2hhcmdlU3RhdHVzKCk6IEFycmF5PHsgaXNBdmFpbGFibGU6IGJvb2xlYW47IGNvb2xkb3duUmVtYWluaW5nOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgcmV0dXJuIHRoaXMuZGFzaENoYXJnZXMubWFwKGNoYXJnZSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IGNoYXJnZS5pc0F2YWlsYWJsZSxcbiAgICAgIGNvb2xkb3duUmVtYWluaW5nOiBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWUgXG4gICAgICAgID8gTWF0aC5tYXgoMCwgNiAtIChjdXJyZW50VGltZSAtIGNoYXJnZS5jb29sZG93blN0YXJ0VGltZSkpXG4gICAgICAgIDogMFxuICAgIH0pKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydENoYXJnZShkaXJlY3Rpb246IFZlY3RvcjMsIGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMywgY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgY2hhcmdpbmcgb3IgZGFzaGluZ1xuICAgIGlmICh0aGlzLmlzQ2hhcmdpbmcgfHwgdGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgY2hhcmdlXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbi5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCk7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uY29weShjdXJyZW50UG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ2hhcmdlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB7IGlzQ29tcGxldGU6IGJvb2xlYW47IG5ld1Bvc2l0aW9uOiBWZWN0b3IzIHwgbnVsbCB9IHtcbiAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uOiBudWxsIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5jaGFyZ2VTdGFydFRpbWU7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gdGhpcy5jaGFyZ2VEdXJhdGlvbiwgMSk7XG5cbiAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgLy8gQ2hhcmdlIGNvbXBsZXRlXG4gICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGZpbmFsUG9zaXRpb24gPSB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHRoaXMuY2hhcmdlRGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5jaGFyZ2VEaXN0YW5jZSkpO1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogdHJ1ZSwgbmV3UG9zaXRpb246IGZpbmFsUG9zaXRpb24gfTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgY3VycmVudCBwb3NpdGlvbiB1c2luZyBlYXNpbmcgKGVhc2Utb3V0IHF1YWQpXG4gICAgY29uc3QgZWFzZU91dFF1YWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAyKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuY2hhcmdlRGlzdGFuY2UgKiBlYXNlT3V0UXVhZCk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uY2xvbmUoKS5hZGQoZGlzcGxhY2VtZW50KTtcblxuICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGNhbmNlbENoYXJnZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIGNsYW1wVmVsb2NpdHkoKTogdm9pZCB7XG4gICAgLy8gR2V0IGVmZmVjdGl2ZSBtYXggc3BlZWQgKGNvbnNpZGVyaW5nIGRlYnVmZnMpXG4gICAgY29uc3QgZWZmZWN0aXZlTWF4U3BlZWQgPSB0aGlzLmdldEVmZmVjdGl2ZU1heFNwZWVkKCk7XG4gICAgXG4gICAgLy8gQ2xhbXAgaG9yaXpvbnRhbCB2ZWxvY2l0eSB0byBlZmZlY3RpdmUgbWF4IHNwZWVkXG4gICAgY29uc3QgaG9yaXpvbnRhbFZlbG9jaXR5ID0gbmV3IFZlY3RvcjModGhpcy52ZWxvY2l0eS54LCAwLCB0aGlzLnZlbG9jaXR5LnopO1xuICAgIGNvbnN0IGhvcml6b250YWxTcGVlZCA9IGhvcml6b250YWxWZWxvY2l0eS5sZW5ndGgoKTtcbiAgICBcbiAgICBpZiAoaG9yaXpvbnRhbFNwZWVkID4gZWZmZWN0aXZlTWF4U3BlZWQpIHtcbiAgICAgIGlmIChlZmZlY3RpdmVNYXhTcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGZyb3plbiAtIHN0b3AgYWxsIGhvcml6b250YWwgbW92ZW1lbnRcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvcml6b250YWxWZWxvY2l0eS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihlZmZlY3RpdmVNYXhTcGVlZCk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IGhvcml6b250YWxWZWxvY2l0eS54O1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnogPSBob3Jpem9udGFsVmVsb2NpdHkuejtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXBwbHlGcmljdGlvbihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYW5Nb3ZlKSByZXR1cm47XG5cbiAgICAvLyBBcHBseSBmcmljdGlvbiB0byBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgY29uc3QgZnJpY3Rpb25Gb3JjZSA9IE1hdGgucG93KHRoaXMuZnJpY3Rpb24sIGRlbHRhVGltZSk7XG4gICAgdGhpcy52ZWxvY2l0eS54ICo9IGZyaWN0aW9uRm9yY2U7XG4gICAgdGhpcy52ZWxvY2l0eS56ICo9IGZyaWN0aW9uRm9yY2U7XG5cbiAgICAvLyBTdG9wIHZlcnkgc21hbGwgdmVsb2NpdGllcyB0byBwcmV2ZW50IGppdHRlclxuICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbG9jaXR5LngpIDwgMC4wMSkgdGhpcy52ZWxvY2l0eS54ID0gMDtcbiAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eS56KSA8IDAuMDEpIHRoaXMudmVsb2NpdHkueiA9IDA7XG4gIH1cblxuICBwdWJsaWMgYXBwbHlHcmF2aXR5KGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbkZseSkge1xuICAgICAgdGhpcy52ZWxvY2l0eS55ICs9IHRoaXMuZ3Jhdml0eSAqIGRlbHRhVGltZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMudmVsb2NpdHkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5hY2NlbGVyYXRpb24pIHtcbiAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZWxlcmF0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLm1vdmVEaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuICAgIHRoaXMuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuTW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5KdW1wID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkZseSA9IGZhbHNlO1xuICAgIHRoaXMubWF4U3BlZWQgPSA1LjA7XG4gICAgdGhpcy5mcmljdGlvbiA9IDAuODtcbiAgICB0aGlzLmp1bXBGb3JjZSA9IDIwLjA7XG4gICAgdGhpcy5ncmF2aXR5ID0gLTEyLjU7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFJlc2V0IGRlYnVmZiBzdGF0ZXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgdGhpcy5pc1Nsb3dlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2xvd2VkVW50aWwgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSAxLjA7XG5cbiAgICAvLyBSZXNldCBkYXNoIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaERpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRhc2hEdXJhdGlvbiA9IDAuMzU7XG4gICAgdGhpcy5kYXNoRGlzdGFuY2UgPSA0O1xuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIFxuICAgIC8vIFJlc2V0IGRhc2ggY2hhcmdlc1xuICAgIHRoaXMubWF4RGFzaENoYXJnZXMgPSAzO1xuICAgIHRoaXMuZGFzaENoYXJnZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLm1heERhc2hDaGFyZ2VzIH0sICgpID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgIGNvb2xkb3duU3RhcnRUaW1lOiBudWxsXG4gICAgfSkpO1xuXG4gICAgLy8gUmVzZXQgY2hhcmdlIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuY2hhcmdlRHVyYXRpb24gPSAwLjM1O1xuICAgIHRoaXMuY2hhcmdlRGlzdGFuY2UgPSA5O1xuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogTW92ZW1lbnQge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IE1vdmVtZW50KHRoaXMubWF4U3BlZWQsIHRoaXMuZnJpY3Rpb24sIHRoaXMuanVtcEZvcmNlLCB0aGlzLmdyYXZpdHkpO1xuICAgIGNsb25lLnZlbG9jaXR5LmNvcHkodGhpcy52ZWxvY2l0eSk7XG4gICAgY2xvbmUuYWNjZWxlcmF0aW9uLmNvcHkodGhpcy5hY2NlbGVyYXRpb24pO1xuICAgIGNsb25lLm1vdmVEaXJlY3Rpb24uY29weSh0aGlzLm1vdmVEaXJlY3Rpb24pO1xuICAgIGNsb25lLmlucHV0U3RyZW5ndGggPSB0aGlzLmlucHV0U3RyZW5ndGg7XG4gICAgY2xvbmUuaXNHcm91bmRlZCA9IHRoaXMuaXNHcm91bmRlZDtcbiAgICBjbG9uZS5jYW5Nb3ZlID0gdGhpcy5jYW5Nb3ZlO1xuICAgIGNsb25lLmNhbkp1bXAgPSB0aGlzLmNhbkp1bXA7XG4gICAgY2xvbmUuY2FuRmx5ID0gdGhpcy5jYW5GbHk7XG5cbiAgICAvLyBDbG9uZSBkZWJ1ZmYgc3RhdGVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyb3plblVudGlsID0gdGhpcy5mcm96ZW5VbnRpbDtcbiAgICBjbG9uZS5pc1Nsb3dlZCA9IHRoaXMuaXNTbG93ZWQ7XG4gICAgY2xvbmUuc2xvd2VkVW50aWwgPSB0aGlzLnNsb3dlZFVudGlsO1xuICAgIGNsb25lLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcblxuICAgIC8vIENsb25lIGRhc2ggcHJvcGVydGllc1xuICAgIGNsb25lLmlzRGFzaGluZyA9IHRoaXMuaXNEYXNoaW5nO1xuICAgIGNsb25lLmRhc2hEaXJlY3Rpb24uY29weSh0aGlzLmRhc2hEaXJlY3Rpb24pO1xuICAgIGNsb25lLmRhc2hTdGFydFRpbWUgPSB0aGlzLmRhc2hTdGFydFRpbWU7XG4gICAgY2xvbmUuZGFzaER1cmF0aW9uID0gdGhpcy5kYXNoRHVyYXRpb247XG4gICAgY2xvbmUuZGFzaERpc3RhbmNlID0gdGhpcy5kYXNoRGlzdGFuY2U7XG4gICAgY2xvbmUuZGFzaFN0YXJ0UG9zaXRpb24uY29weSh0aGlzLmRhc2hTdGFydFBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBDbG9uZSBkYXNoIGNoYXJnZXNcbiAgICBjbG9uZS5tYXhEYXNoQ2hhcmdlcyA9IHRoaXMubWF4RGFzaENoYXJnZXM7XG4gICAgY2xvbmUuZGFzaENoYXJnZXMgPSB0aGlzLmRhc2hDaGFyZ2VzLm1hcChjaGFyZ2UgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiBjaGFyZ2UuaXNBdmFpbGFibGUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lXG4gICAgfSkpO1xuXG4gICAgLy8gQ2xvbmUgY2hhcmdlIHByb3BlcnRpZXNcbiAgICBjbG9uZS5pc0NoYXJnaW5nID0gdGhpcy5pc0NoYXJnaW5nO1xuICAgIGNsb25lLmNoYXJnZURpcmVjdGlvbi5jb3B5KHRoaXMuY2hhcmdlRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5jaGFyZ2VTdGFydFRpbWUgPSB0aGlzLmNoYXJnZVN0YXJ0VGltZTtcbiAgICBjbG9uZS5jaGFyZ2VEdXJhdGlvbiA9IHRoaXMuY2hhcmdlRHVyYXRpb247XG4gICAgY2xvbmUuY2hhcmdlRGlzdGFuY2UgPSB0aGlzLmNoYXJnZURpc3RhbmNlO1xuICAgIGNsb25lLmNoYXJnZVN0YXJ0UG9zaXRpb24uY29weSh0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbXBvbmVudCIsIk1vdmVtZW50IiwiYWRkRm9yY2UiLCJmb3JjZSIsImFjY2VsZXJhdGlvbiIsImFkZCIsImFkZEltcHVsc2UiLCJpbXB1bHNlIiwidmVsb2NpdHkiLCJqdW1wIiwiY2FuSnVtcCIsImlzR3JvdW5kZWQiLCJjYW5GbHkiLCJ5IiwianVtcEZvcmNlIiwic2V0TW92ZURpcmVjdGlvbiIsImRpcmVjdGlvbiIsInN0cmVuZ3RoIiwibW92ZURpcmVjdGlvbiIsImNvcHkiLCJub3JtYWxpemUiLCJpbnB1dFN0cmVuZ3RoIiwiTWF0aCIsIm1heCIsIm1pbiIsImZyZWV6ZSIsImR1cmF0aW9uIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwiaXNGcm96ZW4iLCJmcm96ZW5VbnRpbCIsInNsb3ciLCJzcGVlZE11bHRpcGxpZXIiLCJpc1Nsb3dlZCIsInNsb3dlZFVudGlsIiwibW92ZW1lbnRTcGVlZE11bHRpcGxpZXIiLCJhcHBseUNvcnJ1cHRlZCIsImlzQ29ycnVwdGVkIiwiY29ycnVwdGVkU3RhcnRUaW1lIiwiY29ycnVwdGVkRHVyYXRpb24iLCJjb3JydXB0ZWRJbml0aWFsU2xvd1BlcmNlbnQiLCJjb3JydXB0ZWRSZWNvdmVyeVJhdGUiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlRGVidWZmcyIsImN1cnJlbnRUaW1lU2Vjb25kcyIsImVsYXBzZWQiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsInNwZWVkIiwibWF4U3BlZWQiLCJjdXJyZW50U2xvd1BlcmNlbnQiLCJ0b0ZpeGVkIiwic3RhcnREYXNoIiwiY3VycmVudFBvc2l0aW9uIiwiaXNEYXNoaW5nIiwiYXZhaWxhYmxlQ2hhcmdlSW5kZXgiLCJkYXNoQ2hhcmdlcyIsImZpbmRJbmRleCIsImNoYXJnZSIsImlzQXZhaWxhYmxlIiwiZGFzaERpcmVjdGlvbiIsImRhc2hTdGFydFRpbWUiLCJkYXNoU3RhcnRQb3NpdGlvbiIsImNvb2xkb3duU3RhcnRUaW1lIiwic2V0VGltZW91dCIsInVwZGF0ZURhc2giLCJpc0NvbXBsZXRlIiwibmV3UG9zaXRpb24iLCJwcm9ncmVzcyIsImRhc2hEdXJhdGlvbiIsImZpbmFsUG9zaXRpb24iLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwiZGFzaERpc3RhbmNlIiwiZWFzZU91dFF1YWQiLCJwb3ciLCJkaXNwbGFjZW1lbnQiLCJjYW5jZWxEYXNoIiwic2V0Iiwic3RvcCIsImdldFNwZWVkIiwibGVuZ3RoIiwiZ2V0SG9yaXpvbnRhbFNwZWVkIiwic3FydCIsIngiLCJ6IiwiaXNNb3ZpbmciLCJpc01vdmluZ0hvcml6b250YWxseSIsImlzRmFsbGluZyIsImlzUmlzaW5nIiwiZ2V0QXZhaWxhYmxlRGFzaENoYXJnZXMiLCJmaWx0ZXIiLCJnZXREYXNoQ2hhcmdlU3RhdHVzIiwibWFwIiwiY29vbGRvd25SZW1haW5pbmciLCJzdGFydENoYXJnZSIsImlzQ2hhcmdpbmciLCJjaGFyZ2VEaXJlY3Rpb24iLCJjaGFyZ2VTdGFydFRpbWUiLCJjaGFyZ2VTdGFydFBvc2l0aW9uIiwidXBkYXRlQ2hhcmdlIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VEaXN0YW5jZSIsImNhbmNlbENoYXJnZSIsImNsYW1wVmVsb2NpdHkiLCJlZmZlY3RpdmVNYXhTcGVlZCIsImhvcml6b250YWxWZWxvY2l0eSIsImhvcml6b250YWxTcGVlZCIsImFwcGx5RnJpY3Rpb24iLCJkZWx0YVRpbWUiLCJjYW5Nb3ZlIiwiZnJpY3Rpb25Gb3JjZSIsImZyaWN0aW9uIiwiYWJzIiwiYXBwbHlHcmF2aXR5IiwiZ3Jhdml0eSIsInJlc2V0IiwiZW5hYmxlZCIsIm1heERhc2hDaGFyZ2VzIiwiQXJyYXkiLCJmcm9tIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    setMaxDistance(maxDistance) {\n        this.maxDistance = maxDistance;\n    }\n    setStartPosition(position) {\n        this.startPosition.copy(position);\n    }\n    setHoming(targetEntityId) {\n        let homingStrength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.8, maxTurnRate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Math.PI;\n        this.targetEntityId = targetEntityId;\n        this.homingStrength = Math.max(0, Math.min(1, homingStrength)); // Clamp between 0 and 1\n        this.maxTurnRate = maxTurnRate;\n    }\n    disableHoming() {\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime || this.distanceTraveled >= this.maxDistance;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Track distance traveled\n        const distanceThisFrame = this.velocity.length() * deltaTime;\n        this.distanceTraveled += distanceThisFrame;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.sourcePlayerId = \"unknown\";\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity;\n        this.startPosition.set(0, 0, 0);\n        this.projectileType = \"generic\";\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n        this.maxTurnRate = Math.PI;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner, this.sourcePlayerId, this.projectileType);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        clone.distanceTraveled = this.distanceTraveled;\n        clone.maxDistance = this.maxDistance;\n        clone.startPosition.copy(this.startPosition);\n        clone.targetEntityId = this.targetEntityId;\n        clone.homingStrength = this.homingStrength;\n        clone.maxTurnRate = this.maxTurnRate;\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1, sourcePlayerId = \"unknown\", projectileType = \"generic\"){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n        this.sourcePlayerId = sourcePlayerId;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity; // Default to no distance limit\n        this.startPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.projectileType = projectileType;\n        // Initialize homing properties\n        this.targetEntityId = null;\n        this.homingStrength = 0; // Default to no homing\n        this.maxTurnRate = Math.PI; // Default to 180 degrees per second turn rate\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBNERoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGVBQWVDLFdBQW1CLEVBQVE7UUFDL0MsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3JCO0lBRU9DLGlCQUFpQkMsUUFBaUIsRUFBUTtRQUMvQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2pCLElBQUksQ0FBQ2dCO0lBQzFCO0lBRU9FLFVBQVVDLGNBQXNCLEVBQXFFO1lBQW5FQyxpQkFBQUEsaUVBQXlCLEtBQUtDLGNBQUFBLGlFQUFzQkMsS0FBS0MsRUFBRTtRQUNsRyxJQUFJLENBQUNKLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdFLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLRyxHQUFHLENBQUMsR0FBR0wsa0JBQWtCLHdCQUF3QjtRQUN4RixJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDckI7SUFFT0ssZ0JBQXNCO1FBQzNCLElBQUksQ0FBQ1AsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxH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RS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzPzcwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdGlsZSBjb21wb25lbnQgZm9yIGJ1bGxldHMsIHNwZWxscywgYW5kIG90aGVyIHByb2plY3RpbGVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aWxlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Byb2plY3RpbGUnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnUHJvamVjdGlsZSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgc3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZTogbnVtYmVyO1xuICBwdWJsaWMgbGlmZXRpbWU6IG51bWJlcjtcbiAgcHVibGljIG1heExpZmV0aW1lOiBudW1iZXI7XG4gIHB1YmxpYyBwaWVyY2luZzogYm9vbGVhbjtcbiAgcHVibGljIGhpdFRhcmdldHM6IFNldDxudW1iZXI+OyAvLyBFbnRpdHkgSURzIHRoYXQgaGF2ZSBiZWVuIGhpdFxuICBwdWJsaWMgZXhwbG9zaW9uUmFkaXVzOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG4gIHB1YmxpYyBib3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBtYXhCb3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBvd25lcjogbnVtYmVyOyAvLyBFbnRpdHkgSUQgb2YgdGhlIG93bmVyXG4gIHB1YmxpYyBzb3VyY2VQbGF5ZXJJZDogc3RyaW5nOyAvLyBQbGF5ZXIgSUQgb2YgdGhlIHNvdXJjZSAoZm9yIG11bHRpcGxheWVyIHRlYW0gdmFsaWRhdGlvbilcbiAgcHVibGljIGRpc3RhbmNlVHJhdmVsZWQ6IG51bWJlcjsgLy8gVHJhY2sgZGlzdGFuY2UgdHJhdmVsZWRcbiAgcHVibGljIG1heERpc3RhbmNlOiBudW1iZXI7IC8vIE1heGltdW0gZGlzdGFuY2UgYmVmb3JlIGV4cGlyaW5nXG4gIHB1YmxpYyBzdGFydFBvc2l0aW9uOiBWZWN0b3IzOyAvLyBTdGFydGluZyBwb3NpdGlvbiBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cbiAgcHVibGljIHByb2plY3RpbGVUeXBlOiBzdHJpbmc7IC8vIFR5cGUgb2YgcHJvamVjdGlsZSAoZS5nLiwgJ3ZpcGVyX3N0aW5nJywgJ2Fycm93JywgZXRjLilcblxuICAvLyBIb21pbmcgcHJvcGVydGllc1xuICBwdWJsaWMgdGFyZ2V0RW50aXR5SWQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCB0byBob21lIHRvd2FyZHNcbiAgcHVibGljIGhvbWluZ1N0cmVuZ3RoOiBudW1iZXI7IC8vIEhvdyBzdHJvbmdseSBpdCBob21lcyAoMC0xKVxuICBwdWJsaWMgbWF4VHVyblJhdGU6IG51bWJlcjsgLy8gTWF4aW11bSByYWRpYW5zIHBlciBzZWNvbmQgdGhlIHByb2plY3RpbGUgY2FuIHR1cm5cblxuICBjb25zdHJ1Y3RvcihcbiAgICBzcGVlZDogbnVtYmVyID0gMjAsXG4gICAgZGFtYWdlOiBudW1iZXIgPSAxMCxcbiAgICBtYXhMaWZldGltZTogbnVtYmVyID0gNSxcbiAgICBvd25lcjogbnVtYmVyID0gLTEsXG4gICAgc291cmNlUGxheWVySWQ6IHN0cmluZyA9ICd1bmtub3duJyxcbiAgICBwcm9qZWN0aWxlVHlwZTogc3RyaW5nID0gJ2dlbmVyaWMnXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICB0aGlzLmxpZmV0aW1lID0gMDtcbiAgICB0aGlzLm1heExpZmV0aW1lID0gbWF4TGlmZXRpbWU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV4cGxvc2lvblJhZGl1cyA9IDA7XG4gICAgdGhpcy5ncmF2aXR5ID0gMDsgLy8gTW9zdCBwcm9qZWN0aWxlcyBpZ25vcmUgZ3Jhdml0eVxuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5zb3VyY2VQbGF5ZXJJZCA9IHNvdXJjZVBsYXllcklkO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5OyAvLyBEZWZhdWx0IHRvIG5vIGRpc3RhbmNlIGxpbWl0XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5wcm9qZWN0aWxlVHlwZSA9IHByb2plY3RpbGVUeXBlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBob21pbmcgcHJvcGVydGllc1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSBudWxsO1xuICAgIHRoaXMuaG9taW5nU3RyZW5ndGggPSAwOyAvLyBEZWZhdWx0IHRvIG5vIGhvbWluZ1xuICAgIHRoaXMubWF4VHVyblJhdGUgPSBNYXRoLlBJOyAvLyBEZWZhdWx0IHRvIDE4MCBkZWdyZWVzIHBlciBzZWNvbmQgdHVybiByYXRlXG4gIH1cblxuICBwdWJsaWMgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMudmVsb2NpdHkuY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuc3BlZWQpO1xuICB9XG5cbiAgcHVibGljIGFkZEdyYXZpdHkoZ3Jhdml0eTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5ncmF2aXR5ID0gZ3Jhdml0eTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQaWVyY2luZyhwaWVyY2luZzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucGllcmNpbmcgPSBwaWVyY2luZztcbiAgfVxuXG4gIHB1YmxpYyBzZXRFeHBsb3NpdmUocmFkaXVzOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGxvc2lvblJhZGl1cyA9IHJhZGl1cztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCb3VuY2luZyhtYXhCb3VuY2VzOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLm1heEJvdW5jZXMgPSBtYXhCb3VuY2VzO1xuICB9XG5cbiAgcHVibGljIHNldE1heERpc3RhbmNlKG1heERpc3RhbmNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gIH1cblxuICBwdWJsaWMgc2V0U3RhcnRQb3NpdGlvbihwb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIb21pbmcodGFyZ2V0RW50aXR5SWQ6IG51bWJlciwgaG9taW5nU3RyZW5ndGg6IG51bWJlciA9IDAuOCwgbWF4VHVyblJhdGU6IG51bWJlciA9IE1hdGguUEkpOiB2b2lkIHtcbiAgICB0aGlzLnRhcmdldEVudGl0eUlkID0gdGFyZ2V0RW50aXR5SWQ7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGhvbWluZ1N0cmVuZ3RoKSk7IC8vIENsYW1wIGJldHdlZW4gMCBhbmQgMVxuICAgIHRoaXMubWF4VHVyblJhdGUgPSBtYXhUdXJuUmF0ZTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNhYmxlSG9taW5nKCk6IHZvaWQge1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSBudWxsO1xuICAgIHRoaXMuaG9taW5nU3RyZW5ndGggPSAwO1xuICB9XG5cbiAgcHVibGljIGhhc0hpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGl0VGFyZ2V0cy5oYXMoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGFkZEhpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5oaXRUYXJnZXRzLmFkZChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgY2FuSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDYW4ndCBoaXQgb3duZXJcbiAgICBpZiAoZW50aXR5SWQgPT09IHRoaXMub3duZXIpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBJZiBwaWVyY2luZywgY2FuIGhpdCB0YXJnZXRzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKHRoaXMucGllcmNpbmcpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIC8vIE90aGVyd2lzZSwgY2FuIG9ubHkgaGl0IGVhY2ggdGFyZ2V0IG9uY2VcbiAgICByZXR1cm4gIXRoaXMuaGFzSGl0VGFyZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0V4cGlyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGlmZXRpbWUgPj0gdGhpcy5tYXhMaWZldGltZSB8fCB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPj0gdGhpcy5tYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Cb3VuY2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmNlcyA8IHRoaXMubWF4Qm91bmNlcztcbiAgfVxuXG4gIHB1YmxpYyBib3VuY2Uobm9ybWFsOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbkJvdW5jZSgpKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVmbGVjdCB2ZWxvY2l0eSBvZmYgdGhlIHN1cmZhY2Ugbm9ybWFsXG4gICAgY29uc3QgcmVmbGVjdGlvbiA9IHRoaXMudmVsb2NpdHkuY2xvbmUoKS5yZWZsZWN0KG5vcm1hbCk7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KHJlZmxlY3Rpb24pO1xuICAgIHRoaXMuYm91bmNlcysrO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGlmZXRpbWUgKz0gZGVsdGFUaW1lO1xuICAgIFxuICAgIC8vIFRyYWNrIGRpc3RhbmNlIHRyYXZlbGVkXG4gICAgY29uc3QgZGlzdGFuY2VUaGlzRnJhbWUgPSB0aGlzLnZlbG9jaXR5Lmxlbmd0aCgpICogZGVsdGFUaW1lO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCArPSBkaXN0YW5jZVRoaXNGcmFtZTtcbiAgICBcbiAgICAvLyBBcHBseSBncmF2aXR5IGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5ncmF2aXR5ICE9PSAwKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgKz0gdGhpcy5ncmF2aXR5ICogZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRQb3NpdGlvbih0cmFuc2Zvcm06IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtLmNsb25lKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0UHJlZGljdGVkUG9zaXRpb24odHJhbnNmb3JtOiBWZWN0b3IzLCBkZWx0YVRpbWU6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIGNvbnN0IHByZWRpY3RlZCA9IHRyYW5zZm9ybS5jbG9uZSgpO1xuICAgIHByZWRpY3RlZC5hZGQodGhpcy52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSkpO1xuICAgIHJldHVybiBwcmVkaWN0ZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5zcGVlZCA9IDIwO1xuICAgIHRoaXMuZGFtYWdlID0gMTA7XG4gICAgdGhpcy5saWZldGltZSA9IDA7XG4gICAgdGhpcy5tYXhMaWZldGltZSA9IDU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cy5jbGVhcigpO1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gMDtcbiAgICB0aGlzLmdyYXZpdHkgPSAwO1xuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gLTE7XG4gICAgdGhpcy5zb3VyY2VQbGF5ZXJJZCA9ICd1bmtub3duJztcbiAgICB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPSAwO1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMucHJvamVjdGlsZVR5cGUgPSAnZ2VuZXJpYyc7XG4gICAgdGhpcy50YXJnZXRFbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXhUdXJuUmF0ZSA9IE1hdGguUEk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBQcm9qZWN0aWxlIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBQcm9qZWN0aWxlKHRoaXMuc3BlZWQsIHRoaXMuZGFtYWdlLCB0aGlzLm1heExpZmV0aW1lLCB0aGlzLm93bmVyLCB0aGlzLnNvdXJjZVBsYXllcklkLCB0aGlzLnByb2plY3RpbGVUeXBlKTtcbiAgICBjbG9uZS52ZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkpO1xuICAgIGNsb25lLmxpZmV0aW1lID0gdGhpcy5saWZldGltZTtcbiAgICBjbG9uZS5waWVyY2luZyA9IHRoaXMucGllcmNpbmc7XG4gICAgY2xvbmUuaGl0VGFyZ2V0cyA9IG5ldyBTZXQodGhpcy5oaXRUYXJnZXRzKTtcbiAgICBjbG9uZS5leHBsb3Npb25SYWRpdXMgPSB0aGlzLmV4cGxvc2lvblJhZGl1cztcbiAgICBjbG9uZS5ncmF2aXR5ID0gdGhpcy5ncmF2aXR5O1xuICAgIGNsb25lLmJvdW5jZXMgPSB0aGlzLmJvdW5jZXM7XG4gICAgY2xvbmUubWF4Qm91bmNlcyA9IHRoaXMubWF4Qm91bmNlcztcbiAgICBjbG9uZS5kaXN0YW5jZVRyYXZlbGVkID0gdGhpcy5kaXN0YW5jZVRyYXZlbGVkO1xuICAgIGNsb25lLm1heERpc3RhbmNlID0gdGhpcy5tYXhEaXN0YW5jZTtcbiAgICBjbG9uZS5zdGFydFBvc2l0aW9uLmNvcHkodGhpcy5zdGFydFBvc2l0aW9uKTtcbiAgICBjbG9uZS50YXJnZXRFbnRpdHlJZCA9IHRoaXMudGFyZ2V0RW50aXR5SWQ7XG4gICAgY2xvbmUuaG9taW5nU3RyZW5ndGggPSB0aGlzLmhvbWluZ1N0cmVuZ3RoO1xuICAgIGNsb25lLm1heFR1cm5SYXRlID0gdGhpcy5tYXhUdXJuUmF0ZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29tcG9uZW50IiwiUHJvamVjdGlsZSIsInNldERpcmVjdGlvbiIsImRpcmVjdGlvbiIsInZlbG9jaXR5IiwiY29weSIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwic3BlZWQiLCJhZGRHcmF2aXR5IiwiZ3Jhdml0eSIsInNldFBpZXJjaW5nIiwicGllcmNpbmciLCJzZXRFeHBsb3NpdmUiLCJyYWRpdXMiLCJleHBsb3Npb25SYWRpdXMiLCJzZXRCb3VuY2luZyIsIm1heEJvdW5jZXMiLCJzZXRNYXhEaXN0YW5jZSIsIm1heERpc3RhbmNlIiwic2V0U3RhcnRQb3NpdGlvbiIsInBvc2l0aW9uIiwic3RhcnRQb3NpdGlvbiIsInNldEhvbWluZyIsInRhcmdldEVudGl0eUlkIiwiaG9taW5nU3RyZW5ndGgiLCJtYXhUdXJuUmF0ZSIsIk1hdGgiLCJQSSIsIm1heCIsIm1pbiIsImRpc2FibGVIb21pbmciLCJoYXNIaXRUYXJnZXQiLCJlbnRpdHlJZCIsImhpdFRhcmdldHMiLCJoYXMiLCJhZGRIaXRUYXJnZXQiLCJhZGQiLCJjYW5IaXRUYXJnZXQiLCJvd25lciIsImlzRXhwaXJlZCIsImxpZmV0aW1lIiwibWF4TGlmZXRpbWUiLCJkaXN0YW5jZVRyYXZlbGVkIiwiY2FuQm91bmNlIiwiYm91bmNlcyIsImJvdW5jZSIsIm5vcm1hbCIsInJlZmxlY3Rpb24iLCJjbG9uZSIsInJlZmxlY3QiLCJ1cGRhdGUiLCJkZWx0YVRpbWUiLCJkaXN0YW5jZVRoaXNGcmFtZSIsImxlbmd0aCIsInkiLCJnZXRQb3NpdGlvbiIsInRyYW5zZm9ybSIsImdldFByZWRpY3RlZFBvc2l0aW9uIiwicHJlZGljdGVkIiwicmVzZXQiLCJzZXQiLCJkYW1hZ2UiLCJjbGVhciIsInNvdXJjZVBsYXllcklkIiwiSW5maW5pdHkiLCJwcm9qZWN0aWxlVHlwZSIsImVuYWJsZWQiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/SummonedUnit.ts":
/*!********************************************!*\
  !*** ./src/ecs/components/SummonedUnit.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummonedUnit: function() { return /* binding */ SummonedUnit; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// SummonedUnit component for PVP tower minions\n\nclass SummonedUnit extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    isExpired(currentTime) {\n        return this.isDead || currentTime - this.summonTime >= this.lifetime;\n    }\n    getDisplayName() {\n        return \"Unit (\".concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.unitId = \"\";\n        this.attackRange = 4;\n        this.attackDamage = 60;\n        this.attackCooldown = 2.0;\n        this.lastAttackTime = 0;\n        this.maxHealth = 1000;\n        this.moveSpeed = 2.25;\n        this.targetPosition = null;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.summonTime = Date.now() / 1000;\n        this.lifetime = 120;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new SummonedUnit(this.ownerId, this.unitId, this.targetPosition);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.maxHealth = this.maxHealth;\n        clone.moveSpeed = this.moveSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.summonTime = this.summonTime;\n        clone.lifetime = this.lifetime;\n        return clone;\n    }\n    constructor(ownerId = \"\", unitId = \"\", targetPosition = null){\n        super();\n        this.componentType = \"SummonedUnit\";\n        this.ownerId = ownerId;\n        this.unitId = unitId;\n        // Combat configuration\n        this.attackRange = 4; // 4 unit attack range as specified\n        this.attackDamage = 60; // 15 damage per hit as specified\n        this.attackCooldown = 2.0; // 1 second between attacks\n        this.lastAttackTime = 0;\n        this.maxHealth = 1000; // 500 HP as specified\n        // Movement configuration\n        this.moveSpeed = 2.25; // Moderate movement speed\n        this.targetPosition = targetPosition;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        // Summon properties\n        this.summonTime = Date.now() / 1000; // Current time in seconds\n        this.lifetime = 120; // 2 minutes lifetime\n    }\n}\nSummonedUnit.componentType = \"SummonedUnit\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQ0FBK0M7QUFDVDtBQUUvQixNQUFNQyxxQkFBcUJELDhDQUFTQTtJQWlFbENFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLFVBQVVoQixXQUFtQixFQUFXO1FBQzdDLE9BQU8sSUFBSSxDQUFDRSxNQUFNLElBQUksY0FBZSxJQUFJLENBQUNlLFVBQVUsSUFBSyxJQUFJLENBQUNDLFFBQVE7SUFDeEU7SUFFT0MsaUJBQXlCO1FBQzlCLE9BQU8sU0FBc0IsT0FB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QUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ2EsU0FBUyxHQUFHO1FBRWpCLG9CQUFvQjtRQUNwQixJQUFJLENBQUNFLFVBQVUsR0FBR1csS0FBS0MsR0FBRyxLQUFLLE1BQU0sMEJBQTBCO1FBQy9ELElBQUksQ0FBQ1gsUUFBUSxHQUFHLEtBQUsscUJBQXFCO0lBQzVDO0FBbUZGO0FBbEphcEIsYUFDWW1DLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0LnRzPzVjOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3VtbW9uZWRVbml0IGNvbXBvbmVudCBmb3IgUFZQIHRvd2VyIG1pbmlvbnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBTdW1tb25lZFVuaXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcblxuICAvLyBPd25lcnNoaXAgYW5kIGlkZW50aWZpY2F0aW9uXG4gIHB1YmxpYyBvd25lcklkOiBzdHJpbmc7IC8vIFBsYXllciBJRCB3aG8gb3ducyB0aGlzIHVuaXRcbiAgcHVibGljIHVuaXRJZDogc3RyaW5nOyAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyB1bml0XG5cbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgbWF4SGVhbHRoOiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgcHJvcGVydGllc1xuICBwdWJsaWMgbW92ZVNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsOyAvLyBQb3NpdGlvbiB0byBtb3ZlIHRvd2FyZHNcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldCAodW5pdCBvciB0b3dlcilcbiAgcHVibGljIGxhc3RUYXJnZXRTZWFyY2hUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRTZWFyY2hDb29sZG93bjogbnVtYmVyOyAvLyBIb3cgb2Z0ZW4gdG8gc2VhcmNoIGZvciB0YXJnZXRzXG5cbiAgLy8gU3RhdGVcbiAgcHVibGljIGlzQWN0aXZlOiBib29sZWFuO1xuICBwdWJsaWMgaXNEZWFkOiBib29sZWFuO1xuICBwdWJsaWMgZGVhdGhUaW1lOiBudW1iZXI7XG5cbiAgLy8gU3VtbW9uIHByb3BlcnRpZXNcbiAgcHVibGljIHN1bW1vblRpbWU6IG51bWJlcjsgLy8gV2hlbiB0aGlzIHVuaXQgd2FzIHN1bW1vbmVkXG4gIHB1YmxpYyBsaWZldGltZTogbnVtYmVyOyAvLyBIb3cgbG9uZyB0aGlzIHVuaXQgbGl2ZXMgKGluIHNlY29uZHMpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdW5pdElkOiBzdHJpbmcgPSAnJyxcbiAgICB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcbiAgICB0aGlzLnVuaXRJZCA9IHVuaXRJZDtcblxuICAgIC8vIENvbWJhdCBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IDQ7IC8vIDQgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSA2MDsgLy8gMTUgZGFtYWdlIHBlciBoaXQgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDIuMDsgLy8gMSBzZWNvbmQgYmV0d2VlbiBhdHRhY2tzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tYXhIZWFsdGggPSAxMDAwOyAvLyA1MDAgSFAgYXMgc3BlY2lmaWVkXG5cbiAgICAvLyBNb3ZlbWVudCBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5tb3ZlU3BlZWQgPSAyLjI1OyAvLyBNb2RlcmF0ZSBtb3ZlbWVudCBzcGVlZFxuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvbjtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSAwLjU7IC8vIFNlYXJjaCBmb3IgdGFyZ2V0cyBldmVyeSAwLjUgc2Vjb25kc1xuXG4gICAgLy8gU3RhdGVcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcblxuICAgIC8vIFN1bW1vbiBwcm9wZXJ0aWVzXG4gICAgdGhpcy5zdW1tb25UaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIEN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXG4gICAgdGhpcy5saWZldGltZSA9IDEyMDsgLy8gMiBtaW51dGVzIGxpZmV0aW1lXG4gIH1cblxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc0RlYWQgfHwgIXRoaXMuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWUpID49IHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd247XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgc2V0VGFyZ2V0KHRhcmdldEVudGl0eUlkOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0RW50aXR5SWQ7XG4gIH1cblxuICBwdWJsaWMgY2xlYXJUYXJnZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0KCk7XG4gIH1cblxuICBwdWJsaWMgaXNFeHBpcmVkKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RlYWQgfHwgKGN1cnJlbnRUaW1lIC0gdGhpcy5zdW1tb25UaW1lKSA+PSB0aGlzLmxpZmV0aW1lO1xuICB9XG5cbiAgcHVibGljIGdldERpc3BsYXlOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBVbml0ICgke3RoaXMub3duZXJJZH0pYDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLm93bmVySWQgPSAnJztcbiAgICB0aGlzLnVuaXRJZCA9ICcnO1xuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSA0O1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gNjA7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDIuMDtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLm1heEhlYWx0aCA9IDEwMDA7XG4gICAgdGhpcy5tb3ZlU3BlZWQgPSAyLjI1O1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hDb29sZG93biA9IDAuNTtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLnN1bW1vblRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICB0aGlzLmxpZmV0aW1lID0gMTIwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogU3VtbW9uZWRVbml0IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBTdW1tb25lZFVuaXQodGhpcy5vd25lcklkLCB0aGlzLnVuaXRJZCwgdGhpcy50YXJnZXRQb3NpdGlvbik7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubWF4SGVhbHRoID0gdGhpcy5tYXhIZWFsdGg7XG4gICAgY2xvbmUubW92ZVNwZWVkID0gdGhpcy5tb3ZlU3BlZWQ7XG4gICAgY2xvbmUuY3VycmVudFRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldDtcbiAgICBjbG9uZS5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWU7XG4gICAgY2xvbmUudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICAgIGNsb25lLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZTtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5zdW1tb25UaW1lID0gdGhpcy5zdW1tb25UaW1lO1xuICAgIGNsb25lLmxpZmV0aW1lID0gdGhpcy5saWZldGltZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJTdW1tb25lZFVuaXQiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWN0aXZlIiwiaXNEZWFkIiwiY3VycmVudFRhcmdldCIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsImxhc3RUYXJnZXRTZWFyY2hUaW1lIiwidGFyZ2V0U2VhcmNoQ29vbGRvd24iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJ0YXJnZXRFbnRpdHlJZCIsImNsZWFyVGFyZ2V0IiwiZGllIiwiZGVhdGhUaW1lIiwiaXNFeHBpcmVkIiwic3VtbW9uVGltZSIsImxpZmV0aW1lIiwiZ2V0RGlzcGxheU5hbWUiLCJvd25lcklkIiwicmVzZXQiLCJ1bml0SWQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0RhbWFnZSIsIm1heEhlYWx0aCIsIm1vdmVTcGVlZCIsInRhcmdldFBvc2l0aW9uIiwiRGF0ZSIsIm5vdyIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 10;\n        this.attackDamage = 25;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 13; // attack range \n        this.attackDamage = 150; // 25 damage per arrow\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksZ0JBQWdCO1FBQ3ZDLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUssc0JBQXNCO1FBQy9DLElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMzsgLy8gYXR0YWNrIHJhbmdlIFxuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gMTUwOyAvLyAyNSBkYW1hZ2UgcGVyIGFycm93XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuNTsgLy8gMS41IHNlY29uZHMgYmV0d2VlbiBzaG90c1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMucHJvamVjdGlsZVNwZWVkID0gMjA7IC8vIFNwZWVkIG9mIHRvd2VyIGFycm93c1xuICAgIFxuICAgIC8vIFRhcmdldGluZyBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaFJhbmdlID0gdGhpcy5hdHRhY2tSYW5nZSArIDE7IC8vIFNlYXJjaCBzbGlnaHRseSBiZXlvbmQgYXR0YWNrIHJhbmdlXG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hDb29sZG93biA9IDAuNTsgLy8gU2VhcmNoIGZvciB0YXJnZXRzIGV2ZXJ5IDAuNSBzZWNvbmRzXG4gICAgXG4gICAgLy8gU3RhdGVcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgfVxuICBcbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaXNEZWFkIHx8ICF0aGlzLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEF0dGFja1RpbWUpID49IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gIH1cbiAgXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBjYW5TZWFyY2hGb3JUYXJnZXRzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSkgPj0gdGhpcy50YXJnZXRTZWFyY2hDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VGFyZ2V0KHRhcmdldEVudGl0eUlkOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0RW50aXR5SWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyBjbGVhclRhcmdldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG4gIFxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbGVhclRhcmdldCgpO1xuICB9XG4gIFxuICBwdWJsaWMgZ2V0RGlzcGxheU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFRvd2VyICR7dGhpcy50b3dlckluZGV4ICsgMX0gKE93bmVyOiAke3RoaXMub3duZXJJZH0pYDtcbiAgfVxuICBcbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMub3duZXJJZCA9ICcnO1xuICAgIHRoaXMudG93ZXJJbmRleCA9IDA7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IDEwO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gMjU7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuNTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLnByb2plY3RpbGVTcGVlZCA9IDIwO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hSYW5nZSA9IDk7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hDb29sZG93biA9IDAuNTtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIFxuICBwdWJsaWMgY2xvbmUoKTogVG93ZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFRvd2VyKHRoaXMub3duZXJJZCwgdGhpcy50b3dlckluZGV4KTtcbiAgICBjbG9uZS5hdHRhY2tSYW5nZSA9IHRoaXMuYXR0YWNrUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrRGFtYWdlID0gdGhpcy5hdHRhY2tEYW1hZ2U7XG4gICAgY2xvbmUuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICAgIGNsb25lLmxhc3RBdHRhY2tUaW1lID0gdGhpcy5sYXN0QXR0YWNrVGltZTtcbiAgICBjbG9uZS5wcm9qZWN0aWxlU3BlZWQgPSB0aGlzLnByb2plY3RpbGVTcGVlZDtcbiAgICBjbG9uZS5jdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIGNsb25lLnRhcmdldFNlYXJjaFJhbmdlID0gdGhpcy50YXJnZXRTZWFyY2hSYW5nZTtcbiAgICBjbG9uZS5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWU7XG4gICAgY2xvbmUudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICAgIGNsb25lLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZTtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJUb3dlciIsImNhbkF0dGFjayIsImN1cnJlbnRUaW1lIiwiaXNBY3RpdmUiLCJpc0RlYWQiLCJjdXJyZW50VGFyZ2V0IiwibGFzdEF0dGFja1RpbWUiLCJhdHRhY2tDb29sZG93biIsInBlcmZvcm1BdHRhY2siLCJjYW5TZWFyY2hGb3JUYXJnZXRzIiwibGFzdFRhcmdldFNlYXJjaFRpbWUiLCJ0YXJnZXRTZWFyY2hDb29sZG93biIsInVwZGF0ZVRhcmdldFNlYXJjaCIsInNldFRhcmdldCIsInRhcmdldEVudGl0eUlkIiwiY2xlYXJUYXJnZXQiLCJkaWUiLCJkZWF0aFRpbWUiLCJnZXREaXNwbGF5TmFtZSIsInRvd2VySW5kZXgiLCJvd25lcklkIiwicmVzZXQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0RhbWFnZSIsInByb2plY3RpbGVTcGVlZCIsInRhcmdldFNlYXJjaFJhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT1EsT0FBT0MsTUFBZSxFQUE0QztZQUExQ0MsS0FBQUEsaUVBQWMsSUFBSXRCLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztRQUM3RCxNQUFNdUIsU0FBUyxJQUFJcEIseURBQU9BO1FBQzFCb0IsT0FBT0gsTUFBTSxDQUFDLElBQUksQ0FBQ1YsUUFBUSxFQUFFVyxRQUFRQztRQUNyQyxJQUFJLENBQUNFLFVBQVUsQ0FBQ0MscUJBQXFCLENBQUNGO1FBQ3RDLElBQUksQ0FBQ1QsUUFBUSxDQUFDWSxpQkFBaUIsQ0FBQyxJQUFJLENBQUNGLFVBQVU7UUFDL0MsSUFBSSxDQUFDWixlQUFlO0lBQ3RCO0lBRU9lLGFBQXNCO1FBQzNCLE1BQU1DLFVBQVUsSUFBSTVCLHlEQUFPQSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ25DNEIsUUFBUUMsZUFBZSxDQUFDLElBQUksQ0FBQ0wsVUFBVTtRQUN2QyxPQUFPSTtJQUNUO0lBRU9FLFdBQW9CO1FBQ3pCLE1BQU1DLFFBQVEsSUFBSS9CLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztRQUNoQytCLE1BQU1GLGVBQWUsQ0FBQyxJQUFJLENBQUNMLFVBQVU7UUFDckMsT0FBT087SUFDVDtJQUVPQyxRQUFpQjtRQUN0QixNQUFNVixLQUFLLElBQUl0Qix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDN0JzQixHQUFHTyxlQUFlLENBQUMsSUFBSSxDQUFDTCxVQUFVO1FBQ2xDLE9BQU9GO0lBQ1Q7SUFFT1csbUJBQTRCO1FBQ2pDLElBQUksQ0FBQ0MsaUJBQWlCO1FBQ3RCLE1BQU1DLGdCQUFnQixJQUFJbkMseURBQU9BO1FBQ2pDbUMsY0FBY0MscUJBQXFCLENBQUMsSUFBSSxDQUFDQyxXQUFXO1FBQ3BELE9BQU9GO0lBQ1Q7SUFFT0csbUJBQStCO1FBQ3BDLElBQUksQ0FBQ0osaUJBQWlCO1FBQ3RCLE1BQU1LLGtCQUFrQixJQUFJckMsNERBQVVBO1FBQ3RDcUMsZ0JBQWdCZCxxQkFBcUIsQ0FBQyxJQUFJLENBQUNZLFdBQVc7UUFDdEQsT0FBT0U7SUFDVDtJQUVPQyxnQkFBeUI7UUFDOUIsSUFBSSxDQUFDTixpQkFBaUI7UUFDdEIsTUFBTU8sYUFBYSxJQUFJekMseURBQU9BO1FBQzlCeUMsV0FBV0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDTCxXQUFXO1FBQzlDLE9BQU9JO0lBQ1Q7SUFFT0UsZUFBcUI7UUFDMUIsSUFBSSxDQUFDcEIsTUFBTSxDQUFDcUIsT0FBTyxDQUFDLElBQUksQ0FBQ2xDLFFBQVEsRUFBRSxJQUFJLENBQUNjLFVBQVUsRUFBRSxJQUFJLENBQUNQLEtBQUs7UUFDOUQsSUFBSSxDQUFDNEIsaUJBQWlCLEdBQUc7SUFDM0I7SUFFT1gsb0JBQTBCO1FBQy9CLElBQUksSUFBSSxDQUFDVyxpQkFBaUIsRUFBRTtZQUMxQixJQUFJLENBQUNGLFlBQVk7UUFDbkI7UUFFQSxJQUFJLElBQUksQ0FBQ0csTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUNaLGlCQUFpQjtZQUM3QixJQUFJLENBQUNHLFdBQVcsQ0FBQ1UsZ0JBQWdCLENBQUMsSUFBSSxDQUFDRCxNQUFNLENBQUNULFdBQVcsRUFBRSxJQUFJLENBQUNkLE1BQU07UUFDeEUsT0FBTztZQUNMLElBQUksQ0FBQ2MsV0FBVyxDQUFDVyxJQUFJLENBQUMsSUFBSSxDQUFDekIsTUFBTTtRQUNuQztJQUNGO0lBRU8wQixTQUFTQyxLQUFnQixFQUFRO1FBQ3RDLElBQUlBLE1BQU1KLE1BQU0sRUFBRTtZQUNoQkksTUFBTUosTUFBTSxDQUFDSyxXQUFXLENBQUNEO1FBQzNCO1FBRUFBLE1BQU1KLE1BQU0sR0FBRyxJQUFJO1FBQ25CLElBQUksQ0FBQ00sUUFBUSxDQUFDQyxJQUFJLENBQUNIO0lBQ3JCO0lBRU9DLFlBQVlELEtBQWdCLEVBQVE7UUFDekMsTUFBTUksUUFBUSxJQUFJLENBQUNGLFFBQVEsQ0FBQ0csT0FBTyxDQUFDTDtRQUNwQyxJQUFJSSxVQUFVLENBQUMsR0FBRztZQUNoQixJQUFJLENBQUNGLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDRixPQUFPO1lBQzVCSixNQUFNSixNQUFNLEdBQUc7UUFDakI7SUFDRjtJQUVPVyxtQkFBeUI7UUFDOUIsSUFBSSxJQUFJLENBQUNYLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDSyxXQUFXLENBQUMsSUFBSTtRQUM5QjtJQUNGO0lBRVFwQyxtQkFBeUI7UUFDL0IsSUFBSSxDQUFDUyxVQUFVLENBQUNrQyxZQUFZLENBQUMsSUFBSSxDQUFDNUMsUUFBUTtJQUM1QztJQUVRRixrQkFBd0I7UUFDOUIsSUFBSSxDQUFDaUMsaUJBQWlCLEdBQUc7UUFFekIsaUNBQWlDO1FBQ2pDLEtBQUssTUFBTUssU0FBUyxJQUFJLENBQUNFLFFBQVEsQ0FBRTtZQUNqQ0YsTUFBTXRDLGVBQWU7UUFDdkI7SUFDRjtJQUVPK0MsUUFBYztRQUNuQixrREFBa0Q7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQ2pELFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUNBLFFBQVEsR0FBRyxJQUFJVix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDcEMsT0FBTztZQUNMLElBQUksQ0FBQ1UsUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHO1FBQzFCO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxFQUFFO1lBQ2xCLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUliLHVEQUFLQSxDQUFDLEdBQUcsR0FBRztRQUNsQyxPQUFPO1lBQ0wsSUFBSSxDQUFDYSxRQUFRLENBQUNILEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDMUI7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDTSxLQUFLLEVBQUU7WUFDZixJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJakIseURBQU9BLENBQUMsR0FBRyxHQUFHO1FBQ2pDLE9BQU87WUFDTCxJQUFJLENBQUNpQixLQUFLLENBQUNOLEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDdkI7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDYSxVQUFVLEVBQUU7WUFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSXRCLDREQUFVQTtRQUNsQyxPQUFPO1lBQ0wsSUFBSSxDQUFDc0IsVUFBVSxDQUFDYixHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUc7UUFDL0I7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDWSxNQUFNLEVBQUU7WUFDaEIsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSXBCLHlEQUFPQTtRQUMzQixPQUFPO1lBQ0wsSUFBSSxDQUFDb0IsTUFBTSxDQUFDcUMsUUFBUTtRQUN0QjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUN2QixXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSWxDLHlEQUFPQTtRQUNoQyxPQUFPO1lBQ0wsSUFBSSxDQUFDa0MsV0FBVyxDQUFDdUIsUUFBUTtRQUMzQjtRQUVBLElBQUksQ0FBQ2YsaUJBQWlCLEdBQUc7UUFFekIsbUNBQW1DO1FBQ25DLElBQUksQ0FBQ1ksZ0JBQWdCO1FBQ3JCLE1BQU8sSUFBSSxDQUFDTCxRQUFRLENBQUNTLE1BQU0sR0FBRyxFQUFHO1lBQy9CLElBQUksQ0FBQ1YsV0FBVyxDQUFDLElBQUksQ0FBQ0MsUUFBUSxDQUFDLEVBQUU7UUFDbkM7UUFFQSxJQUFJLENBQUNVLE9BQU8sR0FBRztJQUNqQjtJQUVPQyxRQUFtQjtRQUN4QixNQUFNQSxRQUFRLElBQUkxRCxVQUFVLElBQUksQ0FBQ0ssUUFBUSxFQUFFLElBQUksQ0FBQ0ksUUFBUSxFQUFFLElBQUksQ0FBQ0csS0FBSztRQUNwRThDLE1BQU12QyxVQUFVLENBQUN3QixJQUFJLENBQUMsSUFBSSxDQUFDeEIsVUFBVTtRQUNyQyxPQUFPdUM7SUFDVDtJQTFNQUMsWUFDRXRELFdBQW9CLElBQUlWLHlEQUFPQSxDQUFDLEdBQUcsR0FBRyxFQUFFLEVBQ3hDYyxXQUFrQixJQUFJYix1REFBS0EsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUNwQ2dCLFFBQWlCLElBQUlqQix5REFBT0EsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUNyQztRQUNBLEtBQUs7YUFwQlNpRSxnQkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down AND camera rotation is not disabled\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown && !this.cameraRotationDisabled) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    // Disable/enable camera rotation (used for stun effects)\n    setCameraRotationDisabled(disabled, entityId) {\n        this.cameraRotationDisabled = disabled;\n        this.disabledByEntityId = disabled ? entityId || null : null;\n    }\n    // Check if camera rotation is disabled\n    isCameraRotationDisabled() {\n        return this.cameraRotationDisabled;\n    }\n    // Get the entity ID that disabled camera rotation\n    getCameraRotationDisabledBy() {\n        return this.disabledByEntityId;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        // Stun state for camera rotation disable\n        this.cameraRotationDisabled = false;\n        this.disabledByEntityId = null;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBa0QvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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YUFDUHpDLFlBQVksSUFBSVgsMkRBQVNBLENBQUMsSUFBSXdFLEtBQUtDLEVBQUUsR0FBRyxHQUFHO2FBQzNDaEQsaUJBQWlCLElBQUl4Qix5REFBT0E7YUFDNUIyQixrQkFBa0IsSUFBSTNCLHlEQUFPQTthQUM3QjhCLGdCQUFnQixJQUFJOUIseURBQU9BO2FBQzNCbUIsZUFBZSxJQUFJbkIseURBQU9BO1FBRWxDLGtDQUFrQzthQUMxQnFDLG1CQUFtQjthQUNuQlkscUJBQXFCO1FBRTdCLHlDQUF5QzthQUNqQ1gseUJBQXlCO2FBQ3pCMEMscUJBQW9DO1FBSTFDLElBQUksQ0FBQ2pELE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNHLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDbUQsUUFBUSxHQUFHLEtBQUssMkJBQTJCO1FBRWhELElBQUk1RSxRQUFRO1lBQ1YsSUFBSSxDQUFDQSxNQUFNLEdBQUc7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07Z0JBQUUsR0FBR0EsTUFBTTtZQUFDO1FBQzVDO1FBRUEsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtRQUM1QyxJQUFJLENBQUNGLFNBQVMsQ0FBQytCLEdBQUcsR0FBRzhCLEtBQUtDLEVBQUUsR0FBRyxHQUFHLHNCQUFzQjtRQUN4RCxJQUFJLENBQUM5RCxTQUFTLENBQUM2QixLQUFLLEdBQUc7UUFFdkIsSUFBSSxDQUFDTyxtQkFBbUI7UUFDeEIsSUFBSSxDQUFDTSxvQkFBb0I7SUFDM0I7QUFnTUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ2FtZXJhU3lzdGVtLnRzP2NkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FtZXJhIHN5c3RlbSBmb3IgdGhpcmQtcGVyc29uIGNhbWVyYSBjb250cm9sc1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJ0AvY29yZS9JbnB1dE1hbmFnZXInO1xuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnQC91dGlscy9NYXRoVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbWVyYUNvbmZpZyB7XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtb3VzZVNlbnNpdGl2aXR5OiBudW1iZXI7XG4gIHNtb290aGluZzogbnVtYmVyO1xuICBtaW5Qb2xhckFuZ2xlOiBudW1iZXI7XG4gIG1heFBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4RGlzdGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtXTtcbiAgcHJpdmF0ZSBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIHRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBDYW1lcmEgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGNvbmZpZzogQ2FtZXJhQ29uZmlnID0ge1xuICAgIGRpc3RhbmNlOiAxMCxcbiAgICBoZWlnaHQ6IDUsXG4gICAgbW91c2VTZW5zaXRpdml0eTogMC4wMDUsIC8vIEluY3JlYXNlZCBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgc21vb3RoaW5nOiAwLjEsXG4gICAgbWluUG9sYXJBbmdsZTogTWF0aC5QSSAvIDMuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBnb2luZyBhYm92ZSBob3Jpem9uXG4gICAgbWF4UG9sYXJBbmdsZTogTWF0aC5QSSAvIDIuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBsb29raW5nIHVuZGVybmVhdGggdGhlIG1hcFxuICAgIG1heERpc3RhbmNlOiAxMS41LFxuICB9O1xuXG4gIC8vIENhbWVyYSBzdGF0ZVxuICBwcml2YXRlIHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoMTAsIE1hdGguUEkgLyAzLCAwKTtcbiAgcHJpdmF0ZSB0YXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgY3VycmVudFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50TG9va0F0ID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0YXJnZXRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBcbiAgLy8gTW91c2Ugc3RhdGUgZm9yIGNhbWVyYSByb3RhdGlvblxuICBwcml2YXRlIGlzUmlnaHRNb3VzZURvd24gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3aGVlbExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcblxuICAvLyBTdHVuIHN0YXRlIGZvciBjYW1lcmEgcm90YXRpb24gZGlzYWJsZVxuICBwcml2YXRlIGNhbWVyYVJvdGF0aW9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkaXNhYmxlZEJ5RW50aXR5SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmEsIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyLCBjb25maWc/OiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuICAgIHRoaXMucHJpb3JpdHkgPSA5MDA7IC8vIFJ1biBsYXRlLCBhZnRlciBtb3ZlbWVudFxuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoLlBJIC8gMzsgLy8gU3RhcnQgYXQgNjAgZGVncmVlc1xuICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhID0gMDtcblxuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRUYXJnZXQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICB0aGlzLnRhcmdldCA9IGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb25maWcoY29uZmlnOiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IHRoaXMuY29uZmlnLmRpc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBpbnB1dCBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gICAgdGhpcy5oYW5kbGVNb3VzZUlucHV0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uXG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGFyZ2V0TG9va0F0LnkgKz0gdGhpcy5jb25maWcuaGVpZ2h0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnNldEZyb21TcGhlcmljYWwodGhpcy5zcGhlcmljYWwpO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uYWRkKHRoaXMudGFyZ2V0TG9va0F0KTtcblxuICAgIC8vIFNtb290aCBjYW1lcmEgbW92ZW1lbnRcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sZXJwKHRoaXMudGFyZ2V0UG9zaXRpb24sIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LmxlcnAodGhpcy50YXJnZXRMb29rQXQsIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG5cbiAgICAvLyBVcGRhdGUgY2FtZXJhXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1vdXNlSW5wdXQoKTogdm9pZCB7XG4gICAgY29uc3QgbW91c2VEZWx0YSA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldE1vdXNlRGVsdGEoKTtcblxuICAgIC8vIE9ubHkgcm90YXRlIGNhbWVyYSB3aGVuIHJpZ2h0IG1vdXNlIGJ1dHRvbiBpcyBoZWxkIGRvd24gQU5EIGNhbWVyYSByb3RhdGlvbiBpcyBub3QgZGlzYWJsZWRcbiAgICBpZiAoKG1vdXNlRGVsdGEueCAhPT0gMCB8fCBtb3VzZURlbHRhLnkgIT09IDApICYmIHRoaXMuaXNSaWdodE1vdXNlRG93biAmJiAhdGhpcy5jYW1lcmFSb3RhdGlvbkRpc2FibGVkKSB7XG4gICAgICAvLyBVcGRhdGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSAtPSBtb3VzZURlbHRhLnggKiB0aGlzLmNvbmZpZy5tb3VzZVNlbnNpdGl2aXR5O1xuICAgICAgdGhpcy5zcGhlcmljYWwucGhpIC09IG1vdXNlRGVsdGEueSAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7IC8vIEludmVydGVkIFkgZm9yIG5hdHVyYWwgY2FtZXJhIGZlZWxcblxuICAgICAgLy8gQ2xhbXAgcGhpIHRvIHByZXZlbnQgY2FtZXJhIGZsaXBwaW5nXG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSxcbiAgICAgICAgdGhpcy5jb25maWcubWluUG9sYXJBbmdsZSxcbiAgICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICAgKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZXRhXG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZSh0aGlzLnNwaGVyaWNhbC50aGV0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIE1vdXNlIGJ1dHRvbiBldmVudHMgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZURvd24nLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZVVwJywgKHsgYnV0dG9uIH0pID0+IHtcbiAgICAgIGlmIChidXR0b24gPT09IDIpIHsgLy8gUmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICAgIHRoaXMuaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW91c2Ugd2hlZWwgZm9yIHpvb20gLSBvbmx5IGFkZCBsaXN0ZW5lciBvbmNlXG4gICAgaWYgKCF0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCkge1xuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ3doZWVsJywgKHsgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzICs9IGRlbHRhWSAqIDAuMDE7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcCh0aGlzLnNwaGVyaWNhbC5yYWRpdXMsIDIsIHRoaXMuY29uZmlnLm1heERpc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53aGVlbExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJbml0aWFsUG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LnNldCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQsIDApO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICAgIFxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBnZXRDYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FtZXJhUmlnaHQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYW1lcmFEaXJlY3Rpb24oKTtcbiAgICBjb25zdCByaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFGb3J3YXJkKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXRDYW1lcmFSaWdodCgpO1xuICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCByaWdodCk7XG4gICAgZm9yd2FyZC5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXN0YW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC5yYWRpdXM7XG4gIH1cblxuICBwdWJsaWMgc2V0RGlzdGFuY2UoZGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcChkaXN0YW5jZSwgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIGdldEhvcml6b250YWxBbmdsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC50aGV0YTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRWZXJ0aWNhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnBoaTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBbmdsZXMoaG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSBNYXRoVXRpbHMubm9ybWFsaXplQW5nbGUoaG9yaXpvbnRhbCk7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aFV0aWxzLmNsYW1wKFxuICAgICAgdmVydGljYWwsXG4gICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRDYW1lcmEoKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSAwO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzbmFwVG9UYXJnZXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgcG9zaXRpb24gaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnggPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnkgPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5hZGQodGhpcy50YXJnZXRMb29rQXQpO1xuXG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uY29weSh0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuY29weSh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5jdXJyZW50TG9va0F0KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogUGVyc3BlY3RpdmVDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxuXG4gIC8vIERpc2FibGUvZW5hYmxlIGNhbWVyYSByb3RhdGlvbiAodXNlZCBmb3Igc3R1biBlZmZlY3RzKVxuICBwdWJsaWMgc2V0Q2FtZXJhUm90YXRpb25EaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbiwgZW50aXR5SWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNhbWVyYVJvdGF0aW9uRGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB0aGlzLmRpc2FibGVkQnlFbnRpdHlJZCA9IGRpc2FibGVkID8gKGVudGl0eUlkIHx8IG51bGwpIDogbnVsbDtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGNhbWVyYSByb3RhdGlvbiBpcyBkaXNhYmxlZFxuICBwdWJsaWMgaXNDYW1lcmFSb3RhdGlvbkRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYVJvdGF0aW9uRGlzYWJsZWQ7XG4gIH1cblxuICAvLyBHZXQgdGhlIGVudGl0eSBJRCB0aGF0IGRpc2FibGVkIGNhbWVyYSByb3RhdGlvblxuICBwdWJsaWMgZ2V0Q2FtZXJhUm90YXRpb25EaXNhYmxlZEJ5KCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkQnlFbnRpdHlJZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlNwaGVyaWNhbCIsIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNYXRoVXRpbHMiLCJDYW1lcmFTeXN0ZW0iLCJzZXRUYXJnZXQiLCJlbnRpdHkiLCJ0YXJnZXQiLCJzZXRDb25maWciLCJjb25maWciLCJzcGhlcmljYWwiLCJyYWRpdXMiLCJkaXN0YW5jZSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidGFyZ2V0VHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwiaGFuZGxlTW91c2VJbnB1dCIsInRhcmdldExvb2tBdCIsImNvcHkiLCJwb3NpdGlvbiIsInkiLCJoZWlnaHQiLCJ0YXJnZXRQb3NpdGlvbiIsInNldEZyb21TcGhlcmljYWwiLCJhZGQiLCJjdXJyZW50UG9zaXRpb24iLCJsZXJwIiwic21vb3RoaW5nIiwiY3VycmVudExvb2tBdCIsImNhbWVyYSIsImxvb2tBdCIsIm1vdXNlRGVsdGEiLCJpbnB1dE1hbmFnZXIiLCJnZXRNb3VzZURlbHRhIiwieCIsImlzUmlnaHRNb3VzZURvd24iLCJjYW1lcmFSb3RhdGlvbkRpc2FibGVkIiwidGhldGEiLCJtb3VzZVNlbnNpdGl2aXR5IiwicGhpIiwiY2xhbXAiLCJtaW5Qb2xhckFuZ2xlIiwibWF4UG9sYXJBbmdsZSIsIm5vcm1hbGl6ZUFuZ2xlIiwic2V0dXBFdmVudExpc3RlbmVycyIsIm9uIiwiYnV0dG9uIiwid2hlZWxMaXN0ZW5lckFkZGVkIiwiZGVsdGFZIiwibWF4RGlzdGFuY2UiLCJzZXR1cEluaXRpYWxQb3NpdGlvbiIsInNldCIsImdldENhbWVyYURpcmVjdGlvbiIsImRpcmVjdGlvbiIsImdldFdvcmxkRGlyZWN0aW9uIiwiZ2V0Q2FtZXJhUmlnaHQiLCJyaWdodCIsImNyb3NzVmVjdG9ycyIsIm5vcm1hbGl6ZSIsImdldENhbWVyYUZvcndhcmQiLCJmb3J3YXJkIiwiZ2V0RGlzdGFuY2UiLCJzZXREaXN0YW5jZSIsImdldEhvcml6b250YWxBbmdsZSIsImdldFZlcnRpY2FsQW5nbGUiLCJzZXRBbmdsZXMiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJyZXNldENhbWVyYSIsIk1hdGgiLCJQSSIsInNuYXBUb1RhcmdldCIsInVuZGVmaW5lZCIsInoiLCJnZXRDYW1lcmEiLCJzZXRDYW1lcmFSb3RhdGlvbkRpc2FibGVkIiwiZGlzYWJsZWQiLCJlbnRpdHlJZCIsImRpc2FibGVkQnlFbnRpdHlJZCIsImlzQ2FtZXJhUm90YXRpb25EaXNhYmxlZCIsImdldENhbWVyYVJvdGF0aW9uRGlzYWJsZWRCeSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {}\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {}\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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RixNQUFNLENBQUNEO1FBQy9CO0lBQ0Y7SUFFT0UsWUFBa0I7UUFDdkIsSUFBSSxDQUFDckgsV0FBVyxDQUFDc0gsS0FBSztRQUN0QixJQUFJLENBQUNyRixnQkFBZ0IsQ0FBQ3FGLEtBQUs7UUFDM0IsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxNQUFNLEdBQUc7SUFDL0I7SUF2WkFpSCxZQUFZQyxXQUFtQixDQUFDLENBQUU7UUFDaEMsS0FBSzthQVhTQyxxQkFBcUI7WUFBQzdJLGdFQUFTQTtZQUFFRSw4REFBUUE7U0FBQzthQUVsRHVCLGlCQUFrQyxFQUFFO2FBQ3BDNEIsbUJBQW1CLElBQUlGLE1BQThCLDJCQUEyQjs7UUFFeEYsdUJBQXVCO2FBQ2YyRixpQkFBaUI7YUFDakJuSCxrQkFBa0I7YUFDbEJDLG1CQUFtQjtRQUl6QixJQUFJLENBQUNtSCxRQUFRLEdBQUcsSUFBSSxzQ0FBc0M7UUFDMUQsSUFBSSxDQUFDM0gsV0FBVyxHQUFHLElBQUloQiwyREFBV0EsQ0FBQ3dJO0lBQ3JDO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cz9jOWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbGxpc2lvbiBzeXN0ZW0gZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxuaW1wb3J0IHsgVmVjdG9yMywgQm94MyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBTcGF0aWFsSGFzaCB9IGZyb20gJ0AvdXRpbHMvU3BhdGlhbEhhc2gnO1xuXG5pbnRlcmZhY2UgQ29sbGlzaW9uUGFpciB7XG4gIGVudGl0eUE6IEVudGl0eTtcbiAgZW50aXR5QjogRW50aXR5O1xuICBjb2xsaWRlckE6IENvbGxpZGVyO1xuICBjb2xsaWRlckI6IENvbGxpZGVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBDb2xsaWRlcl07XG4gIHByaXZhdGUgc3BhdGlhbEhhc2g6IFNwYXRpYWxIYXNoO1xuICBwcml2YXRlIGNvbGxpc2lvblBhaXJzOiBDb2xsaXNpb25QYWlyW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7IC8vIFRyYWNrIG9uZ29pbmcgY29sbGlzaW9uc1xuICBcbiAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgY29sbGlzaW9uQ2hlY2tzID0gMDtcbiAgcHJpdmF0ZSBhY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICBjb25zdHJ1Y3RvcihjZWxsU2l6ZTogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIG1vdmVtZW50IGJ1dCBhZnRlciBpbnB1dFxuICAgIHRoaXMuc3BhdGlhbEhhc2ggPSBuZXcgU3BhdGlhbEhhc2goY2VsbFNpemUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB0cmlnZ2VyIGRldGVjdGlvbiBhbmQgYnJvYWQgcGhhc2VcbiAgICB0aGlzLnVwZGF0ZVNwYXRpYWxIYXNoKGVudGl0aWVzKTtcbiAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoZW50aXRpZXMpO1xuICAgIHRoaXMucHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcygpO1xuICAgIC8vIEFsc28gcmVzb2x2ZSBjb2xsaXNpb25zIGluIHVwZGF0ZSgpIHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzIGNvbGxpc2lvbiByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXM6IEVudGl0eVtdKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaCB3aXRoIGN1cnJlbnQgZW50aXR5IHBvc2l0aW9uc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWNvbGxpZGVyLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xsaWRlciBib3VuZHNcbiAgICAgIGNvbGxpZGVyLnVwZGF0ZUJvdW5kcyh0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaFxuICAgICAgdGhpcy5zcGF0aWFsSGFzaC51cGRhdGUoZW50aXR5LCBjb2xsaWRlci5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb2xsaXNpb25DaGVja3MgPSAwO1xuICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucyA9IDA7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFF1ZXJ5IHNwYXRpYWwgaGFzaCBmb3IgcG90ZW50aWFsIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGNvbGxpZGVyLmJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJFbnRpdHkgPSBjYW5kaWRhdGUuZW50aXR5O1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IG90aGVyRW50aXR5LmlkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIga2V5IChzbWFsbGVyIElEIGZpcnN0KVxuICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW50aXR5LmlkIDwgb3RoZXJFbnRpdHkuaWQgPyBcbiAgICAgICAgICBgJHtlbnRpdHkuaWR9LSR7b3RoZXJFbnRpdHkuaWR9YCA6IFxuICAgICAgICAgIGAke290aGVyRW50aXR5LmlkfS0ke2VudGl0eS5pZH1gO1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBwYWlyXG4gICAgICAgIGlmIChwcm9jZXNzZWRQYWlycy5oYXMocGFpcktleSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRQYWlycy5hZGQocGFpcktleSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJUcmFuc2Zvcm0gPSBvdGhlckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgICAgaWYgKCFvdGhlclRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhb3RoZXJDb2xsaWRlcj8uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sbGlkZXJzIGNhbiBjb2xsaWRlXG4gICAgICAgIGlmICghY29sbGlkZXIuY2FuQ29sbGlkZVdpdGgob3RoZXJDb2xsaWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2hlY2tzKys7XG5cbiAgICAgICAgLy8gUHJlY2lzZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIGlmIChjb2xsaWRlci5pbnRlcnNlY3RzKG90aGVyQ29sbGlkZXIsIHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCksIG90aGVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdHVhbENvbGxpc2lvbnMrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgICAgIGlmICgoY29sbGlkZXIubGF5ZXIgPT09IDIgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgICAgICAoY29sbGlkZXIubGF5ZXIgPT09IDE2ICYmIG90aGVyQ29sbGlkZXIubGF5ZXIgPT09IDIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VwYXJhdGlvbiA9IHBvc0EuY2xvbmUoKS5zdWIocG9zQik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzZXBhcmF0aW9uLmxlbmd0aCgpO1xuXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAvLyBPYmplY3RzIGFyZSBhdCBleGFjdCBzYW1lIHBvc2l0aW9uLCBzZXBhcmF0ZSBhbG9uZyBZIGF4aXNcbiAgICAgIHNlcGFyYXRpb24uc2V0KDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzZXBhcmF0aW9uIGRpc3RhbmNlXG4gICAgbGV0IHJlcXVpcmVkU2VwYXJhdGlvbiA9IDA7XG4gICAgXG4gICAgaWYgKHBhaXIuY29sbGlkZXJBLnR5cGUgPT09ICdzcGhlcmUnICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnY3lsaW5kZXInKSB7XG4gICAgICAvLyBQbGF5ZXIgKHNwaGVyZSkgdnMgUGlsbGFyIChjeWxpbmRlcikgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnY3lsaW5kZXInICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICAvLyBQaWxsYXIgKGN5bGluZGVyKSB2cyBQbGF5ZXIgKHNwaGVyZSkgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdGhlciBzaGFwZXMsIHVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uXG4gICAgICBjb25zdCByYWRpdXNBID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQSk7XG4gICAgICBjb25zdCByYWRpdXNCID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQik7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwID0gcmVxdWlyZWRTZXBhcmF0aW9uIC0gZGlzdGFuY2U7XG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgaWYgKChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMiAmJiBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgIChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMTYgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDIpKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBzdGF0aWMgb2JqZWN0cyAobGlrZSBwaWxsYXJzKSwgYXBwbHkgc3Ryb25nZXIgc2VwYXJhdGlvbiB0byBwcmV2ZW50IHBlbmV0cmF0aW9uXG4gICAgICBsZXQgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjA7XG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgfHwgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjE7IC8vIDEwJSBleHRyYSBzZXBhcmF0aW9uIGZvciBzdGF0aWMgb2JqZWN0c1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXBhcmF0ZSBvYmplY3RzIC0gdXNlIGVuaGFuY2VkIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gc2VwYXJhdGlvbi5tdWx0aXBseVNjYWxhcihvdmVybGFwICogc2VwYXJhdGlvbk11bHRpcGxpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdGllcyBoYXZlIE1vdmVtZW50IGNvbXBvbmVudHMgZm9yIGludGVsbGlnZW50IHNlcGFyYXRpb24gZGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCBtb3ZlbWVudEEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGNvbnN0IG1vdmVtZW50QiA9IHBhaXIuZW50aXR5Qi5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgc2VwYXJhdGlvbiBkaXN0cmlidXRpb24gYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50cyBhbmQgc3RhdGljIHN0YXR1c1xuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JBID0gMC41OyAvLyBEZWZhdWx0OiBzcGxpdCBzZXBhcmF0aW9uIGVxdWFsbHlcbiAgICAgIGxldCBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgIFxuICAgICAgaWYgKHBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBBIGlzIHN0YXRpYywgQiBtb3ZlcyAtIEIgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCIGlzIHN0YXRpYywgQSBtb3ZlcyAtIEEgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAxO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiAhcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gQm90aCBub24tc3RhdGljIC0gY2hlY2sgZm9yIFBWUCBzY2VuYXJpbyAoYm90aCBwbGF5ZXJzKVxuICAgICAgICBjb25zdCBpc1BsYXllckEgPSBwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSO1xuICAgICAgICBjb25zdCBpc1BsYXllckIgPSBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHx8IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BsYXllckEgJiYgaXNQbGF5ZXJCKSB7XG4gICAgICAgICAgLy8gUFZQIGNvbGxpc2lvbjogY2hlY2sgY2FuTW92ZSBwcm9wZXJ0eSBmb3IgZmFpciBjb2xsaXNpb24gcmVzb2x1dGlvblxuICAgICAgICAgIGNvbnN0IGNhbk1vdmVBID0gbW92ZW1lbnRBID8gbW92ZW1lbnRBLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjYW5Nb3ZlQiA9IG1vdmVtZW50QiA/IG1vdmVtZW50Qi5jYW5Nb3ZlIDogZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBsYXllcnMgY2FuIG1vdmUgLSBlcXVhbCBkaXN0cmlidXRpb24gZm9yIGZhaXIgZ2FtZXBsYXlcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC41O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5Nb3ZlQSAmJiAhY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQSBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQiBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDEuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEIgY2FuIG1vdmUgKGxvY2FsIHBsYXllciksIEEgaXMgcG9zaXRpb24tc3luY2VkIChyZW1vdGUgcGxheWVyKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDEuMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVpdGhlciBjYW4gbW92ZSAtIG5vIHNlcGFyYXRpb24gKHNob3VsZG4ndCBoYXBwZW4gaW4gUFZQKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLVBWUCBjb2xsaXNpb24gLSBkaXN0cmlidXRlIGJhc2VkIG9uIE1vdmVtZW50IGNvbXBvbmVudHNcbiAgICAgICAgICBpZiAobW92ZW1lbnRBICYmICFtb3ZlbWVudEIpIHtcbiAgICAgICAgICAgIC8vIEEgaGFzIE1vdmVtZW50LCBCIGRvZXNuJ3RcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC44O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjI7XG4gICAgICAgICAgfSBlbHNlIGlmICghbW92ZW1lbnRBICYmIG1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQiBoYXMgTW92ZW1lbnQsIEEgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjI7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYm90aCBoYXZlIE1vdmVtZW50IG9yIG5laXRoZXIgaGFzIE1vdmVtZW50LCB1c2UgZXF1YWwgZGlzdHJpYnV0aW9uICgwLjUsIDAuNSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzZXBhcmF0aW9uIHdpdGggY2FsY3VsYXRlZCBmYWN0b3JzXG4gICAgICBpZiAoc2VwYXJhdGlvbkZhY3RvckEgPiAwICYmIHNlcGFyYXRpb25WZWN0b3IgJiYgc2VwYXJhdGlvblZlY3Rvci5jbG9uZSkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZXBhcmF0aW9uRmFjdG9yQSk7XG4gICAgICAgIHRyYW5zZm9ybUEudHJhbnNsYXRlKHNlcGFyYXRpb25BLngsIHNlcGFyYXRpb25BLnksIHNlcGFyYXRpb25BLnopO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBzdG9wIG1vdmVtZW50IHZlbG9jaXR5IGZvciBwbGF5ZXIgd2hlbiBoaXR0aW5nIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChtb3ZlbWVudEEgJiYgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMgJiYgbW92ZW1lbnRBLnZlbG9jaXR5ICYmIG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSAmJiBzZXBhcmF0aW9uICYmIHNlcGFyYXRpb24uY2xvbmUpIHtcbiAgICAgICAgICAvLyBQcm9qZWN0IHZlbG9jaXR5IHRvIHJlbW92ZSBjb21wb25lbnQgdG93YXJkcyB0aGUgc3RhdGljIG9iamVjdFxuICAgICAgICAgIGNvbnN0IHZlbG9jaXR5VG93YXJkc1N0YXRpYyA9IG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSgpLnByb2plY3RPblZlY3RvcihzZXBhcmF0aW9uLmNsb25lKCkubmVnYXRlKCkpO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEEudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQiA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbkIgPSBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLXNlcGFyYXRpb25GYWN0b3JCKTtcbiAgICAgICAgdHJhbnNmb3JtQi50cmFuc2xhdGUoc2VwYXJhdGlvbkIueCwgc2VwYXJhdGlvbkIueSwgc2VwYXJhdGlvbkIueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QiAmJiBwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYykge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRCLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24pO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEIudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcHByb3hpbWF0ZVJhZGl1cyhjb2xsaWRlcjogQ29sbGlkZXIpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY29sbGlkZXIudHlwZSkge1xuICAgICAgY2FzZSAnc3BoZXJlJzpcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyLnJhZGl1cztcbiAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5zaXplLngsIGNvbGxpZGVyLnNpemUueSwgY29sbGlkZXIuc2l6ZS56KSAqIDAuNTtcbiAgICAgIGNhc2UgJ2NhcHN1bGUnOlxuICAgICAgY2FzZSAnY3lsaW5kZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sbGlkZXIucmFkaXVzLCBjb2xsaWRlci5oZWlnaHQgKiAwLjUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIHN5c3RlbXNcbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzKGJvdW5kczogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUmFkaXVzKGNlbnRlcjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlSYWRpdXMoY2VudGVyLCByYWRpdXMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUG9pbnQocG9pbnQ6IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlQb2ludChwb2ludCk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sbGlkZXJzSW5MYXllcihsYXllcjogQ29sbGlzaW9uTGF5ZXIsIGJvdW5kcz86IEJveDMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGJvdW5kcyA/IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoYm91bmRzKSA6IEFycmF5LmZyb20odGhpcy5zcGF0aWFsSGFzaFsnZW50aXR5Q2VsbHMnXS5rZXlzKCkpLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShuZXcgQm94MygpLnNldEZyb21DZW50ZXJBbmRTaXplKG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKDEwMDAsIDEwMDAsIDEwMDApKSk7XG4gICAgICByZXR1cm4gZW50cmllcy5maW5kKGUgPT4gZS5lbnRpdHkuaWQgPT09IGlkKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgYW55W107XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlc1xuICAgICAgLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50cnkuZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlciAmJiBjb2xsaWRlci5sYXllciA9PT0gbGF5ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7XG4gICAgY29sbGlzaW9uQ2hlY2tzOiBudW1iZXI7XG4gICAgYWN0dWFsQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIGFjdGl2ZUNvbGxpc2lvbnM6IG51bWJlcjtcbiAgICBzcGF0aWFsSGFzaFN0YXRzOiBhbnk7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xsaXNpb25DaGVja3M6IHRoaXMuY29sbGlzaW9uQ2hlY2tzLFxuICAgICAgYWN0dWFsQ29sbGlzaW9uczogdGhpcy5hY3R1YWxDb2xsaXNpb25zLFxuICAgICAgYWN0aXZlQ29sbGlzaW9uczogdGhpcy5hY3RpdmVDb2xsaXNpb25zLnNpemUsXG4gICAgICBzcGF0aWFsSGFzaFN0YXRzOiB0aGlzLnNwYXRpYWxIYXNoLmdldFN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHNwYXRpYWwgaGFzaCB3aGVuIGVudGl0eSBpcyByZW1vdmVkXG4gICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuZm9yRWFjaCgocGFpciwga2V5KSA9PiB7XG4gICAgICBpZiAocGFpci5lbnRpdHlBLmlkID09PSBlbnRpdHkuaWQgfHwgcGFpci5lbnRpdHlCLmlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuc3BhdGlhbEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJTcGF0aWFsSGFzaCIsIkNvbGxpc2lvblN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidXBkYXRlU3BhdGlhbEhhc2giLCJkZXRlY3RDb2xsaXNpb25zIiwicHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcyIsInJlc29sdmVDb2xsaXNpb25zIiwiZml4ZWRVcGRhdGUiLCJmaXhlZERlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsImNvbGxpZGVyIiwiZW5hYmxlZCIsInNwYXRpYWxIYXNoIiwicmVtb3ZlIiwidXBkYXRlQm91bmRzIiwiZ2V0V29ybGRQb3NpdGlvbiIsImJvdW5kcyIsImNvbGxpc2lvblBhaXJzIiwibGVuZ3RoIiwiY29sbGlzaW9uQ2hlY2tzIiwiYWN0dWFsQ29sbGlzaW9ucyIsInByb2Nlc3NlZFBhaXJzIiwiU2V0IiwiY2FuZGlkYXRlcyIsInF1ZXJ5IiwiY2FuZGlkYXRlIiwib3RoZXJFbnRpdHkiLCJpZCIsInBhaXJLZXkiLCJoYXMiLCJhZGQiLCJvdGhlclRyYW5zZm9ybSIsIm90aGVyQ29sbGlkZXIiLCJjYW5Db2xsaWRlV2l0aCIsImludGVyc2VjdHMiLCJsYXllciIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsInNlcGFyYXRpb24iLCJzdWIiLCJkaXN0YW5jZSIsIm5vcm1hbGl6ZSIsInJlcXVpcmVkU2VwYXJhdGlvbiIsInR5cGUiLCJyYWRpdXMiLCJyYWRpdXNBIiwiZ2V0QXBwcm94aW1hdGVSYWRpdXMiLCJyYWRpdXNCIiwib3ZlcmxhcCIsInNlcGFyYXRpb25NdWx0aXBsaWVyIiwiaXNTdGF0aWMiLCJzZXBhcmF0aW9uVmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJtb3ZlbWVudEEiLCJtb3ZlbWVudEIiLCJzZXBhcmF0aW9uRmFjdG9yQSIsInNlcGFyYXRpb25GYWN0b3JCIiwiaXNQbGF5ZXJBIiwiUExBWUVSIiwiaXNQbGF5ZXJCIiwiRU5FTVkiLCJjYW5Nb3ZlQSIsImNhbk1vdmUiLCJjYW5Nb3ZlQiIsInNlcGFyYXRpb25BIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVRvd2FyZHNTdGF0aWMiLCJwcm9qZWN0T25WZWN0b3IiLCJuZWdhdGUiLCJzZXBhcmF0aW9uQiIsIk1hdGgiLCJtYXgiLCJzaXplIiwiaGVpZ2h0IiwicXVlcnlDb2xsaWRlcnMiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJxdWVyeUNvbGxpZGVyc1JhZGl1cyIsImNlbnRlciIsInF1ZXJ5UmFkaXVzIiwicXVlcnlDb2xsaWRlcnNQb2ludCIsInBvaW50IiwicXVlcnlQb2ludCIsImdldENvbGxpZGVyc0luTGF5ZXIiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJmaW5kIiwiZSIsImZpbHRlciIsIkJvb2xlYW4iLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwic3BhdGlhbEhhc2hTdGF0cyIsImdldFN0YXRzIiwib25FbnRpdHlSZW1vdmVkIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZGVsZXRlIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNlbGxTaXplIiwicmVxdWlyZWRDb21wb25lbnRzIiwibGFzdFVwZGF0ZVRpbWUiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Throttled logging to reduce spam\n    shouldLogDamage() {\n        const now = Date.now();\n        if (now - this.lastDamageLogTime > this.damageLogThrottle) {\n            this.lastDamageLogTime = now;\n            return true;\n        }\n        return false;\n    }\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    setSummonedUnitDamageCallback(callback) {\n        this.onSummonedUnitDamageCallback = callback;\n    }\n    // Apply summoned unit damage received from server\n    applySummonedUnitDamage(unitId, damage, sourcePlayerId) {\n        const unitEntity = this.world.getEntity(parseInt(unitId));\n        if (!unitEntity) {\n            console.warn(\" Cannot apply summoned unit damage: unit \".concat(unitId, \" not found\"));\n            return;\n        }\n        const health = unitEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        const summonedUnitComponent = unitEntity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_9__.SummonedUnit);\n        if (!health || !summonedUnitComponent) {\n            console.warn(\" Cannot apply summoned unit damage: unit \".concat(unitId, \" missing components\"));\n            return;\n        }\n        const currentTime = Date.now() / 1000;\n        // Apply damage locally (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(damage, currentTime, unitEntity);\n        if (damageDealt) {\n            console.log(\"\\uD83E\\uDD16 Applied \".concat(damage, \" damage to summoned unit \").concat(unitId, \" from player \").concat(sourcePlayerId, \" (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(unitEntity, undefined, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(unitEntity, damage, undefined, \"melee\", false);\n        }\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update debuff statuses for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n                enemy.updateCorruptedStatus(currentTime);\n                // Synchronize enemy debuffs with movement component\n                this.synchronizeEnemyDebuffsWithMovement(entity, enemy);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const summonedUnitComponent = target.getComponent(SummonedUnit);\n            const summonedUnit = summonedUnitComponent ? summonedUnitComponent : null;\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : summonedUnit ? \"SummonedUnit(\".concat(summonedUnit.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            // console.log(` Routing ${actualDamage} damage to enemy ${target.id} through multiplayer server`);\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a summoned unit - route through server for synchronization\n        const summonedUnitComponent = target.getComponent(SummonedUnit);\n        if (summonedUnitComponent && this.onSummonedUnitDamageCallback) {\n            var _target_userData, _target_userData1;\n            // Cast to proper type\n            const summonedUnit = summonedUnitComponent;\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Get source player ID for team validation\n            // For projectiles, check if the source has a player ID stored\n            let sourcePlayerId = \"unknown\";\n            if (source) {\n                var _source_userData;\n                // Check if source is a projectile with stored player info\n                const projectileComponent = source.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_10__.Projectile);\n                if (projectileComponent && projectileComponent.sourcePlayerId) {\n                    sourcePlayerId = projectileComponent.sourcePlayerId;\n                } else if ((_source_userData = source.userData) === null || _source_userData === void 0 ? void 0 : _source_userData.playerId) {\n                    sourcePlayerId = source.userData.playerId;\n                }\n            }\n            // Get the server unit ID from userData (set during ECS sync)\n            const serverUnitId = ((_target_userData = target.userData) === null || _target_userData === void 0 ? void 0 : _target_userData.serverUnitId) || summonedUnit.unitId;\n            const serverUnitOwnerId = ((_target_userData1 = target.userData) === null || _target_userData1 === void 0 ? void 0 : _target_userData1.serverUnitOwnerId) || summonedUnit.ownerId;\n            // Route summoned unit damage through multiplayer server instead of applying locally\n            console.log(\"\\uD83C\\uDF10 Routing \".concat(actualDamage, \" damage to summoned unit \").concat(serverUnitId, \" (owned by \").concat(serverUnitOwnerId, \") from source player \").concat(sourcePlayerId, \" through multiplayer server\"));\n            // Debug: Log the source information\n            if (source) {\n                var _source_userData1;\n                const projectileComponent = source.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_10__.Projectile);\n                console.log(\"\\uD83D\\uDD0D Source entity \".concat(source.id, \" - projectile sourcePlayerId: \").concat(projectileComponent === null || projectileComponent === void 0 ? void 0 : projectileComponent.sourcePlayerId, \", userData playerId: \").concat((_source_userData1 = source.userData) === null || _source_userData1 === void 0 ? void 0 : _source_userData1.playerId));\n            }\n            // Debug: Log the team validation check\n            console.log('\\uD83D\\uDEE1 Team validation: sourcePlayerId=\"'.concat(sourcePlayerId, '\" vs unitOwnerId=\"').concat(serverUnitOwnerId, '\" - ').concat(sourcePlayerId === serverUnitOwnerId ? \"BLOCKED (same team)\" : \"ALLOWED (different teams)\"));\n            // Block damage to own units\n            if (sourcePlayerId === serverUnitOwnerId) {\n                console.log(\"\\uD83D\\uDEAB Blocked damage to own summoned unit\");\n                return;\n            }\n            // Additional check: Don't send damage for units that are already dead locally\n            if (health.isDead || health.currentHealth <= 0) {\n                console.log(\"\\uD83D\\uDEAB Blocked damage to already dead summoned unit \".concat(serverUnitId));\n                return;\n            }\n            // Call the server damage callback with server unit ID\n            this.onSummonedUnitDamageCallback(serverUnitId, serverUnitOwnerId, actualDamage, sourcePlayerId, damageType);\n            // Still create local damage numbers for immediate visual feedback\n            // Check if source is a summoned unit - if so, skip damage numbers to reduce visual clutter\n            const sourceSummonedUnit = source ? source.getComponent(SummonedUnit) : null;\n            const shouldShowDamageNumbers = !sourceSummonedUnit; // Show numbers unless source is a summoned unit\n            if (shouldShowDamageNumbers) {\n                const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                if (transform) {\n                    const position = transform.getWorldPosition();\n                    // Only create damage number if position is valid\n                    if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                        // Offset slightly above the target\n                        position.y += 2;\n                        this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType || \"melee\");\n                    }\n                }\n            }\n            return; // Don't apply damage locally for summoned units\n        }\n        // Fallback: If no callback is set, apply damage locally (for single-player or testing)\n        if (summonedUnitComponent && !this.onSummonedUnitDamageCallback) {\n            // Cast to proper type\n            const summonedUnit = summonedUnitComponent;\n            // Get source player ID for team validation (same logic as above)\n            let sourcePlayerId = \"unknown\";\n            if (source) {\n                var _source_userData2;\n                const projectileComponent = source.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_10__.Projectile);\n                if (projectileComponent && projectileComponent.sourcePlayerId) {\n                    sourcePlayerId = projectileComponent.sourcePlayerId;\n                } else if ((_source_userData2 = source.userData) === null || _source_userData2 === void 0 ? void 0 : _source_userData2.playerId) {\n                    sourcePlayerId = source.userData.playerId;\n                }\n            }\n            // TEMPORARY: Block all damage to own units for testing (even in fallback)\n            if (sourcePlayerId === summonedUnit.ownerId) {\n                console.warn(\"\\uD83D\\uDEAB FALLBACK BLOCKED: Player \".concat(sourcePlayerId, \" tried to damage their own summoned unit \").concat(target.id));\n                return; // Block the damage\n            }\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Apply damage locally (pass entity so Health can use Shield component)\n            const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n            if (damageDealt) {\n                this.totalDamageDealt += actualDamage;\n                // Check if source is a summoned unit - if so, skip damage numbers to reduce visual clutter\n                const sourceSummonedUnit = source ? source.getComponent(SummonedUnit) : null;\n                const shouldShowDamageNumbers = !sourceSummonedUnit; // Show numbers unless source is a summoned unit\n                if (shouldShowDamageNumbers) {\n                    // Create damage number at target position for damage from players/enemies\n                    const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                    if (transform) {\n                        const position = transform.getWorldPosition();\n                        // Only create damage number if position is valid\n                        if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                            // Offset slightly above the target\n                            position.y += 2;\n                            this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType || \"melee\");\n                        }\n                    }\n                }\n                // Log for debugging (throttled to reduce spam)\n                if (this.shouldLogDamage()) {\n                    const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                    const targetName = summonedUnit.getDisplayName();\n                    const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                // console.log(` ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n                }\n                // Check if target died\n                if (health.isDead) {\n                    this.handleEntityDeath(target, source, currentTime);\n                }\n                // Trigger damage effects\n                this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n            }\n            return; // Don't process further for summoned units\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Apply burning stacks for Entropic Bolt and Crossentropy Bolt\n            let finalDamage = baseDamage;\n            if (damageType === \"entropic\" || damageType === \"crossentropy\") {\n                // Get the ControlSystem to apply burning stacks\n                const controlSystemRef = window.controlSystemRef;\n                if (controlSystemRef && controlSystemRef.current) {\n                    const controlSystem = controlSystemRef.current;\n                    const isEntropicBolt = damageType === \"entropic\";\n                    // Apply burning stack and get damage bonus\n                    const { damageBonus } = controlSystem.applyBurningStack(target.id, currentTime, isEntropicBolt);\n                    finalDamage = baseDamage + damageBonus;\n                    console.log(\"\\uD83D\\uDD25 Applied burning stack to player \".concat(target.id, \": base damage \").concat(baseDamage, \" + bonus \").concat(damageBonus, \" = \").concat(finalDamage));\n                }\n            }\n            // Calculate actual damage with critical hit mechanics (using modified damage)\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(finalDamage);\n            // Route player damage through multiplayer server for PVP (let receiver handle shields)\n            if (this.shouldLogDamage()) {\n            // console.log(` Routing ${damageResult.damage} PVP ${damageType || 'damage'} to player ${target.id} through multiplayer server`);\n            }\n            this.onPlayerDamageCallback(target.id.toString(), damageResult.damage, damageType); // Send damage, let receiver handle shields\n            // Create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    // Add slight position offset for delayed damage (like sabres right hit) to prevent overlap\n                    if (damageType === \"sabres_right\") {\n                        position.x += 0.3; // Slight offset to the right for the right sabre\n                    } else if (damageType === \"sabres_left\") {\n                        position.x -= 0.3; // Slight offset to the left for the left sabre\n                    }\n                    this.damageNumberManager.addDamageNumber(damageResult.damage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                // console.warn(' Skipping PVP damage number creation - invalid position:', position);\n                }\n            }\n            // Log for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n                const targetName = \"Player \".concat(target.id);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(` ${sourceName} dealt ${damageResult.damage}${critText} PVP ${damageType || 'damage'} to ${targetName} (routed to server)`);\n            }\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies and non-summoned units (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                // console.warn(' Skipping damage number creation - invalid position:', position);\n                }\n            }\n            // Log damage for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                const targetName = this.getEntityDisplayName(target);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(` ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n            }\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            // console.log(` ${sourceName} healed ${targetName} for ${amount} HP (${health.currentHealth}/${health.maxHealth} HP)`);\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            // console.log(` ${enemy.getDisplayName()} has been defeated!`);\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        // Handle SummonedUnit death\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            summonedUnit.die(currentTime || Date.now() / 1000);\n            // Immediately disable to prevent further targeting\n            summonedUnit.isActive = false;\n            // console.log(` ${summonedUnit.getDisplayName()} has been defeated!`);\n            // Trigger death effects for summoned units\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        // console.log(` ${enemy.getDisplayName()} has respawned!`);\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n        // console.log(` Damage effect${critText} at position:`, transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                // console.log(` Barrage arrow hit detected, applying slow effect to target ${target.id}`);\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                // console.log(` Applied 50% slow for 5 seconds to target ${target.id}`);\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(` Healing effect at position:`, transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(` Death effect at position:`, transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(` Respawn effect at position:`, transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n    // This would integrate with a progression system\n    // console.log(` Entity ${entity.id} gained ${experience} experience!`);\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            return summonedUnit.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        // Check if target is a summoned unit - skip damage numbers only if source is also a summoned unit\n        const summonedUnitComponent = target.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n            const actualDamage = damageResult.damage;\n            const currentTime = Date.now() / 1000;\n            const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n            if (damageDealt) {\n                this.totalDamageDealt += actualDamage;\n                // Check if source is a summoned unit - if so, skip damage numbers to reduce visual clutter\n                const sourceSummonedUnit = source ? source.getComponent(SummonedUnit) : null;\n                const shouldShowDamageNumbers = !sourceSummonedUnit; // Show numbers unless source is a summoned unit\n                if (shouldShowDamageNumbers) {\n                    // Create damage number at target position for damage from players/enemies\n                    const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                    if (transform) {\n                        const position = transform.getWorldPosition();\n                        // Offset slightly above the target\n                        position.y += 1.5;\n                        this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                    }\n                }\n                if (health.isDead) {\n                    this.handleEntityDeath(target, source, currentTime);\n                }\n                this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n            }\n            return damageDealt;\n        }\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    synchronizeEnemyDebuffsWithMovement(entity, enemy) {\n        const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n        if (!movement) return;\n        // Calculate the effective movement speed multiplier based on enemy debuffs\n        let speedMultiplier = 1.0;\n        // Apply corrupted debuff slow effect\n        if (enemy.isCorrupted) {\n            const currentTime = Date.now() / 1000;\n            const elapsed = currentTime - enemy.corruptedStartTime;\n            // Calculate current slow percentage based on gradual recovery\n            // Initial: 90% slow, recovers 10% per second\n            const currentSlowPercent = Math.max(0, enemy.corruptedInitialSlowPercent - elapsed * enemy.corruptedRecoveryRate);\n            // Apply the slow effect (reduce speed by the slow percentage)\n            speedMultiplier *= 1 - currentSlowPercent;\n            // Debug logging for corrupted debuff (only log occasionally to avoid spam)\n            const logInterval = 1.0; // Log every second\n            if (elapsed % logInterval < 0.1) {\n                console.log(\"\\uD83D\\uDC7B Corrupted debuff on \".concat(enemy.getDisplayName(), \": \").concat((currentSlowPercent * 100).toFixed(1), \"% slow (\").concat((speedMultiplier * 100).toFixed(1), \"% speed remaining)\"));\n            }\n        }\n        // Only update the movement speed multiplier if it's different from the current value\n        // This prevents overriding other effects unnecessarily\n        if (Math.abs(movement.movementSpeedMultiplier - speedMultiplier) > 0.01) {\n            movement.movementSpeedMultiplier = speedMultiplier;\n        }\n        // Reset to normal speed if no debuffs are active\n        if (!enemy.isCorrupted && movement.movementSpeedMultiplier !== 1.0) {\n            // Only reset if no other systems are managing the speed multiplier\n            // Check if this might be from another debuff system (like Corrupted Aura)\n            const wasSlowedByOtherEffect = movement.movementSpeedMultiplier < 1.0;\n            if (!wasSlowedByOtherEffect || movement.movementSpeedMultiplier === 0.1) {\n                movement.movementSpeedMultiplier = 1.0;\n            }\n        }\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        // Log throttling to reduce spam\n        this.lastDamageLogTime = 0;\n        this.damageLogThrottle = 100 // Only log every 100ms\n        ;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFDN0I7QUFFVztBQUNBO0FBQ0Y7QUFDUTtBQUNGO0FBQ0E7QUFFbUI7QUFDTjtBQUNMO0FBQ0o7QUFpQmxELE1BQU1XLHFCQUFxQlgsK0NBQU1BO0lBaUN0QyxtQ0FBbUM7SUFDM0JZLGtCQUEyQjtRQUNqQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLElBQUlBLE1BQU0sSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1lBQ3pELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdGO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDhEQUE4RDtJQUN2REksdUJBQXVCQyxRQUFtRCxFQUFRO1FBQ3ZGLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRUEscUVBQXFFO0lBQzlERSx3QkFBd0JGLFFBQXlFLEVBQVE7UUFDOUcsSUFBSSxDQUFDRyxzQkFBc0IsR0FBR0g7SUFDaEM7SUFFT0ksOEJBQThCSixRQUFvSCxFQUFRO1FBQy9KLElBQUksQ0FBQ0ssNEJBQTRCLEdBQUdMO0lBQ3RDO0lBRUEsa0RBQWtEO0lBQzNDTSx3QkFBd0JDLE1BQWMsRUFBRUMsTUFBYyxFQUFFQyxjQUFzQixFQUFRO1FBQzNGLE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxLQUFLLENBQUNDLFNBQVMsQ0FBQ0MsU0FBU047UUFDakQsSUFBSSxDQUFDRyxZQUFZO1lBQ2ZJLFFBQVFDLElBQUksQ0FBQyw4Q0FBcUQsT0FBUFIsUUFBTztZQUNsRTtRQUNGO1FBRUEsTUFBTVMsU0FBU04sV0FBV08sWUFBWSxDQUFDbEMsMERBQU1BO1FBQzdDLE1BQU1tQyx3QkFBd0JSLFdBQVdPLFlBQVksQ0FBQzFCLHNFQUFZQTtRQUNsRSxJQUFJLENBQUN5QixVQUFVLENBQUNFLHVCQUF1QjtZ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QUFTYSx1QkFBdUIsR0FBRztZQUNyQztRQUNGO0lBQ0Y7SUExMEJBRSxZQUFZNUksS0FBWSxDQUFFO1FBQ3hCLEtBQUs7YUExQlM2SSxxQkFBcUI7WUFBQ3pLLDBEQUFNQTtTQUFDO2FBRXJDdUQsY0FBNkIsRUFBRTthQUMvQkUsWUFBeUIsRUFBRTthQUMzQkMsZUFBeUIsRUFBRTtRQUduQyxvQkFBb0I7YUFDWjRDLG1CQUFtQjthQUNuQlksbUJBQW1CO2FBQ25CSSxnQkFBZ0I7UUFXeEIsZ0NBQWdDO2FBQ3hCeEcsb0JBQW9CO2FBQ3BCQyxvQkFBb0IsSUFBSyx1QkFBdUI7O1FBSXRELElBQUksQ0FBQ2EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3lCLG1CQUFtQixHQUFHLElBQUk5QywyRUFBbUJBO1FBQ2xELElBQUksQ0FBQ21LLFFBQVEsR0FBRyxJQUFJLGdDQUFnQztJQUN0RDtBQXMwQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29tYmF0U3lzdGVtLnRzP2E2MGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29tYmF0IHN5c3RlbSBmb3IgaGFuZGxpbmcgZGFtYWdlLCBoZWFsaW5nLCBhbmQgY29tYmF0IG1lY2hhbmljc1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1NoaWVsZCc7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IGNhbGN1bGF0ZURhbWFnZSwgRGFtYWdlUmVzdWx0IH0gZnJvbSAnQC9jb3JlL0RhbWFnZUNhbGN1bGF0b3InO1xuaW1wb3J0IHsgRGFtYWdlTnVtYmVyTWFuYWdlciB9IGZyb20gJ0AvdXRpbHMvRGFtYWdlTnVtYmVyTWFuYWdlcic7XG5pbXBvcnQgeyBTdW1tb25lZFVuaXQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCc7XG5pbXBvcnQgeyBQcm9qZWN0aWxlIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlJztcblxuaW50ZXJmYWNlIERhbWFnZUV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGRhbWFnZTogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIGRhbWFnZVR5cGU/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSGVhbEV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGFtb3VudDogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29tYmF0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtIZWFsdGhdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBkYW1hZ2VRdWV1ZTogRGFtYWdlRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGhlYWxRdWV1ZTogSGVhbEV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBkZWFkRW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gIHByaXZhdGUgZGFtYWdlTnVtYmVyTWFuYWdlcjogRGFtYWdlTnVtYmVyTWFuYWdlcjtcbiAgXG4gIC8vIENvbWJhdCBzdGF0aXN0aWNzXG4gIHByaXZhdGUgdG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gIHByaXZhdGUgdG90YWxIZWFsaW5nRG9uZSA9IDA7XG4gIHByaXZhdGUgZW5lbWllc0tpbGxlZCA9IDA7XG5cbiAgLy8gTXVsdGlwbGF5ZXIgZGFtYWdlIGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvbkVuZW15RGFtYWdlQ2FsbGJhY2s/OiAoZW5lbXlJZDogc3RyaW5nLCBkYW1hZ2U6IG51bWJlcikgPT4gdm9pZDtcbiAgXG4gIC8vIFBWUCBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvblBsYXllckRhbWFnZUNhbGxiYWNrPzogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8vIFN1bW1vbmVkIHVuaXQgZGFtYWdlIGNhbGxiYWNrIGZvciByb3V0aW5nIHN1bW1vbmVkIHVuaXQgZGFtYWdlIHRvIHNlcnZlclxuICBwcml2YXRlIG9uU3VtbW9uZWRVbml0RGFtYWdlQ2FsbGJhY2s/OiAodW5pdElkOiBzdHJpbmcsIHVuaXRPd25lcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBzb3VyY2VQbGF5ZXJJZDogc3RyaW5nLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8vIExvZyB0aHJvdHRsaW5nIHRvIHJlZHVjZSBzcGFtXG4gIHByaXZhdGUgbGFzdERhbWFnZUxvZ1RpbWUgPSAwO1xuICBwcml2YXRlIGRhbWFnZUxvZ1Rocm90dGxlID0gMTAwOyAvLyBPbmx5IGxvZyBldmVyeSAxMDBtc1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlciA9IG5ldyBEYW1hZ2VOdW1iZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgY29sbGlzaW9uIGRldGVjdGlvblxuICB9XG5cbiAgLy8gVGhyb3R0bGVkIGxvZ2dpbmcgdG8gcmVkdWNlIHNwYW1cbiAgcHJpdmF0ZSBzaG91bGRMb2dEYW1hZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RGFtYWdlTG9nVGltZSA+IHRoaXMuZGFtYWdlTG9nVGhyb3R0bGUpIHtcbiAgICAgIHRoaXMubGFzdERhbWFnZUxvZ1RpbWUgPSBub3c7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXJcbiAgcHVibGljIHNldEVuZW15RGFtYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIHBsYXllciBkYW1hZ2UgdG8gbXVsdGlwbGF5ZXIgc2VydmVyIChQVlApXG4gIHB1YmxpYyBzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0U3VtbW9uZWRVbml0RGFtYWdlQ2FsbGJhY2soY2FsbGJhY2s6ICh1bml0SWQ6IHN0cmluZywgdW5pdE93bmVySWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIHNvdXJjZVBsYXllcklkOiBzdHJpbmcsIGRhbWFnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU3VtbW9uZWRVbml0RGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8vIEFwcGx5IHN1bW1vbmVkIHVuaXQgZGFtYWdlIHJlY2VpdmVkIGZyb20gc2VydmVyXG4gIHB1YmxpYyBhcHBseVN1bW1vbmVkVW5pdERhbWFnZSh1bml0SWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIHNvdXJjZVBsYXllcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCB1bml0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkocGFyc2VJbnQodW5pdElkKSk7XG4gICAgaWYgKCF1bml0RW50aXR5KSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBDYW5ub3QgYXBwbHkgc3VtbW9uZWQgdW5pdCBkYW1hZ2U6IHVuaXQgJHt1bml0SWR9IG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWx0aCA9IHVuaXRFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gdW5pdEVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBDYW5ub3QgYXBwbHkgc3VtbW9uZWQgdW5pdCBkYW1hZ2U6IHVuaXQgJHt1bml0SWR9IG1pc3NpbmcgY29tcG9uZW50c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQXBwbHkgZGFtYWdlIGxvY2FsbHkgKHBhc3MgZW50aXR5IHNvIEhlYWx0aCBjYW4gdXNlIFNoaWVsZCBjb21wb25lbnQpXG4gICAgY29uc3QgZGFtYWdlRGVhbHQgPSBoZWFsdGgudGFrZURhbWFnZShkYW1hZ2UsIGN1cnJlbnRUaW1lLCB1bml0RW50aXR5KTtcblxuICAgIGlmIChkYW1hZ2VEZWFsdCkge1xuICAgICAgY29uc29sZS5sb2coYPCfpJYgQXBwbGllZCAke2RhbWFnZX0gZGFtYWdlIHRvIHN1bW1vbmVkIHVuaXQgJHt1bml0SWR9IGZyb20gcGxheWVyICR7c291cmNlUGxheWVySWR9ICgke2hlYWx0aC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgZGllZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFbnRpdHlEZWF0aCh1bml0RW50aXR5LCB1bmRlZmluZWQsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBkYW1hZ2UgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh1bml0RW50aXR5LCBkYW1hZ2UsIHVuZGVmaW5lZCwgJ21lbGVlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGNvbXBvbmVudHMgKHJlZ2VuZXJhdGlvbiwgaW52dWxuZXJhYmlsaXR5IHRpbWVycylcbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbXBvbmVudHMoZW50aXRpZXMsIGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBkYW1hZ2UgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZSk7XG5cbiAgICAvLyBQcm9jZXNzIGhlYWwgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NIZWFsUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGRlYXRoIGFuZCByZXNwYXduXG4gICAgdGhpcy5oYW5kbGVEZWF0aEFuZFJlc3Bhd24oZW50aXRpZXMsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIENsZWFudXAgb2xkIGRhbWFnZSBudW1iZXJzXG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmNsZWFudXAoKTtcblxuICAgIC8vIENsZWFyIHByb2Nlc3NlZCBxdWV1ZXNcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIHJlcXVpcmVkIEhlYWx0aCBjb21wb25lbnQgaXMgbWlzc2luZ1xuICAgICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnQgKGhhbmRsZXMgcmVnZW5lcmF0aW9uIGFuZCBpbnZ1bG5lcmFiaWxpdHkpXG4gICAgICBoZWFsdGgudXBkYXRlKGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAvLyBVcGRhdGUgc2hpZWxkIGNvbXBvbmVudCBpZiBpdCBleGlzdHNcbiAgICAgIGNvbnN0IHNoaWVsZCA9IGVudGl0eS5nZXRDb21wb25lbnQoU2hpZWxkKTtcbiAgICAgIGlmIChzaGllbGQpIHtcbiAgICAgICAgc2hpZWxkLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZGVidWZmIHN0YXR1c2VzIGZvciBlbmVtaWVzXG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgaWYgKGVuZW15KSB7XG4gICAgICAgIGVuZW15LnVwZGF0ZUZyZWV6ZVN0YXR1cyhjdXJyZW50VGltZSk7XG4gICAgICAgIGVuZW15LnVwZGF0ZUNvcnJ1cHRlZFN0YXR1cyhjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTeW5jaHJvbml6ZSBlbmVteSBkZWJ1ZmZzIHdpdGggbW92ZW1lbnQgY29tcG9uZW50XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVFbmVteURlYnVmZnNXaXRoTW92ZW1lbnQoZW50aXR5LCBlbmVteSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzRGFtYWdlUXVldWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZGFtYWdlRXZlbnQgb2YgdGhpcy5kYW1hZ2VRdWV1ZSkge1xuICAgICAgdGhpcy5hcHBseURhbWFnZShkYW1hZ2VFdmVudCwgY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0hlYWxRdWV1ZShjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBoZWFsRXZlbnQgb2YgdGhpcy5oZWFsUXVldWUpIHtcbiAgICAgIHRoaXMuYXBwbHlIZWFsaW5nKGhlYWxFdmVudCwgY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlEYW1hZ2UoZGFtYWdlRXZlbnQ6IERhbWFnZUV2ZW50LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB0YXJnZXQsIGRhbWFnZTogYmFzZURhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlIH0gPSBkYW1hZ2VFdmVudDtcblxuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybjtcblxuICAgIC8vIEltcG9ydCBTdW1tb25lZFVuaXQgY29tcG9uZW50IGR5bmFtaWNhbGx5IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICBjb25zdCBTdW1tb25lZFVuaXQgPSByZXF1aXJlKCdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCcpLlN1bW1vbmVkVW5pdDtcblxuICAgIC8vIERlYnVnOiBMb2cgYWxsIGRhbWFnZSBldmVudHMgZm9yIGNoYXJnZSBkYW1hZ2VcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ2NoYXJnZScpIHtcbiAgICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBjb25zdCBzdW1tb25lZFVuaXRDb21wb25lbnQgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCk7XG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBzdW1tb25lZFVuaXRDb21wb25lbnQgPyBzdW1tb25lZFVuaXRDb21wb25lbnQgYXMgdHlwZW9mIFN1bW1vbmVkVW5pdC5wcm90b3R5cGUgOiBudWxsO1xuICAgICAgY29uc3QgZW50aXR5VHlwZSA9IGVuZW15ID8gYEVuZW15KCR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IHN1bW1vbmVkVW5pdCA/IGBTdW1tb25lZFVuaXQoJHtzdW1tb25lZFVuaXQuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IGBQbGF5ZXIoJHt0YXJnZXQuaWR9KWA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFuIGVuZW15IC0gaWYgc28sIHJvdXRlIGRhbWFnZSB0aHJvdWdoIG11bHRpcGxheWVyXG4gICAgY29uc3QgZW5lbXkgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICBpZiAoZW5lbXkgJiYgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGFtYWdlIHdpdGggY3JpdGljYWwgaGl0IG1lY2hhbmljc1xuICAgICAgY29uc3QgZGFtYWdlUmVzdWx0OiBEYW1hZ2VSZXN1bHQgPSBjYWxjdWxhdGVEYW1hZ2UoYmFzZURhbWFnZSk7XG4gICAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgICAvLyBSb3V0ZSBlbmVteSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXIgaW5zdGVhZCBvZiBhcHBseWluZyBsb2NhbGx5XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+MkCBSb3V0aW5nICR7YWN0dWFsRGFtYWdlfSBkYW1hZ2UgdG8gZW5lbXkgJHt0YXJnZXQuaWR9IHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyYCk7XG4gICAgICB0aGlzLm9uRW5lbXlEYW1hZ2VDYWxsYmFjayh0YXJnZXQuaWQudG9TdHJpbmcoKSwgYWN0dWFsRGFtYWdlKTtcblxuICAgICAgLy8gU3RpbGwgY3JlYXRlIGxvY2FsIGRhbWFnZSBudW1iZXJzIGZvciBpbW1lZGlhdGUgdmlzdWFsIGZlZWRiYWNrXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgcG9zaXRpb24ueSArPSAxLjU7XG4gICAgICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5hZGREYW1hZ2VOdW1iZXIoXG4gICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIGRhbWFnZVR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG5cbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIGVuZW1pZXNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBzdW1tb25lZCB1bml0IC0gcm91dGUgdGhyb3VnaCBzZXJ2ZXIgZm9yIHN5bmNocm9uaXphdGlvblxuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IHRhcmdldC5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50ICYmIHRoaXMub25TdW1tb25lZFVuaXREYW1hZ2VDYWxsYmFjaykge1xuICAgICAgLy8gQ2FzdCB0byBwcm9wZXIgdHlwZVxuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gc3VtbW9uZWRVbml0Q29tcG9uZW50IGFzIHR5cGVvZiBTdW1tb25lZFVuaXQucHJvdG90eXBlO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcblxuICAgICAgLy8gR2V0IHNvdXJjZSBwbGF5ZXIgSUQgZm9yIHRlYW0gdmFsaWRhdGlvblxuICAgICAgLy8gRm9yIHByb2plY3RpbGVzLCBjaGVjayBpZiB0aGUgc291cmNlIGhhcyBhIHBsYXllciBJRCBzdG9yZWRcbiAgICAgIGxldCBzb3VyY2VQbGF5ZXJJZCA9ICd1bmtub3duJztcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgc291cmNlIGlzIGEgcHJvamVjdGlsZSB3aXRoIHN0b3JlZCBwbGF5ZXIgaW5mb1xuICAgICAgICBjb25zdCBwcm9qZWN0aWxlQ29tcG9uZW50ID0gc291cmNlLmdldENvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICAgICAgaWYgKHByb2plY3RpbGVDb21wb25lbnQgJiYgKHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KS5zb3VyY2VQbGF5ZXJJZCkge1xuICAgICAgICAgIHNvdXJjZVBsYXllcklkID0gKHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KS5zb3VyY2VQbGF5ZXJJZDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudXNlckRhdGE/LnBsYXllcklkKSB7XG4gICAgICAgICAgc291cmNlUGxheWVySWQgPSBzb3VyY2UudXNlckRhdGEucGxheWVySWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBzZXJ2ZXIgdW5pdCBJRCBmcm9tIHVzZXJEYXRhIChzZXQgZHVyaW5nIEVDUyBzeW5jKVxuICAgICAgY29uc3Qgc2VydmVyVW5pdElkID0gdGFyZ2V0LnVzZXJEYXRhPy5zZXJ2ZXJVbml0SWQgfHwgc3VtbW9uZWRVbml0LnVuaXRJZDtcbiAgICAgIGNvbnN0IHNlcnZlclVuaXRPd25lcklkID0gdGFyZ2V0LnVzZXJEYXRhPy5zZXJ2ZXJVbml0T3duZXJJZCB8fCBzdW1tb25lZFVuaXQub3duZXJJZDtcblxuICAgICAgLy8gUm91dGUgc3VtbW9uZWQgdW5pdCBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXIgaW5zdGVhZCBvZiBhcHBseWluZyBsb2NhbGx5XG4gICAgICBjb25zb2xlLmxvZyhg8J+MkCBSb3V0aW5nICR7YWN0dWFsRGFtYWdlfSBkYW1hZ2UgdG8gc3VtbW9uZWQgdW5pdCAke3NlcnZlclVuaXRJZH0gKG93bmVkIGJ5ICR7c2VydmVyVW5pdE93bmVySWR9KSBmcm9tIHNvdXJjZSBwbGF5ZXIgJHtzb3VyY2VQbGF5ZXJJZH0gdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXJgKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWc6IExvZyB0aGUgc291cmNlIGluZm9ybWF0aW9uXG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3RpbGVDb21wb25lbnQgPSBzb3VyY2UuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBTb3VyY2UgZW50aXR5ICR7c291cmNlLmlkfSAtIHByb2plY3RpbGUgc291cmNlUGxheWVySWQ6ICR7KHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KT8uc291cmNlUGxheWVySWR9LCB1c2VyRGF0YSBwbGF5ZXJJZDogJHtzb3VyY2UudXNlckRhdGE/LnBsYXllcklkfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWJ1ZzogTG9nIHRoZSB0ZWFtIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgIGNvbnNvbGUubG9nKGDwn5uh77iPIFRlYW0gdmFsaWRhdGlvbjogc291cmNlUGxheWVySWQ9XCIke3NvdXJjZVBsYXllcklkfVwiIHZzIHVuaXRPd25lcklkPVwiJHtzZXJ2ZXJVbml0T3duZXJJZH1cIiAtICR7c291cmNlUGxheWVySWQgPT09IHNlcnZlclVuaXRPd25lcklkID8gJ0JMT0NLRUQgKHNhbWUgdGVhbSknIDogJ0FMTE9XRUQgKGRpZmZlcmVudCB0ZWFtcyknfWApO1xuICAgICAgXG4gICAgICAvLyBCbG9jayBkYW1hZ2UgdG8gb3duIHVuaXRzXG4gICAgICBpZiAoc291cmNlUGxheWVySWQgPT09IHNlcnZlclVuaXRPd25lcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEJsb2NrZWQgZGFtYWdlIHRvIG93biBzdW1tb25lZCB1bml0YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkaXRpb25hbCBjaGVjazogRG9uJ3Qgc2VuZCBkYW1hZ2UgZm9yIHVuaXRzIHRoYXQgYXJlIGFscmVhZHkgZGVhZCBsb2NhbGx5XG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCB8fCBoZWFsdGguY3VycmVudEhlYWx0aCA8PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEJsb2NrZWQgZGFtYWdlIHRvIGFscmVhZHkgZGVhZCBzdW1tb25lZCB1bml0ICR7c2VydmVyVW5pdElkfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGwgdGhlIHNlcnZlciBkYW1hZ2UgY2FsbGJhY2sgd2l0aCBzZXJ2ZXIgdW5pdCBJRFxuICAgICAgdGhpcy5vblN1bW1vbmVkVW5pdERhbWFnZUNhbGxiYWNrKFxuICAgICAgICBzZXJ2ZXJVbml0SWQsXG4gICAgICAgIHNlcnZlclVuaXRPd25lcklkLFxuICAgICAgICBhY3R1YWxEYW1hZ2UsXG4gICAgICAgIHNvdXJjZVBsYXllcklkLFxuICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICApO1xuXG4gICAgICAvLyBTdGlsbCBjcmVhdGUgbG9jYWwgZGFtYWdlIG51bWJlcnMgZm9yIGltbWVkaWF0ZSB2aXN1YWwgZmVlZGJhY2tcbiAgICAgIC8vIENoZWNrIGlmIHNvdXJjZSBpcyBhIHN1bW1vbmVkIHVuaXQgLSBpZiBzbywgc2tpcCBkYW1hZ2UgbnVtYmVycyB0byByZWR1Y2UgdmlzdWFsIGNsdXR0ZXJcbiAgICAgIGNvbnN0IHNvdXJjZVN1bW1vbmVkVW5pdCA9IHNvdXJjZSA/IHNvdXJjZS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KSA6IG51bGw7XG4gICAgICBjb25zdCBzaG91bGRTaG93RGFtYWdlTnVtYmVycyA9ICFzb3VyY2VTdW1tb25lZFVuaXQ7IC8vIFNob3cgbnVtYmVycyB1bmxlc3Mgc291cmNlIGlzIGEgc3VtbW9uZWQgdW5pdFxuXG4gICAgICBpZiAoc2hvdWxkU2hvd0RhbWFnZU51bWJlcnMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBwb3NpdGlvbi55ICs9IDI7XG4gICAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgICBhY3R1YWxEYW1hZ2UsXG4gICAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgZGFtYWdlVHlwZSB8fCAnbWVsZWUnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47IC8vIERvbid0IGFwcGx5IGRhbWFnZSBsb2NhbGx5IGZvciBzdW1tb25lZCB1bml0c1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiBJZiBubyBjYWxsYmFjayBpcyBzZXQsIGFwcGx5IGRhbWFnZSBsb2NhbGx5IChmb3Igc2luZ2xlLXBsYXllciBvciB0ZXN0aW5nKVxuICAgIGlmIChzdW1tb25lZFVuaXRDb21wb25lbnQgJiYgIXRoaXMub25TdW1tb25lZFVuaXREYW1hZ2VDYWxsYmFjaykge1xuICAgICAgLy8gQ2FzdCB0byBwcm9wZXIgdHlwZVxuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gc3VtbW9uZWRVbml0Q29tcG9uZW50IGFzIHR5cGVvZiBTdW1tb25lZFVuaXQucHJvdG90eXBlO1xuXG4gICAgICAvLyBHZXQgc291cmNlIHBsYXllciBJRCBmb3IgdGVhbSB2YWxpZGF0aW9uIChzYW1lIGxvZ2ljIGFzIGFib3ZlKVxuICAgICAgbGV0IHNvdXJjZVBsYXllcklkID0gJ3Vua25vd24nO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBwcm9qZWN0aWxlQ29tcG9uZW50ID0gc291cmNlLmdldENvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICAgICAgaWYgKHByb2plY3RpbGVDb21wb25lbnQgJiYgKHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KS5zb3VyY2VQbGF5ZXJJZCkge1xuICAgICAgICAgIHNvdXJjZVBsYXllcklkID0gKHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KS5zb3VyY2VQbGF5ZXJJZDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudXNlckRhdGE/LnBsYXllcklkKSB7XG4gICAgICAgICAgc291cmNlUGxheWVySWQgPSBzb3VyY2UudXNlckRhdGEucGxheWVySWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVEVNUE9SQVJZOiBCbG9jayBhbGwgZGFtYWdlIHRvIG93biB1bml0cyBmb3IgdGVzdGluZyAoZXZlbiBpbiBmYWxsYmFjaylcbiAgICAgIGlmIChzb3VyY2VQbGF5ZXJJZCA9PT0gc3VtbW9uZWRVbml0Lm93bmVySWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDwn5qrIEZBTExCQUNLIEJMT0NLRUQ6IFBsYXllciAke3NvdXJjZVBsYXllcklkfSB0cmllZCB0byBkYW1hZ2UgdGhlaXIgb3duIHN1bW1vbmVkIHVuaXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIHJldHVybjsgLy8gQmxvY2sgdGhlIGRhbWFnZVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcblxuICAgICAgLy8gQXBwbHkgZGFtYWdlIGxvY2FsbHkgKHBhc3MgZW50aXR5IHNvIEhlYWx0aCBjYW4gdXNlIFNoaWVsZCBjb21wb25lbnQpXG4gICAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IGhlYWx0aC50YWtlRGFtYWdlKGFjdHVhbERhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG5cbiAgICAgIGlmIChkYW1hZ2VEZWFsdCkge1xuICAgICAgICB0aGlzLnRvdGFsRGFtYWdlRGVhbHQgKz0gYWN0dWFsRGFtYWdlO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHNvdXJjZSBpcyBhIHN1bW1vbmVkIHVuaXQgLSBpZiBzbywgc2tpcCBkYW1hZ2UgbnVtYmVycyB0byByZWR1Y2UgdmlzdWFsIGNsdXR0ZXJcbiAgICAgICAgY29uc3Qgc291cmNlU3VtbW9uZWRVbml0ID0gc291cmNlID8gc291cmNlLmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2hvdWxkU2hvd0RhbWFnZU51bWJlcnMgPSAhc291cmNlU3VtbW9uZWRVbml0OyAvLyBTaG93IG51bWJlcnMgdW5sZXNzIHNvdXJjZSBpcyBhIHN1bW1vbmVkIHVuaXRcblxuICAgICAgICBpZiAoc2hvdWxkU2hvd0RhbWFnZU51bWJlcnMpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgZGFtYWdlIG51bWJlciBhdCB0YXJnZXQgcG9zaXRpb24gZm9yIGRhbWFnZSBmcm9tIHBsYXllcnMvZW5lbWllc1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBkYW1hZ2UgbnVtYmVyIGlmIHBvc2l0aW9uIGlzIHZhbGlkXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gT2Zmc2V0IHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgcG9zaXRpb24ueSArPSAyO1xuICAgICAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkYW1hZ2VUeXBlIHx8ICdtZWxlZSdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHN1bW1vbmVkVW5pdC5nZXREaXNwbGF5TmFtZSgpO1xuICAgICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDimpTvuI8gJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgZGllZFxuICAgICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgZGFtYWdlIGVmZmVjdHNcbiAgICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgcHJvY2VzcyBmdXJ0aGVyIGZvciBzdW1tb25lZCB1bml0c1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhIHBsYXllciBpbiBQVlAgbW9kZSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIC8vIEFsc28gcHJldmVudCBzZWxmLWRhbWFnZSBpbiBQVlAgKHNvdXJjZSBoaXR0aW5nIHRoZW1zZWx2ZXMpXG4gICAgaWYgKCFlbmVteSAmJiB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sgJiYgc291cmNlICYmIHNvdXJjZS5pZCAhPT0gdGFyZ2V0LmlkKSB7XG4gICAgICAvLyBBcHBseSBidXJuaW5nIHN0YWNrcyBmb3IgRW50cm9waWMgQm9sdCBhbmQgQ3Jvc3NlbnRyb3B5IEJvbHRcbiAgICAgIGxldCBmaW5hbERhbWFnZSA9IGJhc2VEYW1hZ2U7XG4gICAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ2VudHJvcGljJyB8fCBkYW1hZ2VUeXBlID09PSAnY3Jvc3NlbnRyb3B5Jykge1xuICAgICAgICAvLyBHZXQgdGhlIENvbnRyb2xTeXN0ZW0gdG8gYXBwbHkgYnVybmluZyBzdGFja3NcbiAgICAgICAgY29uc3QgY29udHJvbFN5c3RlbVJlZiA9ICh3aW5kb3cgYXMgYW55KS5jb250cm9sU3lzdGVtUmVmO1xuICAgICAgICBpZiAoY29udHJvbFN5c3RlbVJlZiAmJiBjb250cm9sU3lzdGVtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjb25zdCBjb250cm9sU3lzdGVtID0gY29udHJvbFN5c3RlbVJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IGlzRW50cm9waWNCb2x0ID0gZGFtYWdlVHlwZSA9PT0gJ2VudHJvcGljJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHBseSBidXJuaW5nIHN0YWNrIGFuZCBnZXQgZGFtYWdlIGJvbnVzXG4gICAgICAgICAgY29uc3QgeyBkYW1hZ2VCb251cyB9ID0gY29udHJvbFN5c3RlbS5hcHBseUJ1cm5pbmdTdGFjayh0YXJnZXQuaWQsIGN1cnJlbnRUaW1lLCBpc0VudHJvcGljQm9sdCk7XG4gICAgICAgICAgZmluYWxEYW1hZ2UgPSBiYXNlRGFtYWdlICsgZGFtYWdlQm9udXM7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYPCflKUgQXBwbGllZCBidXJuaW5nIHN0YWNrIHRvIHBsYXllciAke3RhcmdldC5pZH06IGJhc2UgZGFtYWdlICR7YmFzZURhbWFnZX0gKyBib251cyAke2RhbWFnZUJvbnVzfSA9ICR7ZmluYWxEYW1hZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzICh1c2luZyBtb2RpZmllZCBkYW1hZ2UpXG4gICAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShmaW5hbERhbWFnZSk7XG5cbiAgICAgIC8vIFJvdXRlIHBsYXllciBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXIgZm9yIFBWUCAobGV0IHJlY2VpdmVyIGhhbmRsZSBzaGllbGRzKVxuICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nRGFtYWdlKCkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYOKalO+4jyBSb3V0aW5nICR7ZGFtYWdlUmVzdWx0LmRhbWFnZX0gUFZQICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gcGxheWVyICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgfVxuICAgICAgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrKHRhcmdldC5pZC50b1N0cmluZygpLCBkYW1hZ2VSZXN1bHQuZGFtYWdlLCBkYW1hZ2VUeXBlKTsgLy8gU2VuZCBkYW1hZ2UsIGxldCByZWNlaXZlciBoYW5kbGUgc2hpZWxkc1xuXG4gICAgICAvLyBDcmVhdGUgbG9jYWwgZGFtYWdlIG51bWJlcnMgZm9yIGltbWVkaWF0ZSB2aXN1YWwgZmVlZGJhY2tcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBkYW1hZ2UgbnVtYmVyIGlmIHBvc2l0aW9uIGlzIHZhbGlkXG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuXG4gICAgICAgICAgLy8gQWRkIHNsaWdodCBwb3NpdGlvbiBvZmZzZXQgZm9yIGRlbGF5ZWQgZGFtYWdlIChsaWtlIHNhYnJlcyByaWdodCBoaXQpIHRvIHByZXZlbnQgb3ZlcmxhcFxuICAgICAgICAgIGlmIChkYW1hZ2VUeXBlID09PSAnc2FicmVzX3JpZ2h0Jykge1xuICAgICAgICAgICAgcG9zaXRpb24ueCArPSAwLjM7IC8vIFNsaWdodCBvZmZzZXQgdG8gdGhlIHJpZ2h0IGZvciB0aGUgcmlnaHQgc2FicmVcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhbWFnZVR5cGUgPT09ICdzYWJyZXNfbGVmdCcpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggLT0gMC4zOyAvLyBTbGlnaHQgb2Zmc2V0IHRvIHRoZSBsZWZ0IGZvciB0aGUgbGVmdCBzYWJyZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5hZGREYW1hZ2VOdW1iZXIoXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuZGFtYWdlLCAvLyBTaG93IHRoZSBmdWxsIGRhbWFnZSBpbiBkYW1hZ2UgbnVtYmVyc1xuICAgICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhbWFnZVR5cGUgfHwgJ3B2cCdcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFNraXBwaW5nIFBWUCBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmcgKHRocm90dGxlZCB0byByZWR1Y2Ugc3BhbSlcbiAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgUGxheWVyICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSBgUGxheWVyICR7dGFyZ2V0LmlkfWA7XG4gICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg4pqU77iPICR7c291cmNlTmFtZX0gZGVhbHQgJHtkYW1hZ2VSZXN1bHQuZGFtYWdlfSR7Y3JpdFRleHR9IFBWUCAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKHJvdXRlZCB0byBzZXJ2ZXIpYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIFBWUCBwbGF5ZXJzXG4gICAgfVxuXG4gICAgLy8gRm9yIG5vbi1lbmVtaWVzIGFuZCBub24tc3VtbW9uZWQgdW5pdHMgKGxpa2UgcGxheWVycyBpbiBub24tUFZQIG1vZGUpLCBhcHBseSBkYW1hZ2UgbG9jYWxseSBhcyBiZWZvcmVcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgLy8gQXBwbHkgZGFtYWdlIChwYXNzIGVudGl0eSBzbyBIZWFsdGggY2FuIHVzZSBTaGllbGQgY29tcG9uZW50KVxuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcblxuICAgIGlmIChkYW1hZ2VEZWFsdCkge1xuICAgICAgdGhpcy50b3RhbERhbWFnZURlYWx0ICs9IGFjdHVhbERhbWFnZTtcblxuICAgICAgLy8gQ3JlYXRlIGRhbWFnZSBudW1iZXIgYXQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZGFtYWdlIG51bWJlciBpZiBwb3NpdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICAgIHBvc2l0aW9uLnkgKz0gMztcbiAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhbWFnZVR5cGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFNraXBwaW5nIGRhbWFnZSBudW1iZXIgY3JlYXRpb24gLSBpbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2cgZGFtYWdlIGZvciBkZWJ1Z2dpbmcgKHRocm90dGxlZCB0byByZWR1Y2Ugc3BhbSlcbiAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0aGlzLmdldEVudGl0eURpc3BsYXlOYW1lKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+SpSAke3NvdXJjZU5hbWV9IGRlYWx0ICR7YWN0dWFsRGFtYWdlfSR7Y3JpdFRleHR9ICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAoJHtoZWFsdGguY3VycmVudEhlYWx0aH0vJHtoZWFsdGgubWF4SGVhbHRofSBIUClgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGRpZWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBkYW1hZ2UgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBseUhlYWxpbmcoaGVhbEV2ZW50OiBIZWFsRXZlbnQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRhcmdldCwgYW1vdW50LCBzb3VyY2UgfSA9IGhlYWxFdmVudDtcbiAgICBcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm47XG5cbiAgICAvLyBBcHBseSBoZWFsaW5nXG4gICAgY29uc3QgaGVhbGluZ0RvbmUgPSBoZWFsdGguaGVhbChhbW91bnQpO1xuICAgIFxuICAgIGlmIChoZWFsaW5nRG9uZSkge1xuICAgICAgdGhpcy50b3RhbEhlYWxpbmdEb25lICs9IGFtb3VudDtcbiAgICAgIFxuICAgICAgLy8gTG9nIGhlYWxpbmcgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBFbnRpdHkgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0aGlzLmdldEVudGl0eURpc3BsYXlOYW1lKHRhcmdldCk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SmiAke3NvdXJjZU5hbWV9IGhlYWxlZCAke3RhcmdldE5hbWV9IGZvciAke2Ftb3VudH0gSFAgKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG5cbiAgICAgIC8vIFRyaWdnZXIgaGVhbGluZyBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUVudGl0eURlYXRoKGVudGl0eTogRW50aXR5LCBraWxsZXI/OiBFbnRpdHksIGN1cnJlbnRUaW1lPzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcblxuICAgIGlmIChlbmVteSkge1xuICAgICAgZW5lbXkuZGllKGN1cnJlbnRUaW1lIHx8IERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIHRoaXMuZW5lbWllc0tpbGxlZCsrO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SgCAke2VuZW15LmdldERpc3BsYXlOYW1lKCl9IGhhcyBiZWVuIGRlZmVhdGVkIWApO1xuXG4gICAgICAvLyBBd2FyZCBleHBlcmllbmNlIHRvIGtpbGxlciBpZiBpdCdzIGEgcGxheWVyXG4gICAgICBpZiAoa2lsbGVyKSB7XG4gICAgICAgIHRoaXMuYXdhcmRFeHBlcmllbmNlKGtpbGxlciwgZW5lbXkuZXhwZXJpZW5jZVJld2FyZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZGVhdGggZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eSwga2lsbGVyKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgU3VtbW9uZWRVbml0IGRlYXRoXG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXRDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1vbmVkVW5pdCA9IHN1bW1vbmVkVW5pdENvbXBvbmVudCBhcyB0eXBlb2YgU3VtbW9uZWRVbml0LnByb3RvdHlwZTtcbiAgICAgIHN1bW1vbmVkVW5pdC5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgXG4gICAgICAvLyBJbW1lZGlhdGVseSBkaXNhYmxlIHRvIHByZXZlbnQgZnVydGhlciB0YXJnZXRpbmdcbiAgICAgIHN1bW1vbmVkVW5pdC5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SgCAke3N1bW1vbmVkVW5pdC5nZXREaXNwbGF5TmFtZSgpfSBoYXMgYmVlbiBkZWZlYXRlZCFgKTtcblxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzIGZvciBzdW1tb25lZCB1bml0c1xuICAgICAgdGhpcy50cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eSwga2lsbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlYWRFbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURlYXRoQW5kUmVzcGF3bihlbnRpdGllczogRW50aXR5W10sIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgIFxuICAgICAgaWYgKCFoZWFsdGggfHwgIWVuZW15KSBjb250aW51ZTtcblxuICAgICAgLy8gSGFuZGxlIHJlc3Bhd24gZm9yIGVuZW1pZXNcbiAgICAgIGlmIChlbmVteS5pc0RlYWQgJiYgZW5lbXkuY2FuUmVzcGF3bk5vdyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5yZXNwYXduRW5lbXkoZW50aXR5LCBlbmVteSwgaGVhbHRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc3Bhd25FbmVteShlbnRpdHk6IEVudGl0eSwgZW5lbXk6IEVuZW15LCBoZWFsdGg6IEhlYWx0aCk6IHZvaWQge1xuICAgIC8vIFJlc3Bhd24gdGhlIGVuZW15XG4gICAgZW5lbXkucmVzcGF3bigpO1xuICAgIGhlYWx0aC5yZXZpdmUoKTtcbiAgICBcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+UhCAke2VuZW15LmdldERpc3BsYXlOYW1lKCl9IGhhcyByZXNwYXduZWQhYCk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciByZXNwYXduIGVmZmVjdHNcbiAgICB0aGlzLnRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHkpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgZGFtYWdlOiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSwgZGFtYWdlVHlwZT86IHN0cmluZywgaXNDcml0aWNhbD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIHBhcnRpY2xlIGVmZmVjdHMsIHNjcmVlbiBzaGFrZSwgZXRjLlxuICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgaGFuZGxlIGJhc2ljIGVmZmVjdHNcbiAgICBcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgLy8gQ291bGQgdHJpZ2dlciBkYW1hZ2UgbnVtYmVyIHBvcHVwLCBibG9vZCBlZmZlY3RzLCBldGMuXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGxvZyB0aGUgcG9zaXRpb24gd2hlcmUgZGFtYWdlIG9jY3VycmVkXG4gICAgICBjb25zdCBjcml0VGV4dCA9IGlzQ3JpdGljYWwgPyAnIChDUklUSUNBTCknIDogJyc7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+OryBEYW1hZ2UgZWZmZWN0JHtjcml0VGV4dH0gYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBwcm9qZWN0aWxlIGVmZmVjdHNcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ3Byb2plY3RpbGUnICYmIHNvdXJjZSkge1xuICAgICAgY29uc3Qgc291cmNlUmVuZGVyZXIgPSBzb3VyY2UuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICAgIGlmIChzb3VyY2VSZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzQmFycmFnZUFycm93KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn4+5IEJhcnJhZ2UgYXJyb3cgaGl0IGRldGVjdGVkLCBhcHBseWluZyBzbG93IGVmZmVjdCB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIGNvbnN0IHRhcmdldE1vdmVtZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXRNb3ZlbWVudCkge1xuICAgICAgICAgIHRhcmdldE1vdmVtZW50LnNsb3coNTAwMCwgMC41KTsgLy8gNSBzZWNvbmRzLCA1MCUgc3BlZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+QjCBBcHBsaWVkIDUwJSBzbG93IGZvciA1IHNlY29uZHMgdG8gdGFyZ2V0ICR7dGFyZ2V0LmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VySGVhbGluZ0VmZmVjdHModGFyZ2V0OiBFbnRpdHksIGFtb3VudDogbnVtYmVyLCBzb3VyY2U/OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIGhlYWxpbmcgcGFydGljbGUgZWZmZWN0c1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg4pyoIEhlYWxpbmcgZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eTogRW50aXR5LCBraWxsZXI/OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIGRlYXRoIGFuaW1hdGlvbnMsIGxvb3QgZHJvcHMsIGV0Yy5cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgLy8gY29uc29sZS5sb2coYPCfkoAgRGVhdGggZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyUmVzcGF3bkVmZmVjdHMoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIHJlc3Bhd24gYW5pbWF0aW9ucywgZWZmZWN0cywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+MnyBSZXNwYXduIGVmZmVjdCBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXdhcmRFeHBlcmllbmNlKGVudGl0eTogRW50aXR5LCBleHBlcmllbmNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGEgcHJvZ3Jlc3Npb24gc3lzdGVtXG4gICAgLy8gY29uc29sZS5sb2coYOKtkCBFbnRpdHkgJHtlbnRpdHkuaWR9IGdhaW5lZCAke2V4cGVyaWVuY2V9IGV4cGVyaWVuY2UhYCk7XG4gIH1cblxuICBwcml2YXRlIGdldEVudGl0eURpc3BsYXlOYW1lKGVudGl0eTogRW50aXR5KTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgIGlmIChlbmVteSkge1xuICAgICAgcmV0dXJuIGVuZW15LmdldERpc3BsYXlOYW1lKCk7XG4gICAgfVxuXG4gICAgLy8gSW1wb3J0IFN1bW1vbmVkVW5pdCBjb21wb25lbnQgZHluYW1pY2FsbHkgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIGNvbnN0IFN1bW1vbmVkVW5pdCA9IHJlcXVpcmUoJ0AvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0JykuU3VtbW9uZWRVbml0O1xuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBzdW1tb25lZFVuaXRDb21wb25lbnQgYXMgdHlwZW9mIFN1bW1vbmVkVW5pdC5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gc3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCk7XG4gICAgfVxuXG4gICAgLy8gQ291bGQgY2hlY2sgZm9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBwcm92aWRlIG5hbWVzXG4gICAgcmV0dXJuIGBFbnRpdHkgJHtlbnRpdHkuaWR9YDtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIG90aGVyIHN5c3RlbXMgdG8gcXVldWUgZGFtYWdlIGFuZCBoZWFsaW5nXG4gIHB1YmxpYyBxdWV1ZURhbWFnZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLnB1c2goe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGFtYWdlLFxuICAgICAgc291cmNlLFxuICAgICAgZGFtYWdlVHlwZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBxdWV1ZUhlYWxpbmcoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBhbW91bnQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbW1lZGlhdGUgZGFtYWdlL2hlYWxpbmcgKGJ5cGFzc2VzIHF1ZXVlKVxuICBwdWJsaWMgZGVhbERhbWFnZUltbWVkaWF0ZShcbiAgICB0YXJnZXQ6IEVudGl0eSxcbiAgICBkYW1hZ2U6IG51bWJlcixcbiAgICBzb3VyY2U/OiBFbnRpdHksXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJbXBvcnQgU3VtbW9uZWRVbml0IGNvbXBvbmVudCBkeW5hbWljYWxseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBzdW1tb25lZCB1bml0IC0gc2tpcCBkYW1hZ2UgbnVtYmVycyBvbmx5IGlmIHNvdXJjZSBpcyBhbHNvIGEgc3VtbW9uZWQgdW5pdFxuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IHRhcmdldC5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGRhbWFnZSk7XG4gICAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgY29uc3QgZGFtYWdlRGVhbHQgPSBoZWFsdGgudGFrZURhbWFnZShhY3R1YWxEYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuXG4gICAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgICAgdGhpcy50b3RhbERhbWFnZURlYWx0ICs9IGFjdHVhbERhbWFnZTtcblxuICAgICAgICAvLyBDaGVjayBpZiBzb3VyY2UgaXMgYSBzdW1tb25lZCB1bml0IC0gaWYgc28sIHNraXAgZGFtYWdlIG51bWJlcnMgdG8gcmVkdWNlIHZpc3VhbCBjbHV0dGVyXG4gICAgICAgIGNvbnN0IHNvdXJjZVN1bW1vbmVkVW5pdCA9IHNvdXJjZSA/IHNvdXJjZS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNob3VsZFNob3dEYW1hZ2VOdW1iZXJzID0gIXNvdXJjZVN1bW1vbmVkVW5pdDsgLy8gU2hvdyBudW1iZXJzIHVubGVzcyBzb3VyY2UgaXMgYSBzdW1tb25lZCB1bml0XG5cbiAgICAgICAgaWYgKHNob3VsZFNob3dEYW1hZ2VOdW1iZXJzKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGRhbWFnZSBudW1iZXIgYXQgdGFyZ2V0IHBvc2l0aW9uIGZvciBkYW1hZ2UgZnJvbSBwbGF5ZXJzL2VuZW1pZXNcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgICAgICAgLy8gT2Zmc2V0IHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgIGRhbWFnZVR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWx0aC5pc0RlYWQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVudGl0eURlYXRoKHRhcmdldCwgc291cmNlLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldCwgYWN0dWFsRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUsIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhbWFnZURlYWx0O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGFtYWdlIHdpdGggY3JpdGljYWwgaGl0IG1lY2hhbmljc1xuICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGRhbWFnZSk7XG4gICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgZGFtYWdlRGVhbHQgPSBoZWFsdGgudGFrZURhbWFnZShhY3R1YWxEYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuXG4gICAgaWYgKGRhbWFnZURlYWx0KSB7XG4gICAgICB0aGlzLnRvdGFsRGFtYWdlRGVhbHQgKz0gYWN0dWFsRGFtYWdlO1xuXG4gICAgICAvLyBDcmVhdGUgZGFtYWdlIG51bWJlciBhdCB0YXJnZXQgcG9zaXRpb25cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICBwb3NpdGlvbi55ICs9IDEuNTtcbiAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICBhY3R1YWxEYW1hZ2UsXG4gICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgZGFtYWdlVHlwZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUVudGl0eURlYXRoKHRhcmdldCwgc291cmNlLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlckRhbWFnZUVmZmVjdHModGFyZ2V0LCBhY3R1YWxEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSwgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBkYW1hZ2VEZWFsdDtcbiAgfVxuXG4gIHB1YmxpYyBoZWFsSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBhbW91bnQ6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWxpbmdEb25lO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBpc0VudGl0eURlYWQoZW50aXR5OiBFbnRpdHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5pc0RlYWQgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbnRpdHlIZWFsdGhSYXRpbyhlbnRpdHk6IEVudGl0eSk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSA6IDA7XG4gIH1cblxuICBwdWJsaWMgY2FuRW50aXR5VGFrZURhbWFnZShlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gKCFoZWFsdGguaXNEZWFkICYmICFoZWFsdGguaXNJbnZ1bG5lcmFibGUpIDogZmFsc2U7XG4gIH1cblxuICAvLyBTdGF0aXN0aWNzIGFuZCBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldENvbWJhdFN0YXRzKCk6IHtcbiAgICB0b3RhbERhbWFnZURlYWx0OiBudW1iZXI7XG4gICAgdG90YWxIZWFsaW5nRG9uZTogbnVtYmVyO1xuICAgIGVuZW1pZXNLaWxsZWQ6IG51bWJlcjtcbiAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IG51bWJlcjtcbiAgICBxdWV1ZWRIZWFsRXZlbnRzOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbERhbWFnZURlYWx0OiB0aGlzLnRvdGFsRGFtYWdlRGVhbHQsXG4gICAgICB0b3RhbEhlYWxpbmdEb25lOiB0aGlzLnRvdGFsSGVhbGluZ0RvbmUsXG4gICAgICBlbmVtaWVzS2lsbGVkOiB0aGlzLmVuZW1pZXNLaWxsZWQsXG4gICAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoLFxuICAgICAgcXVldWVkSGVhbEV2ZW50czogdGhpcy5oZWFsUXVldWUubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gICAgdGhpcy50b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgICB0aGlzLmVuZW1pZXNLaWxsZWQgPSAwO1xuICB9XG5cbiAgLy8gRGFtYWdlIG51bWJlcnMgbWFuYWdlbWVudFxuICBwdWJsaWMgZ2V0RGFtYWdlTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmdldERhbWFnZU51bWJlcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVEYW1hZ2VOdW1iZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5yZW1vdmVEYW1hZ2VOdW1iZXIoaWQpO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRTdGF0cygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzeW5jaHJvbml6ZUVuZW15RGVidWZmc1dpdGhNb3ZlbWVudChlbnRpdHk6IEVudGl0eSwgZW5lbXk6IEVuZW15KTogdm9pZCB7XG4gICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAoIW1vdmVtZW50KSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGVmZmVjdGl2ZSBtb3ZlbWVudCBzcGVlZCBtdWx0aXBsaWVyIGJhc2VkIG9uIGVuZW15IGRlYnVmZnNcbiAgICBsZXQgc3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuXG4gICAgLy8gQXBwbHkgY29ycnVwdGVkIGRlYnVmZiBzbG93IGVmZmVjdFxuICAgIGlmIChlbmVteS5pc0NvcnJ1cHRlZCkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIGVuZW15LmNvcnJ1cHRlZFN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgc2xvdyBwZXJjZW50YWdlIGJhc2VkIG9uIGdyYWR1YWwgcmVjb3ZlcnlcbiAgICAgIC8vIEluaXRpYWw6IDkwJSBzbG93LCByZWNvdmVycyAxMCUgcGVyIHNlY29uZFxuICAgICAgY29uc3QgY3VycmVudFNsb3dQZXJjZW50ID0gTWF0aC5tYXgoMCwgZW5lbXkuY29ycnVwdGVkSW5pdGlhbFNsb3dQZXJjZW50IC0gKGVsYXBzZWQgKiBlbmVteS5jb3JydXB0ZWRSZWNvdmVyeVJhdGUpKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdGhlIHNsb3cgZWZmZWN0IChyZWR1Y2Ugc3BlZWQgYnkgdGhlIHNsb3cgcGVyY2VudGFnZSlcbiAgICAgIHNwZWVkTXVsdGlwbGllciAqPSAoMSAtIGN1cnJlbnRTbG93UGVyY2VudCk7XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIGNvcnJ1cHRlZCBkZWJ1ZmYgKG9ubHkgbG9nIG9jY2FzaW9uYWxseSB0byBhdm9pZCBzcGFtKVxuICAgICAgY29uc3QgbG9nSW50ZXJ2YWwgPSAxLjA7IC8vIExvZyBldmVyeSBzZWNvbmRcbiAgICAgIGlmIChlbGFwc2VkICUgbG9nSW50ZXJ2YWwgPCAwLjEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfkbsgQ29ycnVwdGVkIGRlYnVmZiBvbiAke2VuZW15LmdldERpc3BsYXlOYW1lKCl9OiAkeyhjdXJyZW50U2xvd1BlcmNlbnQgKiAxMDApLnRvRml4ZWQoMSl9JSBzbG93ICgkeyhzcGVlZE11bHRpcGxpZXIgKiAxMDApLnRvRml4ZWQoMSl9JSBzcGVlZCByZW1haW5pbmcpYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSB1cGRhdGUgdGhlIG1vdmVtZW50IHNwZWVkIG11bHRpcGxpZXIgaWYgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZVxuICAgIC8vIFRoaXMgcHJldmVudHMgb3ZlcnJpZGluZyBvdGhlciBlZmZlY3RzIHVubmVjZXNzYXJpbHlcbiAgICBpZiAoTWF0aC5hYnMobW92ZW1lbnQubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgLSBzcGVlZE11bHRpcGxpZXIpID4gMC4wMSkge1xuICAgICAgbW92ZW1lbnQubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSBzcGVlZE11bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgdG8gbm9ybWFsIHNwZWVkIGlmIG5vIGRlYnVmZnMgYXJlIGFjdGl2ZVxuICAgIGlmICghZW5lbXkuaXNDb3JydXB0ZWQgJiYgbW92ZW1lbnQubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgIT09IDEuMCkge1xuICAgICAgLy8gT25seSByZXNldCBpZiBubyBvdGhlciBzeXN0ZW1zIGFyZSBtYW5hZ2luZyB0aGUgc3BlZWQgbXVsdGlwbGllclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBtaWdodCBiZSBmcm9tIGFub3RoZXIgZGVidWZmIHN5c3RlbSAobGlrZSBDb3JydXB0ZWQgQXVyYSlcbiAgICAgIGNvbnN0IHdhc1Nsb3dlZEJ5T3RoZXJFZmZlY3QgPSBtb3ZlbWVudC5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA8IDEuMDtcbiAgICAgIGlmICghd2FzU2xvd2VkQnlPdGhlckVmZmVjdCB8fCBtb3ZlbWVudC5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9PT0gMC4xKSB7IC8vIDAuMSBpcyB0eXBpY2FsIGNvcnJ1cHRlZCBzbG93IHZhbHVlXG4gICAgICAgIG1vdmVtZW50Lm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlN5c3RlbSIsIkhlYWx0aCIsIlNoaWVsZCIsIkVuZW15IiwiVHJhbnNmb3JtIiwiUmVuZGVyZXIiLCJNb3ZlbWVudCIsImNhbGN1bGF0ZURhbWFnZSIsIkRhbWFnZU51bWJlck1hbmFnZXIiLCJTdW1tb25lZFVuaXQiLCJQcm9qZWN0aWxlIiwiQ29tYmF0U3lzdGVtIiwic2hvdWxkTG9nRGFtYWdlIiwibm93IiwiRGF0ZSIsImxhc3REYW1hZ2VMb2dUaW1lIiwiZGFtYWdlTG9nVGhyb3R0bGUiLCJzZXRFbmVteURhbWFnZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvbkVuZW15RGFtYWdlQ2FsbGJhY2siLCJzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayIsIm9uUGxheWVyRGFtYWdlQ2FsbGJhY2siLCJzZXRTdW1tb25lZFVuaXREYW1hZ2VDYWxsYmFjayIsIm9uU3VtbW9uZWRVbml0RGFtYWdlQ2FsbGJhY2siLCJhcHBseVN1bW1vbmVkVW5pdERhbWFnZSIsInVuaXRJZCIsImRhbWFnZSIsInNvdXJjZVBsYXllcklkIiwidW5pdEVudGl0eSIsIndvcmxkIiwiZ2V0RW50aXR5IiwicGFyc2VJbnQiLCJjb25zb2xlIiwid2FybiIsImhlYWx0aCIsImdldENvbXBvbmVudCIsInN1bW1vbmVkVW5pdENvbXBvbmVudCIsImN1cnJlbnRUaW1lIiwiZGFtYWdlRGVhbHQiLCJ0YWtlRGFtYWdlIiwibG9nIiwiY3VycmVudEhlYWx0aCIsIm1heEhlYWx0aCIsImlzRGVhZCIsImhhbmRsZUVudGl0eURlYXRoIiwidW5kZWZpbmVkIiwidHJpZ2dlckRhbWFnZUVmZmVjdHMiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsInVwZGF0ZUhlYWx0aENvbXBvbmVudHMiLCJwcm9jZXNzRGFtYWdlUXVldWUiLCJwcm9jZXNzSGVhbFF1ZXVlIiwiaGFuZGxlRGVhdGhBbmRSZXNwYXduIiwiZGFtYWdlTnVtYmVyTWFuYWdlciIsImNsZWFudXAiLCJkYW1hZ2VRdWV1ZSIsImxlbmd0aCIsImhlYWxRdWV1ZSIsImRlYWRFbnRpdGllcyIsImVudGl0eSIsImVuYWJsZWQiLCJzaGllbGQiLCJlbmVteSIsInVwZGF0ZUZyZWV6ZVN0YXR1cyIsInVwZGF0ZUNvcnJ1cHRlZFN0YXR1cyIsInN5bmNocm9uaXplRW5lbXlEZWJ1ZmZzV2l0aE1vdmVtZW50IiwiZGFtYWdlRXZlbnQiLCJhcHBseURhbWFnZSIsImhlYWxFdmVudCIsImFwcGx5SGVhbGluZyIsInRhcmdldCIsImJhc2VEYW1hZ2UiLCJzb3VyY2UiLCJkYW1hZ2VUeXBlIiwicmVxdWlyZSIsInN1bW1vbmVkVW5pdCIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImlkIiwiZGFtYWdlUmVzdWx0IiwiYWN0dWFsRGFtYWdlIiwidG9TdHJpbmciLCJ0cmFuc2Zvcm0iLCJwb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJ5IiwiYWRkRGFtYWdlTnVtYmVyIiwiaXNDcml0aWNhbCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiZ2V0RW50aXR5RGlzcGxheU5hbWUiLCJjcml0VGV4dCIsInByb2plY3RpbGVDb21wb25lbnQiLCJ1c2VyRGF0YSIsInBsYXllcklkIiwic2VydmVyVW5pdElkIiwic2VydmVyVW5pdE93bmVySWQiLCJvd25lcklkIiwic291cmNlU3VtbW9uZWRVbml0Iiwic2hvdWxkU2hvd0RhbWFnZU51bWJlcnMiLCJ4IiwieiIsInRvdGFsRGFtYWdlRGVhbHQiLCJmaW5hbERhbWFnZSIsImNvbnRyb2xTeXN0ZW1SZWYiLCJ3aW5kb3ciLCJjdXJyZW50IiwiY29udHJvbFN5c3RlbSIsImlzRW50cm9waWNCb2x0IiwiZGFtYWdlQm9udXMiLCJhcHBseUJ1cm5pbmdTdGFjayIsImFtb3VudCIsImhlYWxpbmdEb25lIiwiaGVhbCIsInRvdGFsSGVhbGluZ0RvbmUiLCJ0cmlnZ2VySGVhbGluZ0VmZmVjdHMiLCJraWxsZXIiLCJkaWUiLCJlbmVtaWVzS2lsbGVkIiwiYXdhcmRFeHBlcmllbmNlIiwiZXhwZXJpZW5jZVJld2FyZCIsInRyaWdnZXJEZWF0aEVmZmVjdHMiLCJpc0FjdGl2ZSIsInB1c2giLCJjYW5SZXNwYXduTm93IiwicmVzcGF3bkVuZW15IiwicmVzcGF3biIsInJldml2ZSIsInRyaWdnZXJSZXNwYXduRWZmZWN0cyIsInNvdXJjZVJlbmRlcmVyIiwibWVzaCIsImlzQmFycmFnZUFycm93IiwidGFyZ2V0TW92ZW1lbnQiLCJzbG93IiwiZXhwZXJpZW5jZSIsInF1ZXVlRGFtYWdlIiwidGltZXN0YW1wIiwicXVldWVIZWFsaW5nIiwiZGVhbERhbWFnZUltbWVkaWF0ZSIsImhlYWxJbW1lZGlhdGUiLCJpc0VudGl0eURlYWQiLCJnZXRFbnRpdHlIZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiY2FuRW50aXR5VGFrZURhbWFnZSIsImlzSW52dWxuZXJhYmxlIiwiZ2V0Q29tYmF0U3RhdHMiLCJxdWV1ZWREYW1hZ2VFdmVudHMiLCJxdWV1ZWRIZWFsRXZlbnRzIiwicmVzZXRTdGF0cyIsImdldERhbWFnZU51bWJlcnMiLCJyZW1vdmVEYW1hZ2VOdW1iZXIiLCJvbkRpc2FibGUiLCJjbGVhciIsIm1vdmVtZW50Iiwic3BlZWRNdWx0aXBsaWVyIiwiaXNDb3JydXB0ZWQiLCJlbGFwc2VkIiwiY29ycnVwdGVkU3RhcnRUaW1lIiwiY3VycmVudFNsb3dQZXJjZW50IiwiTWF0aCIsIm1heCIsImNvcnJ1cHRlZEluaXRpYWxTbG93UGVyY2VudCIsImNvcnJ1cHRlZFJlY292ZXJ5UmF0ZSIsImxvZ0ludGVydmFsIiwidG9GaXhlZCIsImFicyIsIm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyIiwid2FzU2xvd2VkQnlPdGhlckVmZmVjdCIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/weapons/StunManager */ \"(app-pages-browser)/./src/components/weapons/StunManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        }\n        // Clean up expired Sunder stacks periodically\n        this.cleanupSunderStacks();\n        // Clean up expired Burning stacks periodically\n        this.cleanupBurningStacks();\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only prevent for abilities that truly override movement)\n        // Most abilities should allow movement - only prevent for dashing, charging, and debuffs\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"5\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ARCANE; // Default runeblade subclass\n                this.fireRate = this.runebladeFireRate; // Use runeblade fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to runeblade\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            this.handleRunebladeInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\" Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging && !this.isCrossentropyCharging) {\n            this.performCrossentropyAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.35 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    performCrossentropyAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            const manaConsumed = gameUI.consumeMana(40);\n            if (!manaConsumed) {\n                console.warn(\" CrossentropyBolt: Failed to consume mana - not enough mana?\");\n                return;\n            }\n            console.log(\" CrossentropyBolt: Consumed 40 mana (\".concat(manaBefore, \" -> \").concat(gameUI.getCurrentMana(), \")\"));\n        }\n        this.isCrossentropyCharging = true;\n        this.crossentropyChargeProgress = 0;\n        this.lastCrossentropyTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.crossentropyChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.crossentropyChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCrossentropyBoltAbilityAfterCharge(playerTransform);\n                this.isCrossentropyCharging = false;\n                this.crossentropyChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCrossentropyBoltAbilityAfterCharge(playerTransform) {\n        // Rate limiting was already checked in performCrossentropyAbility()\n        // No need to check again here - we just finished charging\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        var _this_playerEntity_userData;\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            maxDistance: 25,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0,\n            sourcePlayerId: ((_this_playerEntity_userData = this.playerEntity.userData) === null || _this_playerEntity_userData === void 0 ? void 0 : _this_playerEntity_userData.playerId) || \"unknown\"\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        var _this_playerEntity_userData, _this_playerEntity;\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaConsumed = gameUI.consumeMana(10);\n            if (!manaConsumed) {\n                console.warn(\" EntropicBolt: Failed to consume mana despite canCast check\");\n                return;\n            }\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 2,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0,\n            sourcePlayerId: ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : (_this_playerEntity_userData = _this_playerEntity.userData) === null || _this_playerEntity_userData === void 0 ? void 0 : _this_playerEntity_userData.playerId) || \"unknown\"\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaConsumed = gameUI.consumeMana(40);\n            if (!manaConsumed) {\n                console.warn(\" CrossentropyBolt: Failed to consume mana despite canCast check\");\n                return;\n            }\n            console.log(\" Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 2.5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            const manaConsumed = gameUI.consumeMana(20);\n            if (!manaConsumed) {\n                console.warn(\"\\uD83E\\uDE78 Reanimate: Failed to consume mana despite canCast check\");\n                return;\n            }\n            const manaAfter = gameUI.getCurrentMana();\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 30 HP \n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(30); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n            // console.log(` Reanimate healed player for 30 HP. Current health: ${healthComponent.currentHealth}/${healthComponent.maxHealth}`);\n            } else {\n            // console.log(' Reanimate cast successfully but player already at full health');\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            return;\n        }\n        // Check if player has enough mana (50 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaConsumed = gameUI.consumeMana(50);\n            if (!manaConsumed) {\n                console.warn(\" FrostNova: Failed to consume mana despite canCast check\");\n                return;\n            }\n        }\n        this.lastFrostNovaTime = currentTime;\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 20,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        // Get local socket ID to prevent self-targeting\n        const localSocketId = window.localSocketId;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self (local player entity)\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    // CRITICAL FIX: First check if this entity represents the local player\n                    const serverPlayerEntities = window.serverPlayerEntities;\n                    let targetPlayerId = null;\n                    if (serverPlayerEntities && serverPlayerEntities.current) {\n                        serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                            if (localEntityId === entity.id) {\n                                targetPlayerId = playerId;\n                            }\n                        });\n                    }\n                    // NEVER damage or debuff ourselves\n                    if (targetPlayerId && targetPlayerId === localSocketId) {\n                        console.log(\" Skipping Frost Nova on local player \".concat(localSocketId));\n                        return; // Skip this entity completely\n                    }\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity && targetPlayerId) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting freeze effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n        // console.log(` Frost Nova froze ${frozenCount} enemies within ${radius} unit radius`);\n        }\n        if (damagedPlayers > 0) {\n        // console.log(` Frost Nova damaged ${damagedPlayers} players within ${radius} unit radius`);\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 2,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setSkyfallCallback(callback) {\n        this.onSkyfallCallback = callback;\n    }\n    setBackstabCallback(callback) {\n        this.onBackstabCallback = callback;\n    }\n    setSunderCallback(callback) {\n        this.onSunderCallback = callback;\n    }\n    setSmiteCallback(callback) {\n        this.onSmiteCallback = callback;\n    }\n    setDeathGraspCallback(callback) {\n        this.onDeathGraspCallback = callback;\n    }\n    setWraithStrikeCallback(callback) {\n        this.onWraithStrikeCallback = callback;\n    }\n    setConsumeManaCallback(callback) {\n        this.onConsumeManaCallback = callback;\n    }\n    setCheckManaCallback(callback) {\n        this.onCheckManaCallback = callback;\n    }\n    setCreateSabreMistEffectCallback(callback) {\n        this.onCreateSabreMistEffectCallback = callback;\n    }\n    setStealthCallback(callback) {\n        this.onStealthCallback = callback;\n    }\n    setHauntedSoulEffectCallback(callback) {\n        this.onHauntedSoulEffectCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        // Store the original callback\n        const originalCallback = callback;\n        // Create a wrapper callback that also tracks debuffs internally\n        this.onDebuffCallback = (targetEntityId, debuffType, duration, position)=>{\n            // Track the debuff effect internally for stun detection\n            this.trackDebuffEffect(targetEntityId, debuffType, duration);\n            // Call the original callback\n            if (originalCallback) {\n                originalCallback(targetEntityId, debuffType, duration, position);\n            }\n        };\n    }\n    // Internal method to track debuff effects for stun detection\n    trackDebuffEffect(entityId, debuffType, duration) {\n        const currentTime = Date.now();\n        const effect = {\n            debuffType,\n            startTime: currentTime,\n            duration\n        };\n        // Get existing effects for this entity\n        const existingEffects = this.activeDebuffEffects.get(entityId) || [];\n        // Add the new effect\n        existingEffects.push(effect);\n        // Update the map\n        this.activeDebuffEffects.set(entityId, existingEffects);\n        // Schedule cleanup of expired effect\n        setTimeout(()=>{\n            const currentEffects = this.activeDebuffEffects.get(entityId) || [];\n            const filteredEffects = currentEffects.filter((e)=>e !== effect);\n            if (filteredEffects.length === 0) {\n                this.activeDebuffEffects.delete(entityId);\n            } else {\n                this.activeDebuffEffects.set(entityId, filteredEffects);\n            }\n        }, duration);\n    }\n    // Method to check if a player/entity is currently stunned\n    isPlayerStunned(entityId) {\n        const currentTime = Date.now();\n        const effects = this.activeDebuffEffects.get(entityId);\n        if (!effects) return false;\n        // Check if any active effect is a stun effect\n        return effects.some((effect)=>effect.debuffType === \"stunned\" && currentTime - effect.startTime < effect.duration);\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.75; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isCrossentropyChargingActive() {\n        return this.isCrossentropyCharging;\n    }\n    getCrossentropyChargeProgress() {\n        return this.crossentropyChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    isSkyfallActive() {\n        return this.isSkyfalling;\n    }\n    isBackstabActive() {\n        return this.isBackstabbing;\n    }\n    isSunderActive() {\n        return this.isSundering;\n    }\n    isStealthActive() {\n        return this.isStealthing;\n    }\n    isPlayerInvisible() {\n        return this.isInvisible;\n    }\n    isSmiteActive() {\n        return this.isSmiting;\n    }\n    isDeathGraspActive() {\n        return this.isDeathGrasping;\n    }\n    isWraithStrikeActive() {\n        return this.isWraithStriking;\n    }\n    isCorruptedAuraActive() {\n        return this.corruptedAuraActive;\n    }\n    isColossusStrikeActive() {\n        return this.isColossusStriking;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting && !this.isColossusStriking) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting && !this.isColossusStriking) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting && !this.isColossusStriking) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isColossusStriking) {\n            this.performDeflect(playerTransform);\n        }\n        // Handle Colossus Strike ability with 'F' key\n        if (this.inputManager.isKeyPressed(\"f\") && !this.isColossusStriking && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performColossusStrike(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    handleRunebladeInput(playerTransform) {\n        // Handle runeblade melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSmiting && !this.isDeathGrasping && !this.isWraithStriking) {\n            this.performRunebladeMeleeAttack(playerTransform);\n        }\n        // Handle Smite ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSmiting && !this.isSwinging && !this.isDeathGrasping && !this.isWraithStriking) {\n            this.performSmite(playerTransform);\n        }\n        // Handle DeathGrasp ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeathGrasping && !this.isSmiting && !this.isSwinging && !this.isWraithStriking) {\n            this.performDeathGrasp(playerTransform);\n        }\n        // Handle Corrupted Aura ability with 'R' key (just pressed detection)\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isSmiting && !this.isSwinging && !this.isDeathGrasping && !this.isWraithStriking) {\n            // Track if R key was just pressed (not held down)\n            if (!this.rKeyWasPressed) {\n                this.toggleCorruptedAura(playerTransform);\n                this.rKeyWasPressed = true;\n            }\n        } else {\n            // Reset the just pressed flag when R key is released\n            this.rKeyWasPressed = false;\n        }\n        // Handle WraithStrike ability with 'F' key\n        if (this.inputManager.isKeyPressed(\"f\") && !this.isWraithStriking && !this.isSmiting && !this.isSwinging && !this.isDeathGrasping) {\n            this.performWraithStrike(playerTransform);\n        }\n        // Handle Corrupted Aura effects while active\n        if (this.corruptedAuraActive) {\n            this.updateCorruptedAuraEffects(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    performRunebladeMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use runeblade-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.runebladeFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by runeblade component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (same as sword)\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    performSmite(playerTransform) {\n        // Check if using Runeblade\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSmiteTime < this.smiteCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already smiting\n        if (this.isSmiting) {\n            return;\n        }\n        // Check if player has enough mana (35 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastSmite()) {\n            console.log(\" Smite: Not enough mana to cast (need 35)\");\n            return;\n        }\n        this.lastSmiteTime = currentTime;\n        this.isSmiting = true;\n        // Stop player movement immediately when casting Smite\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                playerMovement.velocity.x = 0;\n                playerMovement.velocity.z = 0;\n                playerMovement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n            }\n        }\n        // Consume mana (35 mana)\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            const manaConsumed = gameUI.consumeMana(35);\n            if (!manaConsumed) {\n                console.warn(\" Smite: Failed to consume mana despite canCast check\");\n                return;\n            }\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\" Smite: Consumed 35 mana. Mana: \".concat(manaBefore, \" -> \").concat(manaAfter));\n        }\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Offset the smite position slightly forward to look like it's coming from the runeblade swing\n        const smitePosition = position.clone().add(direction.clone().multiplyScalar(2.5));\n        // NOTE: Damage detection is now handled by the Smite visual component\n        // to prevent double damage. The visual component's damage detection is more\n        // accurate and properly timed with the animation.\n        // The healing will be triggered by the visual component's onDamageDealt callback\n        // instead of the ControlSystem's performSmiteDamage method.\n        console.log(\" Smite: Damage detection delegated to visual component\");\n        // Trigger smite callback with healing callback\n        if (this.onSmiteCallback) {\n            this.onSmiteCallback(smitePosition, direction, (damageDealtFlag)=>{\n                // Handle healing when damage is dealt by the visual component\n                if (damageDealtFlag) {\n                    console.log(\" Smite: Damage detected by visual component, triggering healing\");\n                    this.performSmiteHealing();\n                }\n            });\n        }\n        // Reset smiting state after animation duration (same as the Smite component)\n        setTimeout(()=>{\n            this.isSmiting = false;\n        }, 900); // 0.9 seconds matches the animation duration\n    }\n    performSmiteDamage(smitePosition) {\n        if (!this.playerEntity) return false;\n        const smiteDamage = 80;\n        const damageRadius = 3.0; // Small radius around impact location\n        let damageDealt = false;\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return; // Don't damage self\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            const distance = smitePosition.distanceTo(entityTransform.position);\n            if (distance <= damageRadius) {\n                // Entity is within damage radius - apply damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem && this.playerEntity) {\n                    combatSystem.queueDamage(entity, smiteDamage, this.playerEntity, \"smite\");\n                    damageDealt = true;\n                    console.log(\" Smite dealt \".concat(smiteDamage, \" damage to entity \").concat(entity.id, \" at distance \").concat(distance.toFixed(2)));\n                } else {\n                    console.log(\" Smite: Could not find CombatSystem or playerEntity to deal damage\");\n                }\n            }\n        });\n        // NOTE: PVP player damage detection is now handled by the Smite visual component\n        // to prevent double damage. The visual component properly handles PVP damage\n        // through the broadcastPlayerDamage system.\n        return damageDealt;\n    }\n    performSmiteHealing() {\n        if (!this.playerEntity) {\n            console.log(\" Smite: No player entity available for healing\");\n            return;\n        }\n        // Get player's health component and heal for 20 HP (like Reanimate ability)\n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const oldHealth = healthComponent.currentHealth;\n            const maxHealth = healthComponent.maxHealth;\n            // Always attempt to heal, even if at full health (heal method handles this)\n            const didHeal = healthComponent.heal(40); // Smite healing amount\n            if (didHeal) {\n                console.log(\" Smite SUCCESSFULLY healed player for 20 HP! Health: \".concat(oldHealth, \" -> \").concat(healthComponent.currentHealth, \"/\").concat(maxHealth));\n            } else {\n                console.log(\" Smite: Player already at full health (\".concat(healthComponent.currentHealth, \"/\").concat(maxHealth, \") - no healing needed\"));\n            }\n        } else {\n            console.log(\" Smite: CRITICAL ERROR - Could not find health component for player entity \".concat(this.playerEntity.id));\n            // Fallback: Try to heal through gameUI if health component is not available\n            try {\n                const gameUI = window.gameUI;\n                if (gameUI && typeof gameUI.gainHealth === \"function\") {\n                    gameUI.gainHealth(40);\n                    console.log(\" Smite: FALLBACK healing through gameUI - healed for 20 HP\");\n                }\n            } catch (error) {\n                console.log(\" Smite: Could not heal through fallback method either\");\n            }\n        }\n    }\n    performDeathGrasp(playerTransform) {\n        // Check if using Runeblade\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeathGraspTime < this.deathGraspCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already death grasping\n        if (this.isDeathGrasping) {\n            return;\n        }\n        // Check if player has enough mana (25 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDeathGrasp()) {\n            console.log(\"\\uD83D\\uDC80 DeathGrasp: Not enough mana to cast (need 25)\");\n            return;\n        }\n        this.lastDeathGraspTime = currentTime;\n        this.isDeathGrasping = true;\n        // Stop player movement immediately when casting Death Grasp\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                playerMovement.velocity.x = 0;\n                playerMovement.velocity.z = 0;\n                playerMovement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n            }\n        }\n        // Consume mana (25 mana)\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            const manaConsumed = gameUI.consumeMana(25);\n            if (!manaConsumed) {\n                console.warn(\"\\uD83D\\uDC80 DeathGrasp: Failed to consume mana despite canCast check\");\n                return;\n            }\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"\\uD83D\\uDC80 DeathGrasp: Consumed 25 mana. Mana: \".concat(manaBefore, \" -> \").concat(manaAfter));\n        }\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger death grasp callback\n        if (this.onDeathGraspCallback) {\n            this.onDeathGraspCallback(position, direction);\n        }\n        // Reset death grasping state after animation duration\n        setTimeout(()=>{\n            this.isDeathGrasping = false;\n        }, 1200); // 1.2 seconds matches the animation duration\n    }\n    performWraithStrike(playerTransform) {\n        // Check if using Runeblade\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastWraithStrikeTime < this.wraithStrikeCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already wraith striking\n        if (this.isWraithStriking) {\n            return;\n        }\n        // Check if player has enough mana (30 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastWraithStrike()) {\n            console.log(\"\\uD83D\\uDC7B WraithStrike: Not enough mana to cast (need 30)\");\n            return;\n        }\n        this.lastWraithStrikeTime = currentTime;\n        this.isWraithStriking = true;\n        // Stop player movement immediately when casting Wraith Strike\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                playerMovement.velocity.x = 0;\n                playerMovement.velocity.z = 0;\n                playerMovement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n            }\n        }\n        // Consume mana (30 mana)\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            const manaConsumed = gameUI.consumeMana(30);\n            if (!manaConsumed) {\n                console.warn(\"\\uD83D\\uDC7B WraithStrike: Failed to consume mana despite canCast check\");\n                return;\n            }\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"\\uD83D\\uDC7B WraithStrike: Consumed 30 mana. Mana: \".concat(manaBefore, \" -> \").concat(manaAfter));\n        }\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Perform wraith strike damage and apply corrupted debuff\n        this.performWraithStrikeDamage(playerTransform);\n        // Trigger wraith strike callback\n        if (this.onWraithStrikeCallback) {\n            this.onWraithStrikeCallback(position, direction);\n        }\n        // Reset wraith striking state after animation duration (same as 2nd swing)\n        setTimeout(()=>{\n            this.isWraithStriking = false;\n        }, 750); // 0.75 seconds matches the 2nd swing animation duration\n    }\n    performWraithStrikeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const wraithStrikeRange = 4.5; // Same range as melee attacks\n        const wraithStrikeAngle = Math.PI / 2; // 90 degree cone\n        const wraithStrikeDamage = 100; // High damage for wraith strike\n        let hitCount = 0;\n        const currentTime = Date.now() / 1000;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > wraithStrikeRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(wraithStrikeAngle / 2);\n            if (dotProduct < angleThreshold) continue;\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, wraithStrikeDamage, this.playerEntity, \"wraith_strike\");\n                hitCount++;\n                // Apply Corrupted debuff\n                this.applyCorruptedDebuff(entity, targetTransform.position, currentTime);\n            }\n        }\n        console.log(\"\\uD83D\\uDC7B WraithStrike hit \".concat(hitCount, \" targets\"));\n    }\n    applyCorruptedDebuff(entity, position, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n        if (enemy) {\n            // This is an enemy - apply corrupted debuff directly\n            enemy.applyCorrupted(8.0, currentTime); // 8 second duration\n            // Trigger haunted soul visual effect\n            this.triggerHauntedSoulEffect(position);\n        } else {\n            // This is likely another player in PVP mode - broadcast corrupted debuff\n            const localSocketId = window.localSocketId;\n            const serverPlayerEntities = window.serverPlayerEntities;\n            let targetPlayerId = null;\n            if (serverPlayerEntities && serverPlayerEntities.current) {\n                serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                    if (localEntityId === entity.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n            }\n            // NEVER broadcast debuff to ourselves\n            if (targetPlayerId && targetPlayerId !== localSocketId) {\n                // Broadcast corrupted effect to the target player\n                if (this.onDebuffCallback) {\n                    console.log(\"\\uD83D\\uDC7B Broadcasting corrupted effect to player \".concat(targetPlayerId));\n                    this.onDebuffCallback(entity.id, \"corrupted\", 8000, position); // 8 seconds in milliseconds\n                }\n                // Trigger haunted soul visual effect\n                this.triggerHauntedSoulEffect(position);\n            }\n        }\n    }\n    triggerHauntedSoulEffect(position) {\n        // Trigger haunted soul visual effect through callback\n        console.log(\"\\uD83D\\uDC7B Triggering haunted soul effect at position: \".concat(position.x, \", \").concat(position.y, \", \").concat(position.z));\n        // Call the haunted soul effect callback if available\n        if (this.onHauntedSoulEffectCallback) {\n            this.onHauntedSoulEffectCallback(position);\n        }\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n    }\n    // Called by runeblade component when smite animation completes\n    onSmiteComplete() {\n        if (!this.isSmiting) return; // Prevent multiple calls\n        // Reset smiting state\n        this.isSmiting = false;\n    }\n    // Called by runeblade component when death grasp animation completes\n    onDeathGraspComplete() {\n        if (!this.isDeathGrasping) return; // Prevent multiple calls\n        // Reset death grasping state\n        this.isDeathGrasping = false;\n    }\n    // Called by runeblade component when wraith strike animation completes\n    onWraithStrikeComplete() {\n        if (!this.isWraithStriking) return; // Prevent multiple calls\n        // Reset wraith striking state\n        this.isWraithStriking = false;\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n        // Handle Q key for Backstab ability\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performBackstab(playerTransform);\n        }\n        // Handle E key for Sunder ability\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSunder(playerTransform);\n        }\n        // Handle R key for Skyfall ability (switched from E)\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isSkyfalling && !this.isSundering) {\n            this.performSkyfall(playerTransform);\n        }\n        // Handle F key for Stealth ability\n        if (this.inputManager.isKeyPressed(\"f\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering && !this.isBackstabbing && !this.isStealthing) {\n            this.performStealth(playerTransform);\n        }\n        // Update Skyfall state if active\n        if (this.isSkyfalling) {\n            this.updateSkyfallMovement(playerTransform);\n        }\n        // Update Backstab state if active\n        if (this.isBackstabbing) {\n            this.updateBackstabState(playerTransform);\n        }\n        // Update Sunder state if active\n        if (this.isSundering) {\n            this.updateSunderState(playerTransform);\n        }\n        // Update Stealth state if active\n        if (this.isStealthing) {\n            this.updateStealthState(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\" Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\" Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 3.8; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19;\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n            }\n        }\n    }\n    // Skyfall ability implementation\n    performSkyfall(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSkyfallTime < this.skyfallCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSkyfall()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(40);\n        // Start Skyfall\n        this.isSkyfalling = true;\n        this.skyfallPhase = \"ascending\";\n        this.skyfallStartTime = currentTime;\n        this.lastSkyfallTime = currentTime;\n        this.skyfallStartPosition.copy(playerTransform.position);\n        // Set target height (double jump height)\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            this.skyfallOriginalGravity = playerMovement.gravity;\n            this.skyfallTargetHeight = playerTransform.position.y + playerMovement.jumpForce * 1.4; // Reduced height by 30% (was 2x, now 1.4x)\n            // Apply upward velocity\n            playerMovement.velocity.y = playerMovement.jumpForce * 2; // Stronger initial velocity\n            playerMovement.gravity = 0; // Disable gravity during ascent\n        // Don't disable canMove as it prevents all physics updates including gravity\n        // Instead we'll control horizontal movement in the ControlSystem\n        }\n        // Trigger callback for multiplayer/visual effects\n        if (this.onSkyfallCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onSkyfallCallback(playerTransform.position, direction);\n        }\n        // Create Sabre Reaper Mist effect at player position\n        if (this.onCreateSabreMistEffectCallback) {\n            console.log(\"\\uD83C\\uDFAF Skyfall: Calling Sabre Reaper Mist effect callback at position:\", playerTransform.position);\n            this.onCreateSabreMistEffectCallback(playerTransform.position.clone());\n        } else {\n            console.log(\" Skyfall: Sabre Reaper Mist effect callback not set!\");\n        }\n    }\n    updateSkyfallMovement(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerMovement) return;\n        const elapsedTime = currentTime - this.skyfallStartTime;\n        switch(this.skyfallPhase){\n            case \"ascending\":\n                // Check if we've reached target height or started falling\n                if (playerTransform.position.y >= this.skyfallTargetHeight || playerMovement.velocity.y <= 0) {\n                    this.skyfallPhase = \"descending\";\n                    playerMovement.velocity.y = 0; // Stop at peak\n                    playerMovement.gravity = this.skyfallOriginalGravity * 30; // Faster descent\n                }\n                break;\n            case \"descending\":\n                // Check if we've landed (close to original height or on ground)\n                if (playerTransform.position.y <= this.skyfallStartPosition.y + 0.5) {\n                    this.skyfallPhase = \"landing\";\n                    this.performSkyfallLanding(playerTransform);\n                }\n                break;\n            case \"landing\":\n                // Landing phase complete\n                this.completeSkyfallAbility(playerTransform);\n                break;\n        }\n        // Safety timeout (if something goes wrong, end after 5 seconds)\n        if (elapsedTime > 4.0) {\n            this.completeSkyfallAbility(playerTransform);\n        }\n    }\n    performSkyfallLanding(playerTransform) {\n        const currentTime = Date.now() / 1000; // Define currentTime for stun effects\n        // Deal damage to enemies in landing area\n        const allEntities = this.world.getAllEntities();\n        const landingPosition = playerTransform.position;\n        const damageRadius = 4.0; // 4 unit radius\n        const skyfallDamage = 125; // 125 damage as requested\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check distance to landing position\n            const distanceToLanding = landingPosition.distanceTo(targetTransform.position);\n            if (distanceToLanding <= damageRadius) {\n                // Apply Skyfall damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem) {\n                    combatSystem.queueDamage(entity, skyfallDamage, this.playerEntity || undefined);\n                    hitCount++;\n                    // Apply stun effect (2 seconds) to enemies hit by Skyfall\n                    const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                    if (enemy) {\n                        // This is an enemy - stun it\n                        enemy.freeze(2.0, currentTime); // 2 second stun using freeze mechanics\n                    } else {\n                        // This is likely another player in PVP mode - apply stun debuff\n                        // CRITICAL FIX: Check if we're about to target ourselves before broadcasting debuff\n                        const localSocketId = window.localSocketId;\n                        const serverPlayerEntities = window.serverPlayerEntities;\n                        let targetPlayerId = null;\n                        if (serverPlayerEntities && serverPlayerEntities.current) {\n                            serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                                if (localEntityId === entity.id) {\n                                    targetPlayerId = playerId;\n                                }\n                            });\n                        }\n                        // NEVER broadcast debuff to ourselves\n                        if (targetPlayerId && targetPlayerId !== localSocketId) {\n                            // Broadcast stun effect to the target player\n                            if (this.onDebuffCallback) {\n                                this.onDebuffCallback(entity.id, \"stunned\", 2000, targetTransform.position);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    completeSkyfallAbility(playerTransform) {\n        var _this_playerEntity;\n        // Reset all Skyfall states\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        // Restore player movement\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            playerMovement.gravity = this.skyfallOriginalGravity;\n            playerMovement.velocity.y = 0; // Stop any remaining vertical movement\n        }\n    }\n    updateBackstabState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.backstabStartTime;\n        // Check if backstab animation duration has elapsed\n        if (elapsedTime >= this.backstabDuration) {\n            this.isBackstabbing = false;\n        }\n    }\n    // Sunder ability implementation\n    performSunder(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSunderTime < this.sunderCooldown) {\n            return;\n        }\n        // Check energy cost (35 energy)\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSunder()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(35);\n        // Set cooldown\n        this.lastSunderTime = currentTime;\n        // Start sunder animation (same as backstab)\n        this.isSundering = true;\n        this.sunderStartTime = currentTime;\n        // Perform sunder damage with stacking logic\n        this.performSunderDamage(playerTransform);\n    }\n    updateSunderState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.sunderStartTime;\n        // Check if sunder animation duration has elapsed\n        if (elapsedTime >= this.sunderDuration) {\n            this.isSundering = false;\n        }\n    }\n    performSunderDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const sunderRange = 3.5; // Same range as backstab\n        let hitCount = 0;\n        const currentTime = Date.now() / 1000;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > sunderRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 4); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Apply Sunder stacks and calculate damage\n            const { damage, stackCount, isStunned } = this.applySunderStack(entity.id, currentTime);\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"sunder\");\n                // Apply stun effect if at 3 stacks\n                if (isStunned) {\n                    const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                    if (enemy) {\n                        enemy.freeze(4.0, currentTime); // 4 second stun (using freeze mechanics for movement)\n                        // Add visual stun effect (different from freeze)\n                        (0,_components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__.addGlobalStunnedEnemy)(entity.id.toString(), targetTransform.position);\n                    }\n                    // Broadcast stun effect for PVP (using new 'stunned' type)\n                    // CRITICAL FIX: Check if we're about to target ourselves before broadcasting debuff\n                    if (this.onDebuffCallback) {\n                        const localSocketId = window.localSocketId;\n                        const serverPlayerEntities = window.serverPlayerEntities;\n                        let targetPlayerId = null;\n                        if (serverPlayerEntities && serverPlayerEntities.current) {\n                            serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                                if (localEntityId === entity.id) {\n                                    targetPlayerId = playerId;\n                                }\n                            });\n                        }\n                        // NEVER broadcast debuff to ourselves\n                        if (targetPlayerId && targetPlayerId !== localSocketId) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting stun effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"stunned\", 4000, targetTransform.position);\n                        } else {\n                            console.log(\" Skipping stun broadcast - would target local player \".concat(localSocketId, \" or invalid target \").concat(targetPlayerId));\n                        }\n                    }\n                }\n                hitCount++;\n            }\n            // Trigger callback for multiplayer/visual effects\n            if (this.onSunderCallback) {\n                this.onSunderCallback(playerTransform.position, playerDirection, damage, stackCount);\n            }\n        }\n    }\n    applySunderStack(entityId, currentTime) {\n        const stackDuration = 10.0; // 10 seconds\n        let currentStacks = this.sunderStacks.get(entityId);\n        // Clean up expired stacks or initialize new entry\n        if (!currentStacks || currentTime - currentStacks.lastApplied > stackDuration) {\n            currentStacks = {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            };\n        }\n        // Calculate damage based on current stack count (before adding new stack)\n        const baseDamages = [\n            60,\n            70,\n            80,\n            90\n        ]; // 0, 1, 2, 3 stacks\n        const damage = baseDamages[Math.min(currentStacks.stacks, 3)];\n        let isStunned = false;\n        let newStackCount = currentStacks.stacks;\n        // Apply new stack\n        if (currentStacks.stacks < 3) {\n            newStackCount = currentStacks.stacks + 1;\n            this.sunderStacks.set(entityId, {\n                stacks: newStackCount,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        } else {\n            // At 3 stacks, apply stun and reset to 0 stacks\n            isStunned = true;\n            newStackCount = 0;\n            this.sunderStacks.set(entityId, {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        }\n        return {\n            damage,\n            stackCount: newStackCount,\n            isStunned\n        };\n    }\n    // Apply burning stack and calculate damage bonus\n    applyBurningStack(entityId, currentTime) {\n        let isEntropicBolt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        const stackDuration = 5.0; // 5 seconds\n        const maxStacks = 15; // Maximum 15 stacks\n        let currentStacks = this.burningStacks.get(entityId);\n        // Clean up expired stacks or initialize new entry\n        if (!currentStacks || currentTime - currentStacks.lastApplied > stackDuration) {\n            currentStacks = {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            };\n        }\n        // Calculate damage bonus based on current stack count (before adding new stack)\n        let damageBonus = 0;\n        if (isEntropicBolt) {\n            // Entropic Bolt: +1 damage per stack\n            damageBonus = currentStacks.stacks;\n        } else {\n            // Crossentropy Bolt: +20 damage per stack\n            damageBonus = currentStacks.stacks * 20;\n        }\n        let newStackCount = currentStacks.stacks;\n        // Apply new stack (up to maximum)\n        if (currentStacks.stacks < maxStacks) {\n            newStackCount = currentStacks.stacks + 1;\n            this.burningStacks.set(entityId, {\n                stacks: newStackCount,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        } else {\n            // At max stacks, just refresh the duration\n            this.burningStacks.set(entityId, {\n                stacks: maxStacks,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n            newStackCount = maxStacks;\n        }\n        // Broadcast burning debuff effect in PVP mode\n        if (this.onDebuffCallback && newStackCount > 0) {\n            // Find the entity to get its position\n            const targetEntity = this.world.getEntity(entityId);\n            if (targetEntity) {\n                const transform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                if (transform) {\n                    // Create a position with stack count information\n                    const positionWithStacks = transform.position.clone();\n                    positionWithStacks.stackCount = newStackCount; // Attach stack count to position\n                    this.onDebuffCallback(entityId, \"burning\", stackDuration * 1000, positionWithStacks);\n                }\n            }\n        }\n        return {\n            damageBonus,\n            stackCount: newStackCount\n        };\n    }\n    // Clean up expired Sunder stacks periodically\n    cleanupSunderStacks() {\n        const currentTime = Date.now() / 1000;\n        const stackDuration = 10.0;\n        // Convert to array to avoid iteration issues\n        const entries = Array.from(this.sunderStacks.entries());\n        for (const [entityId, stackData] of entries){\n            if (currentTime - stackData.lastApplied > stackDuration) {\n                this.sunderStacks.delete(entityId);\n            }\n        }\n    }\n    // Clean up expired Burning stacks periodically\n    cleanupBurningStacks() {\n        const currentTime = Date.now() / 1000;\n        const stackDuration = 5.0;\n        // Convert to array to avoid iteration issues\n        const entries = Array.from(this.burningStacks.entries());\n        for (const [entityId, stackData] of entries){\n            if (currentTime - stackData.lastApplied > stackDuration) {\n                this.burningStacks.delete(entityId);\n            }\n        }\n    }\n    // Stealth ability implementation\n    performStealth(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastStealthTime < this.stealthCooldown) {\n            return;\n        }\n        // No energy cost for Stealth ability\n        // Set cooldown\n        this.lastStealthTime = currentTime;\n        // Start stealth animation\n        this.isStealthing = true;\n        this.stealthStartTime = currentTime;\n        // Create Sabre Reaper Mist effect at player position\n        if (this.onCreateSabreMistEffectCallback) {\n            this.onCreateSabreMistEffectCallback(playerTransform.position.clone());\n        }\n        // Don't broadcast stealth state immediately - wait for invisibility activation\n        // Schedule invisibility activation after delay\n        setTimeout(()=>{\n            if (this.isStealthing) {\n                this.isInvisible = true;\n                console.log(\"\\uD83E\\uDD77 Stealth: Player is now invisible\");\n                // Broadcast invisibility state to other players\n                this.broadcastStealthState(true);\n            }\n        }, this.stealthDelayDuration * 1000);\n        // Schedule invisibility deactivation with proper cleanup\n        const totalStealthDuration = this.stealthDelayDuration + this.stealthInvisibilityDuration;\n        setTimeout(()=>{\n            if (this.isStealthing) {\n                console.log(\"\\uD83E\\uDD77 Stealth: Duration expired, ending stealth effect\");\n                // Ensure we clean up all stealth states\n                this.isInvisible = false;\n                this.isStealthing = false;\n                this.stealthStartTime = 0;\n                // Force broadcast the visibility state to ensure all clients see the player again\n                this.broadcastStealthState(false);\n                console.log(\"\\uD83E\\uDD77 Stealth: Player is now visible again\");\n            }\n        }, totalStealthDuration * 1000);\n    }\n    updateStealthState(playerTransform) {\n        // Only check if stealth state needs cleanup if we have an active stealth effect\n        if (!this.isStealthing || this.stealthStartTime === 0) {\n            return;\n        }\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.stealthStartTime;\n        const totalStealthDuration = this.stealthDelayDuration + this.stealthInvisibilityDuration;\n        // Only clean up if the setTimeout might have failed for some reason\n        // This is a safety net, not the primary cleanup mechanism\n        if (elapsedTime >= totalStealthDuration + 1.0) {\n            console.log(\"\\uD83E\\uDD77 Stealth: Safety cleanup triggered - setTimeout may have failed\");\n            this.isStealthing = false;\n            this.isInvisible = false;\n            this.stealthStartTime = 0;\n            // Emergency broadcast in case the normal broadcast failed\n            this.broadcastStealthState(false);\n        }\n    }\n    broadcastStealthState(isInvisible) {\n        console.log(\"\\uD83E\\uDD77 Broadcasting stealth state: \".concat(isInvisible ? \"invisible\" : \"visible\"));\n        // Broadcast stealth state through the multiplayer system\n        const multiplayerContext = window.multiplayerContext;\n        if (multiplayerContext && multiplayerContext.broadcastPlayerStealth) {\n            multiplayerContext.broadcastPlayerStealth(isInvisible);\n        } else {\n            console.log(\" Multiplayer context not available for stealth broadcast\");\n        }\n    }\n    resetAllAbilityStates() {\n        // Reset all ability states when switching weapons\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.isBackstabbing = false;\n        this.isSundering = false;\n        // Clean up stealth state and ensure visibility is restored\n        if (this.isStealthing || this.isInvisible) {\n            console.log(\"\\uD83E\\uDD77 Stealth: Cleaning up stealth state due to weapon switch\");\n            this.isStealthing = false;\n            this.isInvisible = false;\n            this.stealthStartTime = 0;\n            // Broadcast visibility restoration when switching weapons\n            this.broadcastStealthState(false);\n        }\n        this.isDivineStorming = false;\n        this.isSwordCharging = false;\n        this.isDeflecting = false;\n        this.isColossusStriking = false;\n        this.isWraithStriking = false; // Reset WraithStrike when switching weapons\n        this.corruptedAuraActive = false; // Reset Corrupted Aura when switching weapons\n        // Clear Sunder stacks when switching weapons\n        this.sunderStacks.clear();\n        // Clear Corrupted Aura slowed entities when switching weapons\n        this.corruptedAuraSlowedEntities.clear();\n        // Clear active debuff effects when switching weapons (for stun detection)\n        this.activeDebuffEffects.clear();\n    }\n    toggleCorruptedAura(playerTransform) {\n        // Check if player has enough mana to activate (minimum 8 mana)\n        const gameUI = window.gameUI;\n        if (!this.corruptedAuraActive && gameUI && !gameUI.canCastCorruptedAura()) {\n            return; // Not enough mana to activate\n        }\n        // Toggle the aura\n        this.corruptedAuraActive = !this.corruptedAuraActive;\n        // Reset mana drain timer when activating\n        if (this.corruptedAuraActive) {\n            this.lastManaDrainTime = Date.now() / 1000;\n        } else {\n            // Clear all slowed entities when deactivating\n            this.corruptedAuraSlowedEntities.clear();\n        }\n        // Trigger callback to update visual component\n        if (this.onCorruptedAuraToggleCallback) {\n            this.onCorruptedAuraToggleCallback(this.corruptedAuraActive);\n        }\n    }\n    updateCorruptedAuraEffects(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const playerPosition = playerTransform.position;\n        // Handle mana draining (8 mana per second)\n        if (currentTime - this.lastManaDrainTime >= 1.0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const manaConsumed = gameUI.consumeMana(this.corruptedAuraManaCost);\n                if (!manaConsumed) {\n                    // Not enough mana - deactivate aura\n                    console.log(\"\\uD83D\\uDC80 Corrupted Aura: Not enough mana, deactivating aura\");\n                    this.corruptedAuraActive = false;\n                    this.corruptedAuraSlowedEntities.clear();\n                    if (this.onCorruptedAuraToggleCallback) {\n                        this.onCorruptedAuraToggleCallback(false);\n                    }\n                    return;\n                }\n                this.lastManaDrainTime = currentTime;\n            }\n        }\n        // Apply slow effect to enemies/players within range\n        this.applyCorruptedAuraSlow(playerPosition, currentTime);\n    }\n    applyCorruptedAuraSlow(playerPosition, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return; // Don't slow self\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityMovement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (!entityTransform || !entityMovement) return;\n            const distance = playerPosition.distanceTo(entityTransform.position);\n            const isInRange = distance <= this.corruptedAuraRange;\n            const wasSlowed = this.corruptedAuraSlowedEntities.get(entity.id) || false;\n            if (isInRange && !wasSlowed) {\n                // Entity just entered range - apply slow\n                entityMovement.movementSpeedMultiplier = this.corruptedAuraSlowEffect;\n                this.corruptedAuraSlowedEntities.set(entity.id, true);\n            } else if (!isInRange && wasSlowed) {\n                // Entity just left range - remove slow\n                entityMovement.movementSpeedMultiplier = 1.0;\n                this.corruptedAuraSlowedEntities.delete(entity.id);\n            }\n        });\n    }\n    setCorruptedAuraToggleCallback(callback) {\n        this.onCorruptedAuraToggleCallback = callback;\n    }\n    setColossusStrikeCallback(callback) {\n        this.onColossusStrikeCallback = callback;\n    }\n    // Backstab ability implementation\n    performBackstab(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastBackstabTime < this.backstabCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastBackstab()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(60);\n        // Set cooldown\n        this.lastBackstabTime = currentTime;\n        // Start backstab animation\n        this.isBackstabbing = true;\n        this.backstabStartTime = currentTime;\n        // Trigger callback for multiplayer/visual effects\n        if (this.onBackstabCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onBackstabCallback(playerTransform.position, direction, 75, false); // Base damage, not backstab by default\n        }\n        // Perform backstab damage\n        this.performBackstabDamage(playerTransform);\n    }\n    performBackstabDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const backstabRange = 4.25; // Sabre melee range\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > backstabRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 3); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Determine if this is a backstab (attacking from behind the target)\n            let isBackstab = false;\n            let damage = 75; // Base damage\n            // For PVP players, check if we're behind them\n            const pvpPlayers = window.pvpPlayers;\n            const localSocketId = window.localSocketId;\n            if (pvpPlayers && localSocketId) {\n                // Find the target player in PVP players map\n                let targetPlayer = null;\n                for (const [playerId, player] of pvpPlayers){\n                    if (playerId !== localSocketId) {\n                        const playerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(player.position.x, player.position.y, player.position.z);\n                        if (playerPos.distanceTo(targetTransform.position) < 0.5) {\n                            targetPlayer = player;\n                            break;\n                        }\n                    }\n                }\n                if (targetPlayer) {\n                    // Calculate target's facing direction from their rotation\n                    const targetFacingDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(targetPlayer.rotation.y), 0, Math.cos(targetPlayer.rotation.y)).normalize();\n                    // Vector from target to attacker\n                    const attackerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(playerPosition, targetTransform.position).normalize();\n                    // Check if attacker is behind target (dot product < 0 means opposite direction)\n                    const behindDotProduct = targetFacingDirection.dot(attackerDirection);\n                    isBackstab = behindDotProduct < -0.3; // 70 degree cone behind target\n                    if (isBackstab) {\n                        damage = 175; // Backstab damage\n                    }\n                }\n            }\n            // Check if target is stunned (for energy refund)\n            let isTargetStunned = false;\n            // Check for enemy stun status (single player mode)\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n            if (enemy) {\n                // Check if enemy is currently frozen/stunned\n                isTargetStunned = enemy.isFrozen;\n            } else {\n                // Check for PVP player stun status using ControlSystem's internal tracking\n                isTargetStunned = this.isPlayerStunned(entity.id);\n            }\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"backstab\");\n                hitCount++;\n                // Refund energy if target is stunned (60 energy)\n                if (isTargetStunned) {\n                    const gameUI = window.gameUI;\n                    if (gameUI && gameUI.gainEnergy) {\n                        gameUI.gainEnergy(60);\n                    }\n                }\n            }\n        }\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.5; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step and weapon type\n        let baseDamage = 45; // Default base damage\n        // Weapon-specific damage scaling\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            // Sword damage values\n            switch(this.swordComboStep){\n                case 1:\n                    baseDamage = 40;\n                    break;\n                case 2:\n                    baseDamage = 45;\n                    break;\n                case 3:\n                    baseDamage = 55;\n                    break; // Finisher does more damage\n            }\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            // Runeblade damage values\n            switch(this.swordComboStep){\n                case 1:\n                    baseDamage = 30;\n                    break;\n                case 2:\n                    baseDamage = 35;\n                    break;\n                case 3:\n                    baseDamage = 45;\n                    break; // Finisher does more damage\n            }\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        enemiesHit++;\n                    }\n                }\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                // console.warn(`Dash cancelled: would move too far from origin (${distanceFromOrigin.toFixed(2)} > ${MAX_DASH_BOUNDS})`);\n                movement.cancelDash();\n            }\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\" Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 40 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            return;\n        }\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.6;\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            return;\n        }\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n        }\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__.triggerGlobalViperSting)();\n        if (success) {\n        // console.log(' Viper Sting visual effects successfully triggered!');\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\" Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0), left (15, 30), right (-15, -30) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0, 15, -15, 30, -30\n        angles.forEach((angle)=>{\n            var _this_playerEntity_userData, _this_playerEntity;\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                maxDistance: 25,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0,\n                sourcePlayerId: ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : (_this_playerEntity_userData = _this_playerEntity.userData) === null || _this_playerEntity_userData === void 0 ? void 0 : _this_playerEntity_userData.playerId) || \"unknown\"\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    performColossusStrike(playerTransform) {\n        // Check if using Sword\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastColossusStrikeTime < this.colossusStrikeCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already performing Colossus Strike\n        if (this.isColossusStriking) {\n            return;\n        }\n        // Check if player has enough rage (minimum 40 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastColossusStrike()) {\n            console.log(\" Colossus Strike: Not enough rage to cast (need 40)\");\n            return;\n        }\n        this.lastColossusStrikeTime = currentTime;\n        this.isColossusStriking = true;\n        // Stop player movement immediately when casting Colossus Strike\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                playerMovement.velocity.x = 0;\n                playerMovement.velocity.z = 0;\n                playerMovement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n            }\n        }\n        // Get current rage amount and consume ALL rage (like Divine Storm)\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40;\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 40\n        }\n        console.log(\" Colossus Strike: Consumed \".concat(currentRage, \" rage\"));\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Offset the colossus strike position slightly forward to look like it's coming from the sword swing (like Smite)\n        const colossusStrikePosition = position.clone().add(direction.clone().multiplyScalar(2.5));\n        // Trigger colossus strike callback with rage spent\n        if (this.onColossusStrikeCallback) {\n            this.onColossusStrikeCallback(colossusStrikePosition, direction, currentRage);\n        }\n        // Reset colossus striking state after animation duration (same as the Sword component)\n        setTimeout(()=>{\n            this.isColossusStriking = false;\n        }, 900); // 0.9 seconds matches the animation duration\n    }\n    // Called by sword component when Colossus Strike animation completes\n    onColossusStrikeComplete() {\n        if (!this.isColossusStriking) return; // Prevent multiple calls\n        // Reset colossus striking state\n        this.isColossusStriking = false;\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n            cooldowns[\"F\"] = {\n                current: Math.max(0, this.colossusStrikeCooldown - (currentTime - this.lastColossusStrikeTime)),\n                max: this.colossusStrikeCooldown,\n                isActive: this.isColossusStriking\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: this.isCrossentropyCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.backstabCooldown - (currentTime - this.lastBackstabTime)),\n                max: this.backstabCooldown,\n                isActive: this.isBackstabbing\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.sunderCooldown - (currentTime - this.lastSunderTime)),\n                max: this.sunderCooldown,\n                isActive: this.isSundering\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.skyfallCooldown - (currentTime - this.lastSkyfallTime)),\n                max: this.skyfallCooldown,\n                isActive: this.isSkyfalling\n            };\n            cooldowns[\"F\"] = {\n                current: Math.max(0, this.stealthCooldown - (currentTime - this.lastStealthTime)),\n                max: this.stealthCooldown,\n                isActive: this.isStealthing\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            // RUNEBLADE abilities\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deathGraspCooldown - (currentTime - this.lastDeathGraspTime)),\n                max: this.deathGraspCooldown,\n                isActive: this.isDeathGrasping\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.smiteCooldown - (currentTime - this.lastSmiteTime)),\n                max: this.smiteCooldown,\n                isActive: this.isSmiting\n            };\n            cooldowns[\"R\"] = {\n                current: this.corruptedAuraActive ? 0 : 0,\n                max: 1,\n                isActive: this.corruptedAuraActive\n            };\n            cooldowns[\"F\"] = {\n                current: Math.max(0, this.wraithStrikeCooldown - (currentTime - this.lastWraithStrikeTime)),\n                max: this.wraithStrikeCooldown,\n                isActive: this.isWraithStriking\n            };\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.2 // Default for bow\n        ;\n        this.swordFireRate = 0.9 // Rate for sword attacks\n        ;\n        this.runebladeFireRate = 0.75 // Runeblade attack rate\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.35 // EntropicBolt rate (0.33s cooldown)\n        ;\n        this.crossentropyFireRate = 2 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.5 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.0 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Key press tracking for toggle abilities\n        this.rKeyWasPressed = false;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Crossentropy Bolt charging state\n        this.isCrossentropyCharging = false;\n        this.crossentropyChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 1 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 8.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 6.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        // Skyfall ability state (Sabres)\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.lastSkyfallTime = 0;\n        this.skyfallCooldown = 5.0 // 4 second cooldown\n        ;\n        this.skyfallStartTime = 0;\n        this.skyfallStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.skyfallTargetHeight = 0;\n        this.skyfallOriginalGravity = 0;\n        // Backstab ability state (Sabres)\n        this.lastBackstabTime = 0;\n        this.backstabCooldown = 1.5 // 2 second cooldown\n        ;\n        this.isBackstabbing = false;\n        this.backstabStartTime = 0;\n        this.backstabDuration = 1.0 // Total animation duration (0.3 + 0.4 + 0.3 seconds)\n        ;\n        // Sunder ability state (Sabres)\n        this.lastSunderTime = 0;\n        this.sunderCooldown = 1.125 // 1.5 second cooldown\n        ;\n        this.isSundering = false;\n        this.sunderStartTime = 0;\n        this.sunderDuration = 1.0 // Same animation duration as backstab\n        ;\n        // Stealth ability state (Sabres)\n        this.lastStealthTime = 0;\n        this.stealthCooldown = 10.0 // 10 second cooldown\n        ;\n        this.isStealthing = false;\n        this.stealthStartTime = 0;\n        this.stealthDelayDuration = 0.5 // 0.5 second delay before invisibility\n        ;\n        this.stealthInvisibilityDuration = 6.0 // 6 seconds of invisibility\n        ;\n        this.isInvisible = false;\n        // Sunder stack tracking - Map of entity ID to stack data\n        this.sunderStacks = new Map();\n        // Burning stack tracking - Map of entity ID to stack data\n        this.burningStacks = new Map();\n        // Active debuff effects tracking for PVP players - Map of entity ID to debuff data\n        this.activeDebuffEffects = new Map();\n        // Smite ability state (Runeblade)\n        this.lastSmiteTime = 0;\n        this.smiteCooldown = 2.0 // 2 second cooldown\n        ;\n        this.isSmiting = false;\n        // DeathGrasp ability state (Runeblade)\n        this.lastDeathGraspTime = 0;\n        this.deathGraspCooldown = 5.0 // 5 second cooldown\n        ;\n        this.isDeathGrasping = false;\n        // WraithStrike ability state (Runeblade)\n        this.lastWraithStrikeTime = 0;\n        this.wraithStrikeCooldown = 3.0 // 3 second cooldown\n        ;\n        this.isWraithStriking = false;\n        // Corrupted Aura ability state (Runeblade)\n        this.corruptedAuraActive = false;\n        this.lastManaDrainTime = 0;\n        this.corruptedAuraRange = 8.0 // 8 unit range for slow effect\n        ;\n        this.corruptedAuraManaCost = 8 // 8 mana per second\n        ;\n        this.corruptedAuraSlowEffect = 0.5 // 50% slow (multiply movement speed by this)\n        ;\n        this.corruptedAuraSlowedEntities = new Map() // Track slowed entities\n        ;\n        // Colossus Strike ability state (Sword)\n        this.lastColossusStrikeTime = 0;\n        this.colossusStrikeCooldown = 4.0 // 4 second cooldown\n        ;\n        this.isColossusStriking = false;\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 1.5 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEyQztBQUNjO0FBR25CO0FBRWlCO0FBQ0Y7QUFDSjtBQUNGO0FBQ007QUFDQTtBQUlQO0FBQzJCO0FBQ0o7QUFDZ0M7QUFDNUI7QUFDVTtBQUNFO0FBRTlFLE1BQU1rQixzQkFBc0JoQiwrQ0FBTUE7SUFvT2hDaUIsVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsWUFBWSxHQUFHRDtJQUN0QjtJQUVPRSxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNILFlBQVksRUFBRTtRQUV4QixNQUFNSSxrQkFBa0IsSUFBSSxDQUFDSixZQUFZLENBQUNLLFlBQVksQ0FBQ3ZCLGdFQUFTQTtRQUNoRSxNQUFNd0IsaUJBQWlCLElBQUksQ0FBQ04sWUFBWSxDQUFDSyxZQUFZLENBQUN0Qiw4REFBUUE7UUFFOUQsSUFBSSxDQUFDcUIsbUJBQW1CLENBQUNFLGdCQUFnQjtRQUV6Qyw2QkFBNkI7UUFDN0IsSUFBSSxPQUFPQSxlQUFlQyxhQUFhLEtBQUssWUFBWTtZQUN0REQsZUFBZUMsYUFBYTtRQUM5QjtRQUVBLDhDQUE4QztRQUM5QyxJQUFJLENBQUNDLG1CQUFtQjtRQUV4QiwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDQyxvQkFBb0I7UUFFekIsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ0MscUJBQXFCO1FBRTFCLDBEQUEwRDtRQUMxRCxJQUFJLENBQUNDLGtCQUFrQixDQUFDTCxnQkFBZ0JGO1FBRXhDLHNEQUFzRDtRQUN0RCxJQUFJLENBQUNRLG9CQUFvQixDQUFDTixnQkFBZ0JGO1FBRTFDLHlGQUF5RjtRQUN6Rix5RkFBeUY7UUFDekYsSUFBSSxDQUFDRSxlQUFlTyxTQUFTLElBQUksQ0FBQ1AsZUFBZVEsVUFBVSxJQUFJLENBQUNSLGVBQWVTLFFBQVEs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QXVCLElBQUssb0JBQW9COzthQUNoRHpDLG1CQUFtQjtRQUUzQiwyQ0FBMkM7YUFDbkNFLHNCQUFzQjthQUN0QmlKLG9CQUFvQjthQUNwQk0scUJBQXFCLElBQUssK0JBQStCOzthQUN6REosd0JBQXdCLEVBQUcsb0JBQW9COzthQUMvQ08sMEJBQTBCLElBQUssNkNBQTZDOzthQUM1RVgsOEJBQThCLElBQUlzRyxNQUF3Qix3QkFBd0I7O1FBRTFGLHdDQUF3QzthQUNoQzhDLHlCQUF5QjthQUN6QkMseUJBQXlCLElBQUssb0JBQW9COzthQUNsRGxTLHFCQUFxQjthQStIckJwUix1QkFBdUI7YUFDdkJDLHVCQUF1QixJQUFLLDRDQUE0Qzs7UUF1c0ZoRix1REFBdUQ7YUFDdEMwZSxtQkFBbUI7WUFDbEMsSUFBSTFpQix5REFBT0EsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQixJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLE1BQU0sR0FBRztZQUN0QixJQUFJQSx5REFBT0EsQ0FBQyxNQUFNLEdBQUcsS0FBUyxlQUFlO1NBQzlDO2FBQ2dCNmlCLGdCQUFnQixJQUFLLDhCQUE4Qjs7UUEwSXBFLG1GQUFtRjthQUMzRXFCLG9CQUFvQixJQUFJNkQ7YUFDeEJuRywyQkFBMkI7UUFqOUZqQyxJQUFJLENBQUN6ZSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ3dHLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMyQixnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDZ2MsY0FBYyxHQUFHLElBQUlubUIsK0VBQWNBLENBQUN3STtRQUN6QyxJQUFJLENBQUM0ZSxRQUFRLEdBQUcsR0FBRywrQkFBK0I7SUFDcEQ7QUE2akhGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHM/MmMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250cm9sIHN5c3RlbSBmb3IgcGxheWVyIGlucHV0IGhhbmRsaW5nXG5pbXBvcnQgeyBWZWN0b3IzLCBNYXRyaXg0IH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFBlcnNwZWN0aXZlQ2FtZXJhIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcblxuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgSGVhbHRoIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9IZWFsdGgnO1xuaW1wb3J0IHsgRW5lbXkgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0VuZW15JztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5pbXBvcnQgeyBDb2xsaWRlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXInO1xuaW1wb3J0IHsgSW5wdXRNYW5hZ2VyIH0gZnJvbSAnQC9jb3JlL0lucHV0TWFuYWdlcic7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IFByb2plY3RpbGVTeXN0ZW0gfSBmcm9tICcuL1Byb2plY3RpbGVTeXN0ZW0nO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuaW1wb3J0IHsgV2VhcG9uU3ViY2xhc3MsIFdlYXBvblR5cGUgfSBmcm9tICdAL2NvbXBvbmVudHMvZHJhZ29uL3dlYXBvbnMnO1xuaW1wb3J0IHsgRGVmbGVjdEJhcnJpZXIgfSBmcm9tICdAL2NvbXBvbmVudHMvd2VhcG9ucy9EZWZsZWN0QmFycmllcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhLCBhZGRHbG9iYWxGcm96ZW5FbmVteSB9IGZyb20gJ0AvY29tcG9uZW50cy93ZWFwb25zL0Zyb3N0Tm92YU1hbmFnZXInO1xuaW1wb3J0IHsgYWRkR2xvYmFsU3R1bm5lZEVuZW15IH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvU3R1bk1hbmFnZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbENvYnJhU2hvdCB9IGZyb20gJ0AvY29tcG9uZW50cy9wcm9qZWN0aWxlcy9Db2JyYVNob3RNYW5hZ2VyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxWaXBlclN0aW5nIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL1ZpcGVyU3RpbmdNYW5hZ2VyJztcblxuZXhwb3J0IGNsYXNzIENvbnRyb2xTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgTW92ZW1lbnRdO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmE7XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW07XG4gIHByaXZhdGUgcGxheWVyRW50aXR5OiBFbnRpdHkgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBib3cgcmVsZWFzZSBlZmZlY3RzXG4gIHByaXZhdGUgb25Cb3dSZWxlYXNlQ2FsbGJhY2s/OiAoZmluYWxQcm9ncmVzczogbnVtYmVyLCBpc1BlcmZlY3RTaG90PzogYm9vbGVhbikgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBEaXZpbmUgU3Rvcm0gYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRGl2aW5lU3Rvcm1DYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIHByb2plY3RpbGUgY3JlYXRpb25cbiAgcHJpdmF0ZSBvblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2s/OiAocHJvamVjdGlsZVR5cGU6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgY29uZmlnOiBhbnkpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgVmlwZXIgU3RpbmcgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uVmlwZXJTdGluZ0NhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQmFycmFnZSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25CYXJyYWdlQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBSZWFuaW1hdGUgaGVhbGluZyBlZmZlY3RcbiAgcHJpdmF0ZSBvblJlYW5pbWF0ZUNhbGxiYWNrPzogKCkgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBGcm9zdCBOb3ZhIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkZyb3N0Tm92YUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQ29icmEgU2hvdCBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25Db2JyYVNob3RDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIENoYXJnZSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25DaGFyZ2VDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIERlZmxlY3QgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRGVmbGVjdENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgYnJvYWRjYXN0aW5nIGRlYnVmZiBlZmZlY3RzIGluIFBWUFxuICBwcml2YXRlIG9uRGVidWZmQ2FsbGJhY2s/OiAodGFyZ2V0RW50aXR5SWQ6IG51bWJlciwgZGVidWZmVHlwZTogJ2Zyb3plbicgfCAnc2xvd2VkJyB8ICdzdHVubmVkJyB8ICdjb3JydXB0ZWQnIHwgJ2J1cm5pbmcnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBTa3lmYWxsIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNreWZhbGxDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEJhY2tzdGFiIGFiaWxpdHlcbiAgcHJpdmF0ZSBvbkJhY2tzdGFiQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgU3VuZGVyIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblN1bmRlckNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGRhbWFnZTogbnVtYmVyLCBzdGFja0NvdW50OiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIFNtaXRlIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNtaXRlQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgb25EYW1hZ2VEZWFsdD86IChkYW1hZ2VEZWFsdDogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAvLyBDYWxsYmFjayBmb3IgRGVhdGhHcmFzcCBhYmlsaXR5XG4gIHByaXZhdGUgb25EZWF0aEdyYXNwQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcblxuICAvLyBDYWxsYmFjayBmb3IgV3JhaXRoU3RyaWtlIGFiaWxpdHlcbiAgcHJpdmF0ZSBvbldyYWl0aFN0cmlrZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIFJ1bmVibGFkZSBtYW5hIGNvbnN1bXB0aW9uXG4gIHByaXZhdGUgb25Db25zdW1lTWFuYUNhbGxiYWNrPzogKGFtb3VudDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gIC8vIENhbGxiYWNrIGZvciBSdW5lYmxhZGUgbWFuYSBjaGVja2luZ1xuICBwcml2YXRlIG9uQ2hlY2tNYW5hQ2FsbGJhY2s/OiAoYW1vdW50OiBudW1iZXIpID0+IGJvb2xlYW47XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIGNyZWF0aW5nIFNhYnJlIFJlYXBlciBNaXN0IGVmZmVjdFxuICBwcml2YXRlIG9uQ3JlYXRlU2FicmVNaXN0RWZmZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMpID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIFN0ZWFsdGggYWJpbGl0eVxuICBwcml2YXRlIG9uU3RlYWx0aENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBpc0FjdGl2YXRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIEhhdW50ZWQgU291bCBlZmZlY3QgKFdyYWl0aFN0cmlrZSlcbiAgcHJpdmF0ZSBvbkhhdW50ZWRTb3VsRWZmZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMpID0+IHZvaWQ7XG5cbiAgLy8gUmF0ZSBsaW1pdGluZyBmb3IgcHJvamVjdGlsZSBmaXJpbmdcbiAgcHJpdmF0ZSBsYXN0RmlyZVRpbWUgPSAwO1xuICBwcml2YXRlIGxhc3RDcm9zc2VudHJvcHlUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIENyb3NzZW50cm9weUJvbHRcbiAgcHJpdmF0ZSBsYXN0UmVhbmltYXRlVGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBSZWFuaW1hdGUgYWJpbGl0eVxuICBwcml2YXRlIGxhc3RWaXBlclN0aW5nVGltZSA9IDA7XG4gIHByaXZhdGUgbGFzdEZyb3N0Tm92YVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgRnJvc3QgTm92YSBhYmlsaXR5XG4gIHByaXZhdGUgbGFzdENvYnJhU2hvdFRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgQ29icmEgU2hvdCBhYmlsaXR5XG4gIHByaXZhdGUgZmlyZVJhdGUgPSAwLjI7IC8vIERlZmF1bHQgZm9yIGJvd1xuICBwcml2YXRlIHN3b3JkRmlyZVJhdGUgPSAwLjk7IC8vIFJhdGUgZm9yIHN3b3JkIGF0dGFja3NcbiAgcHJpdmF0ZSBydW5lYmxhZGVGaXJlUmF0ZSA9IDAuNzU7IC8vIFJ1bmVibGFkZSBhdHRhY2sgcmF0ZVxuICBwcml2YXRlIHNhYnJlc0ZpcmVSYXRlID0gMC42OyAvLyBTYWJyZXMgZHVhbCBhdHRhY2sgcmF0ZSAoNjAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNjeXRoZUZpcmVSYXRlID0gMC4zNTsgLy8gRW50cm9waWNCb2x0IHJhdGUgKDAuMzNzIGNvb2xkb3duKVxuICBwcml2YXRlIGNyb3NzZW50cm9weUZpcmVSYXRlID0gMjsgLy8gQ3Jvc3NlbnRyb3B5Qm9sdCByYXRlICgxIHBlciBzZWNvbmQpXG4gIHByaXZhdGUgdmlwZXJTdGluZ0ZpcmVSYXRlID0gMi41OyAvLyBWaXBlciBTdGluZyByYXRlICgyIHNlY29uZHMgY29vbGRvd24pXG4gIHByaXZhdGUgZnJvc3ROb3ZhRmlyZVJhdGUgPSAxMi4wOyAvLyBGcm9zdCBOb3ZhIHJhdGUgKDEyIHNlY29uZHMgY29vbGRvd24pXG4gIHByaXZhdGUgY29icmFTaG90RmlyZVJhdGUgPSAyLjA7IC8vIENvYnJhIFNob3QgcmF0ZSAoMiBzZWNvbmRzIGNvb2xkb3duKVxuXG4gIC8vIEtleSBwcmVzcyB0cmFja2luZyBmb3IgdG9nZ2xlIGFiaWxpdGllc1xuICBwcml2YXRlIHJLZXlXYXNQcmVzc2VkID0gZmFsc2U7XG4gIFxuICAvLyBDdXJyZW50IHdlYXBvbiBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgY3VycmVudFdlYXBvbjogV2VhcG9uVHlwZSA9IFdlYXBvblR5cGUuQk9XOyAvLyBEZWZhdWx0IHdlYXBvblxuICBwcml2YXRlIGN1cnJlbnRTdWJjbGFzczogV2VhcG9uU3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5FTEVNRU5UQUw7IC8vIERlZmF1bHQgZm9yIGJvd1xuICBwcml2YXRlIGN1cnJlbnRMZXZlbCA9IDE7XG4gIFxuICAvLyBXZWFwb24tc3BlY2lmaWMgc3RhdGVzXG4gIHByaXZhdGUgaXNDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGNoYXJnZVByb2dyZXNzID0gMDtcbiAgcHJpdmF0ZSBpc1N3aW5naW5nID0gZmFsc2U7XG4gIFxuICAvLyBWaXBlciBTdGluZyBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzVmlwZXJTdGluZ0NoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgdmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gMDtcbiAgXG4gIC8vIEJhcnJhZ2UgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0JhcnJhZ2VDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIHByaXZhdGUgbGFzdEJhcnJhZ2VUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYXJyYWdlRmlyZVJhdGUgPSA1LjA7IC8vIDUgc2Vjb25kIGNvb2xkb3duIChrZWVwaW5nIGFzIHJlcXVlc3RlZClcbiAgXG4gIC8vIENvYnJhIFNob3QgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0NvYnJhU2hvdENoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuXG4gIC8vIENyb3NzZW50cm9weSBCb2x0IGNoYXJnaW5nIHN0YXRlXG4gIHByaXZhdGUgaXNDcm9zc2VudHJvcHlDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGNyb3NzZW50cm9weUNoYXJnZVByb2dyZXNzID0gMDtcbiAgXG4gIC8vIFN3b3JkLXNwZWNpZmljIHN0YXRlc1xuICBwcml2YXRlIHN3b3JkQ29tYm9TdGVwOiAxIHwgMiB8IDMgPSAxO1xuICBwcml2YXRlIGxhc3RTd29yZEF0dGFja1RpbWUgPSAwO1xuICBwcml2YXRlIHN3b3JkQ29tYm9SZXNldFRpbWUgPSAxOyAvLyBSZXNldCBjb21ibyBhZnRlciAxIHNlY29uZHNcbiAgXG4gIC8vIERpdmluZSBTdG9ybSBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNEaXZpbmVTdG9ybWluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3REaXZpbmVTdG9ybVRpbWUgPSAwO1xuICBwcml2YXRlIGRpdmluZVN0b3JtQ29vbGRvd24gPSA4LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIFxuICAvLyBDaGFyZ2UgYWJpbGl0eSBzdGF0ZVxuICBwcml2YXRlIGlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RDaGFyZ2VUaW1lID0gMDtcbiAgcHJpdmF0ZSBjaGFyZ2VDb29sZG93biA9IDguMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgXG4gIC8vIERlZmxlY3QgYWJpbGl0eSBzdGF0ZVxuICBwcml2YXRlIGlzRGVmbGVjdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3REZWZsZWN0VGltZSA9IDA7XG4gIHByaXZhdGUgZGVmbGVjdENvb2xkb3duID0gNi4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGRlZmxlY3REdXJhdGlvbiA9IDMuMDsgLy8gMyBzZWNvbmQgZHVyYXRpb25cbiAgcHJpdmF0ZSBkZWZsZWN0QmFycmllcjogRGVmbGVjdEJhcnJpZXI7XG4gIFxuICAvLyBTa3lmYWxsIGFiaWxpdHkgc3RhdGUgKFNhYnJlcylcbiAgcHJpdmF0ZSBpc1NreWZhbGxpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBza3lmYWxsUGhhc2U6ICdub25lJyB8ICdhc2NlbmRpbmcnIHwgJ2Rlc2NlbmRpbmcnIHwgJ2xhbmRpbmcnID0gJ25vbmUnO1xuICBwcml2YXRlIGxhc3RTa3lmYWxsVGltZSA9IDA7XG4gIHByaXZhdGUgc2t5ZmFsbENvb2xkb3duID0gNS4wOyAvLyA0IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIHNreWZhbGxTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIHNreWZhbGxTdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBza3lmYWxsVGFyZ2V0SGVpZ2h0ID0gMDtcbiAgcHJpdmF0ZSBza3lmYWxsT3JpZ2luYWxHcmF2aXR5ID0gMDtcbiAgXG4gIC8vIEJhY2tzdGFiIGFiaWxpdHkgc3RhdGUgKFNhYnJlcylcbiAgcHJpdmF0ZSBsYXN0QmFja3N0YWJUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYWNrc3RhYkNvb2xkb3duID0gMS41OyAvLyAyIHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzQmFja3N0YWJiaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgYmFja3N0YWJTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIGJhY2tzdGFiRHVyYXRpb24gPSAxLjA7IC8vIFRvdGFsIGFuaW1hdGlvbiBkdXJhdGlvbiAoMC4zICsgMC40ICsgMC4zIHNlY29uZHMpXG4gIFxuICAvLyBTdW5kZXIgYWJpbGl0eSBzdGF0ZSAoU2FicmVzKVxuICBwcml2YXRlIGxhc3RTdW5kZXJUaW1lID0gMDtcbiAgcHJpdmF0ZSBzdW5kZXJDb29sZG93biA9IDEuMTI1OyAvLyAxLjUgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgaXNTdW5kZXJpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdW5kZXJTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIHN1bmRlckR1cmF0aW9uID0gMS4wOyAvLyBTYW1lIGFuaW1hdGlvbiBkdXJhdGlvbiBhcyBiYWNrc3RhYlxuICBcbiAgLy8gU3RlYWx0aCBhYmlsaXR5IHN0YXRlIChTYWJyZXMpXG4gIHByaXZhdGUgbGFzdFN0ZWFsdGhUaW1lID0gMDtcbiAgcHJpdmF0ZSBzdGVhbHRoQ29vbGRvd24gPSAxMC4wOyAvLyAxMCBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBpc1N0ZWFsdGhpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGVhbHRoU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBzdGVhbHRoRGVsYXlEdXJhdGlvbiA9IDAuNTsgLy8gMC41IHNlY29uZCBkZWxheSBiZWZvcmUgaW52aXNpYmlsaXR5XG4gIHByaXZhdGUgc3RlYWx0aEludmlzaWJpbGl0eUR1cmF0aW9uID0gNi4wOyAvLyA2IHNlY29uZHMgb2YgaW52aXNpYmlsaXR5XG4gIHByaXZhdGUgaXNJbnZpc2libGUgPSBmYWxzZTtcbiAgXG4gIC8vIFN1bmRlciBzdGFjayB0cmFja2luZyAtIE1hcCBvZiBlbnRpdHkgSUQgdG8gc3RhY2sgZGF0YVxuICBwcml2YXRlIHN1bmRlclN0YWNrcyA9IG5ldyBNYXA8bnVtYmVyLCB7IHN0YWNrczogbnVtYmVyOyBsYXN0QXBwbGllZDogbnVtYmVyOyBkdXJhdGlvbjogbnVtYmVyIH0+KCk7XG5cbiAgLy8gQnVybmluZyBzdGFjayB0cmFja2luZyAtIE1hcCBvZiBlbnRpdHkgSUQgdG8gc3RhY2sgZGF0YVxuICBwcml2YXRlIGJ1cm5pbmdTdGFja3MgPSBuZXcgTWFwPG51bWJlciwgeyBzdGFja3M6IG51bWJlcjsgbGFzdEFwcGxpZWQ6IG51bWJlcjsgZHVyYXRpb246IG51bWJlciB9PigpO1xuXG4gIC8vIEFjdGl2ZSBkZWJ1ZmYgZWZmZWN0cyB0cmFja2luZyBmb3IgUFZQIHBsYXllcnMgLSBNYXAgb2YgZW50aXR5IElEIHRvIGRlYnVmZiBkYXRhXG4gIHByaXZhdGUgYWN0aXZlRGVidWZmRWZmZWN0cyA9IG5ldyBNYXA8bnVtYmVyLCB7IGRlYnVmZlR5cGU6IHN0cmluZzsgc3RhcnRUaW1lOiBudW1iZXI7IGR1cmF0aW9uOiBudW1iZXIgfVtdPigpO1xuXG4gIC8vIFNtaXRlIGFiaWxpdHkgc3RhdGUgKFJ1bmVibGFkZSlcbiAgcHJpdmF0ZSBsYXN0U21pdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSBzbWl0ZUNvb2xkb3duID0gMi4wOyAvLyAyIHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzU21pdGluZyA9IGZhbHNlO1xuXG4gIC8vIERlYXRoR3Jhc3AgYWJpbGl0eSBzdGF0ZSAoUnVuZWJsYWRlKVxuICBwcml2YXRlIGxhc3REZWF0aEdyYXNwVGltZSA9IDA7XG4gIHByaXZhdGUgZGVhdGhHcmFzcENvb2xkb3duID0gNS4wOyAvLyA1IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzRGVhdGhHcmFzcGluZyA9IGZhbHNlO1xuXG4gIC8vIFdyYWl0aFN0cmlrZSBhYmlsaXR5IHN0YXRlIChSdW5lYmxhZGUpXG4gIHByaXZhdGUgbGFzdFdyYWl0aFN0cmlrZVRpbWUgPSAwO1xuICBwcml2YXRlIHdyYWl0aFN0cmlrZUNvb2xkb3duID0gMy4wOyAvLyAzIHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzV3JhaXRoU3RyaWtpbmcgPSBmYWxzZTtcblxuICAvLyBDb3JydXB0ZWQgQXVyYSBhYmlsaXR5IHN0YXRlIChSdW5lYmxhZGUpXG4gIHByaXZhdGUgY29ycnVwdGVkQXVyYUFjdGl2ZSA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RNYW5hRHJhaW5UaW1lID0gMDtcbiAgcHJpdmF0ZSBjb3JydXB0ZWRBdXJhUmFuZ2UgPSA4LjA7IC8vIDggdW5pdCByYW5nZSBmb3Igc2xvdyBlZmZlY3RcbiAgcHJpdmF0ZSBjb3JydXB0ZWRBdXJhTWFuYUNvc3QgPSA4OyAvLyA4IG1hbmEgcGVyIHNlY29uZFxuICBwcml2YXRlIGNvcnJ1cHRlZEF1cmFTbG93RWZmZWN0ID0gMC41OyAvLyA1MCUgc2xvdyAobXVsdGlwbHkgbW92ZW1lbnQgc3BlZWQgYnkgdGhpcylcbiAgcHJpdmF0ZSBjb3JydXB0ZWRBdXJhU2xvd2VkRW50aXRpZXMgPSBuZXcgTWFwPG51bWJlciwgYm9vbGVhbj4oKTsgLy8gVHJhY2sgc2xvd2VkIGVudGl0aWVzXG5cbiAgLy8gQ29sb3NzdXMgU3RyaWtlIGFiaWxpdHkgc3RhdGUgKFN3b3JkKVxuICBwcml2YXRlIGxhc3RDb2xvc3N1c1N0cmlrZVRpbWUgPSAwO1xuICBwcml2YXRlIGNvbG9zc3VzU3RyaWtlQ29vbGRvd24gPSA0LjA7IC8vIDQgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgaXNDb2xvc3N1c1N0cmlraW5nID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmEsIFxuICAgIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyLCBcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIgPSBuZXcgRGVmbGVjdEJhcnJpZXIod29ybGQpO1xuICAgIHRoaXMucHJpb3JpdHkgPSA1OyAvLyBSdW4gZWFybHkgZm9yIGlucHV0IGhhbmRsaW5nXG4gIH1cblxuICBwdWJsaWMgc2V0UGxheWVyKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgdGhpcy5wbGF5ZXJFbnRpdHkgPSBlbnRpdHk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG5cbiAgICBjb25zdCBwbGF5ZXJUcmFuc2Zvcm0gPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgXG4gICAgaWYgKCFwbGF5ZXJUcmFuc2Zvcm0gfHwgIXBsYXllck1vdmVtZW50KSByZXR1cm47XG5cbiAgICAvLyBVcGRhdGUgZGVidWZmIHN0YXRlcyBmaXJzdFxuICAgIGlmICh0eXBlb2YgcGxheWVyTW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGxheWVyTW92ZW1lbnQudXBkYXRlRGVidWZmcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleHBpcmVkIFN1bmRlciBzdGFja3MgcGVyaW9kaWNhbGx5XG4gICAgdGhpcy5jbGVhbnVwU3VuZGVyU3RhY2tzKCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhwaXJlZCBCdXJuaW5nIHN0YWNrcyBwZXJpb2RpY2FsbHlcbiAgICB0aGlzLmNsZWFudXBCdXJuaW5nU3RhY2tzKCk7XG5cbiAgICAvLyBIYW5kbGUgd2VhcG9uIHN3aXRjaGluZ1xuICAgIHRoaXMuaGFuZGxlV2VhcG9uU3dpdGNoaW5nKCk7XG5cbiAgICAvLyBIYW5kbGUgZGFzaCBtb3ZlbWVudCBmaXJzdCAob3ZlcnJpZGVzIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5oYW5kbGVEYXNoTW92ZW1lbnQocGxheWVyTW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhcmdlIG1vdmVtZW50IChvdmVycmlkZXMgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmhhbmRsZUNoYXJnZU1vdmVtZW50KHBsYXllck1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gSGFuZGxlIHBsYXllciBtb3ZlbWVudCBpbnB1dCAob25seSBwcmV2ZW50IGZvciBhYmlsaXRpZXMgdGhhdCB0cnVseSBvdmVycmlkZSBtb3ZlbWVudClcbiAgICAvLyBNb3N0IGFiaWxpdGllcyBzaG91bGQgYWxsb3cgbW92ZW1lbnQgLSBvbmx5IHByZXZlbnQgZm9yIGRhc2hpbmcsIGNoYXJnaW5nLCBhbmQgZGVidWZmc1xuICAgIGlmICghcGxheWVyTW92ZW1lbnQuaXNEYXNoaW5nICYmICFwbGF5ZXJNb3ZlbWVudC5pc0NoYXJnaW5nICYmICFwbGF5ZXJNb3ZlbWVudC5pc0Zyb3plbikge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlbWVudElucHV0KHBsYXllck1vdmVtZW50KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGNvbWJhdCBpbnB1dFxuICAgIHRoaXMuaGFuZGxlQ29tYmF0SW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgZGVmbGVjdCBiYXJyaWVyIHBvc2l0aW9uIGlmIGFjdGl2ZVxuICAgIHRoaXMudXBkYXRlRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTW92ZW1lbnRJbnB1dChtb3ZlbWVudDogTW92ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG5cbiAgICBjb25zdCBwbGF5ZXJUcmFuc2Zvcm0gPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXBsYXllclRyYW5zZm9ybSkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGRvdWJsZS10YXAgZGFzaGVzIGZpcnN0IChiZWZvcmUgcHJvY2Vzc2luZyByZWd1bGFyIG1vdmVtZW50KVxuICAgIHRoaXMuY2hlY2tGb3JEYXNoSW5wdXQobW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBHZXQgaW5wdXQgZGlyZWN0aW9uXG4gICAgY29uc3QgaW5wdXREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBsZXQgaGFzSW5wdXQgPSBmYWxzZTtcblxuICAgIC8vIFdBU0QgbW92ZW1lbnRcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCd3JykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnogLT0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncycpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi56ICs9IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2EnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueCAtPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdkJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnggKz0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgZGlhZ29uYWwgbW92ZW1lbnRcbiAgICBpZiAoaW5wdXREaXJlY3Rpb24ubGVuZ3RoKCkgPiAwKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGlucHV0IHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGNhbWVyYSBvcmllbnRhdGlvblxuICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhjYW1lcmFEaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbWVyYSdzIGZvcndhcmQgdmVjdG9yIChwcm9qZWN0ZWQgb24gWFogcGxhbmUpXG4gICAgICBjb25zdCBjYW1lcmFGb3J3YXJkID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2VcbiAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhRm9yd2FyZCwgLWlucHV0RGlyZWN0aW9uLnopO1xuICAgICAgd29ybGREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgIG1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24od29ybGREaXJlY3Rpb24sIDEuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24obmV3IFZlY3RvcjMoMCwgMCwgMCksIDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBqdW1waW5nXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnICcpKSB7IC8vIFNwYWNlYmFyXG4gICAgICBtb3ZlbWVudC5qdW1wKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsYXN0V2VhcG9uU3dpdGNoVGltZSA9IDA7XG4gIHByaXZhdGUgd2VhcG9uU3dpdGNoQ29vbGRvd24gPSAxLjU7IC8vIDIwMG1zIGNvb2xkb3duIHRvIHByZXZlbnQgcmFwaWQgc3dpdGNoaW5nXG5cbiAgcHJpdmF0ZSBoYW5kbGVXZWFwb25Td2l0Y2hpbmcoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBQcmV2ZW50IHJhcGlkIHdlYXBvbiBzd2l0Y2hpbmdcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lIDwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3ZWFwb24gc3dpdGNoaW5nIHdpdGggbnVtYmVyIGtleXNcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcxJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TV09SRDtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5ESVZJTklUWTsgLy8gRGVmYXVsdCBzd29yZCBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zd29yZEZpcmVSYXRlOyAvLyBVc2Ugc3dvcmQtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7IC8vIFJlc2V0IGNvbWJvIHdoZW4gc3dpdGNoaW5nIHRvIHN3b3JkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzInKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5CT1c7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRUxFTUVOVEFMOyAvLyBEZWZhdWx0IGJvdyBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gMC4yMjU7IC8vIEJvdyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCczJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk7IC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuU0NZVEhFO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkNIQU9TOyAvLyBEZWZhdWx0IHNjeXRoZSBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zY3l0aGVGaXJlUmF0ZTsgLy8gVXNlIHNjeXRoZSBmaXJlIHJhdGUgKDAuNXMpXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnNCcpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNBQlJFUztcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5GUk9TVDsgLy8gRGVmYXVsdCBzYWJyZXMgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc2FicmVzRmlyZVJhdGU7IC8vIFVzZSBzYWJyZXMtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnNScpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlJVTkVCTEFERSkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlJVTkVCTEFERTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5BUkNBTkU7IC8vIERlZmF1bHQgcnVuZWJsYWRlIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnJ1bmVibGFkZUZpcmVSYXRlOyAvLyBVc2UgcnVuZWJsYWRlIGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAxOyAvLyBSZXNldCBjb21ibyB3aGVuIHN3aXRjaGluZyB0byBydW5lYmxhZGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNvbWJhdElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgIHRoaXMuaGFuZGxlQm93SW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQ1lUSEUpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2N5dGhlSW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgdGhpcy5oYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0FCUkVTKSB7XG4gICAgICB0aGlzLmhhbmRsZVNhYnJlc0lucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuUlVORUJMQURFKSB7XG4gICAgICB0aGlzLmhhbmRsZVJ1bmVibGFkZUlucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVCb3dJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBWaXBlciBTdGluZyBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1WaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBCYXJyYWdlIGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpKSB7XG5cbiAgICAgIGlmICghdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENvYnJhIFNob3QgYWJpbGl0eSB3aXRoICdFJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdlJykpIHtcblxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLnBlcmZvcm1Db2JyYVNob3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGJvdyBjaGFyZ2luZyBhbmQgZmlyaW5nXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uIGhlbGRcbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG5cbiAgICAgIH1cbiAgICAgIC8vIEluY3JlYXNlIGNoYXJnZSBwcm9ncmVzcyAoY291bGQgYmUgdGltZS1iYXNlZClcbiAgICAgIGlmICghdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLmNoYXJnZVByb2dyZXNzICsgMC4wMTI1LCAxLjApOyAvLyBCT1cgQ0hBUkdFIFNQRUVEXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFueSBhYmlsaXR5IGlzIGNoYXJnaW5nIC0gaWYgc28sIGNhbmNlbCB0aGUgcmVndWxhciBib3cgc2hvdFxuICAgICAgaWYgKHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgfHwgdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyB8fCB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIGNoYXJnZSBwcm9ncmVzcyBiZWZvcmUgcmVzZXR0aW5nIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgICAgY29uc3QgZmluYWxDaGFyZ2VQcm9ncmVzcyA9IHRoaXMuY2hhcmdlUHJvZ3Jlc3M7XG4gICAgICBcbiAgICAgIC8vIFJlbGVhc2UgdGhlIGJvd1xuICAgICAgdGhpcy5maXJlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciB2aXN1YWwgZWZmZWN0cyBjYWxsYmFjayB3aXRoIHRoZSBzdG9yZWQgY2hhcmdlIHByb2dyZXNzXG4gICAgICB0aGlzLnRyaWdnZXJCb3dSZWxlYXNlRWZmZWN0cyhmaW5hbENoYXJnZVByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNjeXRoZUlucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHNjeXRoZSBsZWZ0IGNsaWNrIGZvciBFbnRyb3BpY0JvbHRcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkpIHsgLy8gTGVmdCBtb3VzZSBidXR0b24gaGVsZFxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgU3RhcnRlZCBjaGFyZ2luZyBzY3l0aGUgKHNwaW5uaW5nKScpO1xuICAgICAgfVxuICAgICAgLy8gSW5jcmVhc2UgY2hhcmdlIHByb2dyZXNzIGNvbnRpbnVvdXNseSBmb3Igc3Bpbm5pbmcgYW5pbWF0aW9uIChubyBjYXApXG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzICs9IDAuMDM7IC8vIENvbnRpbnVvdXNseSBpbmNyZWFzZSBmb3Igc3Bpbm5pbmdcbiAgICAgIFxuICAgICAgLy8gRmlyZSBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZXMgY29udGludW91c2x5IHdoaWxlIHNwaW5uaW5nXG4gICAgICB0aGlzLmZpcmVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIC8vIFN0b3Agc3Bpbm5pbmcgd2hlbiBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENyb3NzZW50cm9weUJvbHQgYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNDaGFyZ2luZyAmJiAhdGhpcy5pc0Nyb3NzZW50cm9weUNoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Dcm9zc2VudHJvcHlBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBSZWFuaW1hdGUgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRnJvc3QgTm92YSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaXJlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2xpY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5maXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uIChzYW1lIGFzIGNhbWVyYSBkaXJlY3Rpb24gc2luY2UgZHJhZ29uIGZhY2VzIGNhbWVyYSlcbiAgICAvLyBUaGlzIGVuc3VyZXMgYXJyb3dzIGZpcmUgb3V0d2FyZCBmcm9tIHdoZXJlIHRoZSBkcmFnb24gaXMgZmFjaW5nXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gdG8gYWNjb3VudCBmb3IgcmVzdHJpY3RlZCBjYW1lcmEgYm91bmRzXG4gICAgLy8gU2luY2UgY2FtZXJhIGNhbid0IGxvb2sgZG93biBtdWNoIGR1ZSB0byBib3VuZHMsIHdlIGFkZCBhIGZpeGVkIGRvd253YXJkIGFuZ2xlXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBcbiAgICAvLyBDcmVhdGUgYSByb3RhdGlvbiBtYXRyaXggdG8gYXBwbHkgdGhlIGRvd253YXJkIGFuZ2xlIGFyb3VuZCB0aGUgY2FtZXJhJ3MgcmlnaHQgYXhpc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIFBlcmZlY3Qgc2hvdCB0aW1pbmcgY29uc3RhbnRzXG4gICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc7IC8vIDg1JSBjaGFyZ2VcbiAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICBjb25zdCBpc1BlcmZlY3RTaG90ID0gdGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCAmJiB0aGlzLmNoYXJnZVByb2dyZXNzIDw9IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJvdyBpcyBmdWxseSBjaGFyZ2VkIGZvciBzcGVjaWFsIHByb2plY3RpbGVcbiAgICBpZiAodGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzUGVyZmVjdFNob3QpIHtcbiAgICAgIHRoaXMuY3JlYXRlUGVyZmVjdFNob3RQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWJ1ZzogTG9nIHRoZSBmaXJpbmcgYW5nbGUgdG8gdmVyaWZ5IGl0J3MgY2hhbmdpbmcgd2l0aCBjYW1lcmEgcm90YXRpb25cbiAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnopO1xuICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gdXNlIG5ldyBzY3l0aGUgcmF0ZSAoMC4zNSBzZWNvbmRzKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLnNjeXRoZUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb25cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiAoc2FtZSBhcyBib3cgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHNwaW5TdGF0dXMgPSB0aGlzLmlzQ2hhcmdpbmcgPyAnIChTUElOTklORyknIDogJyc7XG4gICAgXG4gICAgdGhpcy5jcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQ3Jvc3NlbnRyb3B5QWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcblxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lIDwgdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDQwIG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0Q3Jvc3NlbnRyb3B5Qm9sdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc3QgbWFuYUNvbnN1bWVkID0gZ2FtZVVJLmNvbnN1bWVNYW5hKDQwKTtcbiAgICAgIGlmICghbWFuYUNvbnN1bWVkKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqU77iPIENyb3NzZW50cm9weUJvbHQ6IEZhaWxlZCB0byBjb25zdW1lIG1hbmEgLSBub3QgZW5vdWdoIG1hbmE/Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gQ3Jvc3NlbnRyb3B5Qm9sdDogQ29uc3VtZWQgNDAgbWFuYSAoJHttYW5hQmVmb3JlfSAtPiAke2dhbWVVSS5nZXRDdXJyZW50TWFuYSgpfSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ3Jvc3NlbnRyb3B5Q2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuY3Jvc3NlbnRyb3B5Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZCBjaGFyZ2UgdGltZVxuXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuY3Jvc3NlbnRyb3B5Q2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG5cbiAgICAgIGlmICh0aGlzLmNyb3NzZW50cm9weUNoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNoYXJnZUludGVydmFsKTtcbiAgICAgICAgdGhpcy5maXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHlBZnRlckNoYXJnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLmlzQ3Jvc3NlbnRyb3B5Q2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcm9zc2VudHJvcHlDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHlBZnRlckNoYXJnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgd2FzIGFscmVhZHkgY2hlY2tlZCBpbiBwZXJmb3JtQ3Jvc3NlbnRyb3B5QWJpbGl0eSgpXG4gICAgLy8gTm8gbmVlZCB0byBjaGVjayBhZ2FpbiBoZXJlIC0gd2UganVzdCBmaW5pc2hlZCBjaGFyZ2luZ1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBhbmdsZSBjb21wZW5zYXRpb24gKHNhbWUgYXMgYm93IHByb2plY3RpbGVzKVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIFxuICAgIHRoaXMuY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHZhbGlkIHRhcmdldHMgaW4gdGhlIHdvcmxkIGJlZm9yZSBjcmVhdGluZyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIGNvbnN0IHZhbGlkVGFyZ2V0cyA9IHBvdGVudGlhbFRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiBcbiAgICAgIHRhcmdldC5pZCAhPT0gdGhpcy5wbGF5ZXJFbnRpdHkhLmlkICYmIC8vIE5vdCB0aGUgcGxheWVyIGl0c2VsZlxuICAgICAgIXRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKT8uaXNEZWFkIC8vIE5vdCBkZWFkXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbiBtdWx0aXBsYXllciBtb2RlLCBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlcyBpZiB0aGVyZSBhcmUgdmFsaWQgdGFyZ2V0cyBvciBpZiB3ZSBuZWVkIHRvIGJyb2FkY2FzdCB0byBvdGhlciBwbGF5ZXJzXG4gICAgY29uc3QgaGFzVmFsaWRUYXJnZXRzID0gdmFsaWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc2hvdWxkQnJvYWRjYXN0ID0gdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgIT09IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAoIWhhc1ZhbGlkVGFyZ2V0cyAmJiAhc2hvdWxkQnJvYWRjYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjc1OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZSB1c2luZyB0aGUgUHJvamVjdGlsZVN5c3RlbSB3aXRoIGN1cnJlbnQgd2VhcG9uIGNvbmZpZ1xuICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICBzcGVlZDogMjUsXG4gICAgICBkYW1hZ2U6IDEwLCAvLyBBcnJvdyBkYW1hZ2Ugc2hvdWxkIGJlIDEwXG4gICAgICBsaWZldGltZTogMyxcbiAgICAgIG1heERpc3RhbmNlOiAyNSwgLy8gTGltaXQgYm93IGFycm93cyB0byAyNSB1bml0cyBkaXN0YW5jZVxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wLFxuICAgICAgc291cmNlUGxheWVySWQ6IHRoaXMucGxheWVyRW50aXR5LnVzZXJEYXRhPy5wbGF5ZXJJZCB8fCAndW5rbm93bidcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIHByb2plY3RpbGVDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdyZWd1bGFyX2Fycm93Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBwcm9qZWN0aWxlQ29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHZhbGlkIHRhcmdldHMgaW4gdGhlIHdvcmxkIGJlZm9yZSBjcmVhdGluZyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIGNvbnN0IHZhbGlkVGFyZ2V0cyA9IHBvdGVudGlhbFRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiBcbiAgICAgIHRhcmdldC5pZCAhPT0gdGhpcy5wbGF5ZXJFbnRpdHkhLmlkICYmIC8vIE5vdCB0aGUgcGxheWVyIGl0c2VsZlxuICAgICAgIXRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKT8uaXNEZWFkIC8vIE5vdCBkZWFkXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbiBtdWx0aXBsYXllciBtb2RlLCBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlcyBpZiB0aGVyZSBhcmUgdmFsaWQgdGFyZ2V0cyBvciBpZiB3ZSBuZWVkIHRvIGJyb2FkY2FzdCB0byBvdGhlciBwbGF5ZXJzXG4gICAgY29uc3QgaGFzVmFsaWRUYXJnZXRzID0gdmFsaWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc2hvdWxkQnJvYWRjYXN0ID0gdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgIT09IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAoIWhhc1ZhbGlkVGFyZ2V0cyAmJiAhc2hvdWxkQnJvYWRjYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDE1IG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0RW50cm9waWNCb2x0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUNvbnN1bWVkID0gZ2FtZVVJLmNvbnN1bWVNYW5hKDEwKTtcbiAgICAgIGlmICghbWFuYUNvbnN1bWVkKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqhIEVudHJvcGljQm9sdDogRmFpbGVkIHRvIGNvbnN1bWUgbWFuYSBkZXNwaXRlIGNhbkNhc3QgY2hlY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIEVudHJvcGljQm9sdCBwcm9qZWN0aWxlIHVzaW5nIHRoZSBuZXcgbWV0aG9kXG4gICAgY29uc3QgZW50cm9waWNDb25maWcgPSB7XG4gICAgICBzcGVlZDogMjAsIC8vIEZhc3RlciB0aGFuIENyb3NzZW50cm9weUJvbHRcbiAgICAgIGRhbWFnZTogMjAsIC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICAgIGxpZmV0aW1lOiAyLCAvLyBTaG9ydGVyIGxpZmV0aW1lXG4gICAgICBwaWVyY2luZzogZmFsc2UsIC8vIE5vbi1waWVyY2luZyBzbyBwcm9qZWN0aWxlIGdldHMgZGVzdHJveWVkIG9uIGhpdFxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gTm8gZXhwbG9zaW9uIGVmZmVjdFxuICAgICAgZXhwbG9zaW9uUmFkaXVzOiAwLCAvLyBObyBleHBsb3Npb24gcmFkaXVzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjAsXG4gICAgICBzb3VyY2VQbGF5ZXJJZDogdGhpcy5wbGF5ZXJFbnRpdHk/LnVzZXJEYXRhPy5wbGF5ZXJJZCB8fCAndW5rbm93bidcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGVudHJvcGljQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnZW50cm9waWNfYm9sdCcsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgZW50cm9waWNDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICg0MCBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdENyb3NzZW50cm9weUJvbHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQ29uc3VtZWQgPSBnYW1lVUkuY29uc3VtZU1hbmEoNDApO1xuICAgICAgaWYgKCFtYW5hQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimpTvuI8gQ3Jvc3NlbnRyb3B5Qm9sdDogRmFpbGVkIHRvIGNvbnN1bWUgbWFuYSBkZXNwaXRlIGNhbkNhc3QgY2hlY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBDb25zdW1lZCA0MCBtYW5hIGZvciBDcm9zc2VudHJvcHkgQm9sdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSB1c2luZyB0aGUgZXhpc3RpbmcgbWV0aG9kXG4gICAgY29uc3QgY3Jvc3NlbnRyb3B5Q29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDE1LCAvLyBTbG93ZXIgdGhhbiBFbnRyb3BpY0JvbHRcbiAgICAgIGRhbWFnZTogOTAsIC8vIEhpZ2hlciBkYW1hZ2UgZm9yIFIgYWJpbGl0eVxuICAgICAgbGlmZXRpbWU6IDIuNSwgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgICBwaWVyY2luZzogZmFsc2UsIC8vIFxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gRGlzYWJsZWQgZXhwbG9zaW9uIGVmZmVjdCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGV4cGxvc2lvblJhZGl1czogMCwgLy8gTm8gZXhwbG9zaW9uIHJhZGl1c1xuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgY3Jvc3NlbnRyb3B5Q29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY3Jvc3NlbnRyb3B5X2JvbHQnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNyb3NzZW50cm9weUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNhc3RpbmcgKDEgc2Vjb25kIGNvb2xkb3duKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVhbmltYXRlVGltZSA8IDEuMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZWFuaW1hdGVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMjAgbWFuYSBjb3N0IC0gZG91YmxlZCBmcm9tIDEwKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgY29uc3QgY3VycmVudE1hbmEgPSBnYW1lVUkgPyBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKSA6IDA7XG4gICAgXG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RSZWFuaW1hdGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQmVmb3JlID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgICBjb25zdCBtYW5hQ29uc3VtZWQgPSBnYW1lVUkuY29uc3VtZU1hbmEoMjApO1xuICAgICAgaWYgKCFtYW5hQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfwn6m4IFJlYW5pbWF0ZTogRmFpbGVkIHRvIGNvbnN1bWUgbWFuYSBkZXNwaXRlIGNhbkNhc3QgY2hlY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFuYUFmdGVyID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsd2F5cyB0cmlnZ2VyIHRoZSB2aXN1YWwgZWZmZWN0IGZpcnN0LCByZWdhcmRsZXNzIG9mIGhlYWxpbmcgc3VjY2Vzc1xuICAgIHRoaXMudHJpZ2dlclJlYW5pbWF0ZUVmZmVjdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIncyBoZWFsdGggY29tcG9uZW50IGFuZCBoZWFsIGZvciAzMCBIUCBcbiAgICBjb25zdCBoZWFsdGhDb21wb25lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoaGVhbHRoQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCBkaWRIZWFsID0gaGVhbHRoQ29tcG9uZW50LmhlYWwoMzApOyAvLyBSRUFOSU1BVEUgSEVBTCBBTU9VTlRcbiAgICAgIGlmIChkaWRIZWFsKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn6m4IFJlYW5pbWF0ZSBoZWFsZWQgcGxheWVyIGZvciAzMCBIUC4gQ3VycmVudCBoZWFsdGg6ICR7aGVhbHRoQ29tcG9uZW50LmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoQ29tcG9uZW50Lm1heEhlYWx0aH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfwn6m4IFJlYW5pbWF0ZSBjYXN0IHN1Y2Nlc3NmdWxseSBidXQgcGxheWVyIGFscmVhZHkgYXQgZnVsbCBoZWFsdGgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZWFuaW1hdGVFZmZlY3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBUcmlnZ2VyIHRoZSB2aXN1YWwgaGVhbGluZyBlZmZlY3RcbiAgICBcbiAgICBpZiAodGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2soKTtcbiAgICB9IFxuICAgIFxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRnJvc3ROb3ZhQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSA8IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoNTAgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RGcm9zdE5vdmEoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQ29uc3VtZWQgPSBnYW1lVUkuY29uc3VtZU1hbmEoNTApO1xuICAgICAgaWYgKCFtYW5hQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfinYTvuI8gRnJvc3ROb3ZhOiBGYWlsZWQgdG8gY29uc3VtZSBtYW5hIGRlc3BpdGUgY2FuQ2FzdCBjaGVjaycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIEZyb3N0IE5vdmEgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Gcm9zdE5vdmFDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaW5kIGFsbCBlbmVtaWVzIHdpdGhpbiA1IHVuaXQgcmFkaXVzIGFuZCBmcmVlemUgdGhlbVxuICAgIHRoaXMuZnJlZXplRW5lbWllc0luUmFkaXVzKHBsYXllclBvc2l0aW9uLCA2LjAsIGN1cnJlbnRUaW1lKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdsb2JhbCBmcm9zdCBub3ZhIHZpc3VhbCBlZmZlY3RcbiAgICB0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhKHBsYXllclBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSA8IHRoaXMuY29icmFTaG90RmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBlbmVyZ3kgKDQwIGVuZXJneSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RDb2JyYVNob3QoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNDApO1xuICAgIH1cblxuICAgIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0Q29icmFTaG90VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA3NTA7IC8vIDAuNzUgc2Vjb25kIGNoYXJnZSB0aW1lIChiZXR3ZWVuIFZpcGVyIFN0aW5nIGFuZCBCYXJyYWdlKVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBjaGFyZ2VTdGFydFRpbWU7XG4gICAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlQ29icmFTaG90KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIChzYW1lIGFzIG90aGVyIHByb2plY3RpbGVzKVxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDAuODI1OyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsIGxpa2UgVmlwZXIgU3RpbmdcbiAgICBcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogQ29icmEgU2hvdCBkYW1hZ2UgaXMgaGFuZGxlZCBieSBDb2JyYVNob3RNYW5hZ2VyLCBub3QgRUNTIHByb2plY3RpbGVzXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgcHJvamVjdGlsZXMgYW5kIGRhbWFnZSAoc2ltaWxhciB0byBWaXBlciBTdGluZylcbiAgICBcbiAgICAvLyBUcmlnZ2VyIENvYnJhIFNob3QgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Db2JyYVNob3RDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrKHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2xvYmFsIGNvYnJhIHNob3Qgd2l0aCBwcm9wZXIgcG9zaXRpb25pbmcgKGhhbmRsZXMgbG9jYWwgdmlzdWFsIGVmZmVjdHMgYW5kIGRhbWFnZSlcbiAgICB0cmlnZ2VyR2xvYmFsQ29icmFTaG90KHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NvYnJhX3Nob3RfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwge1xuICAgICAgICBzcGVlZDogMjAsIC8vIENvbnNpc3RlbnQgc3BlZWQgZm9yIFBWUFxuICAgICAgICBkYW1hZ2U6IDI5LCAvLyBVc2UgY29uc2lzdGVudCBkYW1hZ2UgdmFsdWVcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIHZlbm9tRHVyYXRpb246IDZcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZnJlZXplRW5lbWllc0luUmFkaXVzKGNlbnRlclBvc2l0aW9uOiBWZWN0b3IzLCByYWRpdXM6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgbGV0IGZyb3plbkNvdW50ID0gMDtcbiAgICBsZXQgZGFtYWdlZFBsYXllcnMgPSAwO1xuICAgIFxuICAgIC8vIEdldCBsb2NhbCBzb2NrZXQgSUQgdG8gcHJldmVudCBzZWxmLXRhcmdldGluZ1xuICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICBcbiAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghZW50aXR5VHJhbnNmb3JtIHx8ICFlbnRpdHlIZWFsdGggfHwgZW50aXR5SGVhbHRoLmlzRGVhZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICAvLyBTa2lwIHNlbGYgKGxvY2FsIHBsYXllciBlbnRpdHkpXG4gICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZW50aXR5UG9zaXRpb24gPSBlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNlbnRlclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaXMgd2l0aGluIGZyZWV6ZSByYWRpdXNcbiAgICAgIGlmIChkaXN0YW5jZSA8PSByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZW5lbXkgLSBmcmVlemUgaXQgKHNpbmdsZSBwbGF5ZXIgbW9kZSlcbiAgICAgICAgICBlbmVteS5mcmVlemUoNi4wLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgZnJvemVuQ291bnQrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgZnJvemVuIHZpc3VhbCBlZmZlY3QgZm9yIHRoaXMgZW5lbXlcbiAgICAgICAgICBhZGRHbG9iYWxGcm96ZW5FbmVteShlbnRpdHkuaWQudG9TdHJpbmcoKSwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGFub3RoZXIgcGxheWVyIGluIFBWUCBtb2RlIC0gZGVhbCBkYW1hZ2UgYW5kIGZyZWV6ZVxuICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogRmlyc3QgY2hlY2sgaWYgdGhpcyBlbnRpdHkgcmVwcmVzZW50cyB0aGUgbG9jYWwgcGxheWVyXG4gICAgICAgICAgY29uc3Qgc2VydmVyUGxheWVyRW50aXRpZXMgPSAod2luZG93IGFzIGFueSkuc2VydmVyUGxheWVyRW50aXRpZXM7XG4gICAgICAgICAgbGV0IHRhcmdldFBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2VydmVyUGxheWVyRW50aXRpZXMgJiYgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudCkge1xuICAgICAgICAgICAgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudC5mb3JFYWNoKChsb2NhbEVudGl0eUlkOiBudW1iZXIsIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsRW50aXR5SWQgPT09IGVudGl0eS5pZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBORVZFUiBkYW1hZ2Ugb3IgZGVidWZmIG91cnNlbHZlc1xuICAgICAgICAgIGlmICh0YXJnZXRQbGF5ZXJJZCAmJiB0YXJnZXRQbGF5ZXJJZCA9PT0gbG9jYWxTb2NrZXRJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGluZyBGcm9zdCBOb3ZhIG9uIGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9YCk7XG4gICAgICAgICAgICByZXR1cm47IC8vIFNraXAgdGhpcyBlbnRpdHkgY29tcGxldGVseVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkgJiYgdGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb3N0Tm92YURhbWFnZSA9IDUwOyAvLyBGcm9zdCBOb3ZhIGRhbWFnZVxuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgZnJvc3ROb3ZhRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ2Zyb3N0X25vdmEnKTtcbiAgICAgICAgICAgIGRhbWFnZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBmcmVlemUgZWZmZWN0IHRvIHRoZSB0YXJnZXQgcGxheWVyIHNvIHRoZXkgZ2V0IGZyb3plbiBvbiB0aGVpciBlbmRcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gQnJvYWRjYXN0aW5nIGZyZWV6ZSBlZmZlY3QgdG8gcGxheWVyICR7dGFyZ2V0UGxheWVySWR9IChOT1QgbG9jYWwgcGxheWVyICR7bG9jYWxTb2NrZXRJZH0pYCk7XG4gICAgICAgICAgICAgIHRoaXMub25EZWJ1ZmZDYWxsYmFjayhlbnRpdHkuaWQsICdmcm96ZW4nLCA2MDAwLCBlbnRpdHlQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKGZyb3plbkNvdW50ID4gMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGZyb3plICR7ZnJvemVuQ291bnR9IGVuZW1pZXMgd2l0aGluICR7cmFkaXVzfSB1bml0IHJhZGl1c2ApO1xuICAgIH1cbiAgICBpZiAoZGFtYWdlZFBsYXllcnMgPiAwKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3N0IE5vdmEgZGFtYWdlZCAke2RhbWFnZWRQbGF5ZXJzfSBwbGF5ZXJzIHdpdGhpbiAke3JhZGl1c30gdW5pdCByYWRpdXNgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgY2hhcmdlZCBhcnJvdyBwcm9qZWN0aWxlIC0gbW9yZSBwb3dlcmZ1bCB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgY29uc3QgY2hhcmdlZEFycm93Q29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDM1LCAvLyBGYXN0ZXIgdGhhbiByZWd1bGFyIGFycm93cyAoMjUpXG4gICAgICBkYW1hZ2U6IDUwLCAvLyBNdWNoIGhpZ2hlciBkYW1hZ2UgdGhhbiByZWd1bGFyIGFycm93cyAoMTApXG4gICAgICBsaWZldGltZTogMiwgLy8gTG9uZ2VyIGxpZmV0aW1lIHRoYW4gcmVndWxhciBhcnJvd3MgKDMpXG4gICAgICBwaWVyY2luZzogdHJ1ZSwgLy8gQ2hhcmdlZCBhcnJvd3MgY2FuIHBpZXJjZSB0aHJvdWdoIGVuZW1pZXNcbiAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIE5vIGV4cGxvc2lvbiwgYnV0IGNvdWxkIGFkZCBzcGVjaWFsIGVmZmVjdHNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgY2hhcmdlZEFycm93Q29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY2hhcmdlZF9hcnJvdycsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgY2hhcmdlZEFycm93Q29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBwZXJmZWN0IHNob3QgcHJvamVjdGlsZSAtIGVuaGFuY2VkIGNoYXJnZWQgYXJyb3cgd2l0aCBzcGVjaWFsIGVmZmVjdHNcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICB7XG4gICAgICAgIHNwZWVkOiA0MCwgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoMzUpXG4gICAgICAgIGRhbWFnZTogNzUsIC8vIEhpZ2hlciBkYW1hZ2UgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICg1MClcbiAgICAgICAgbGlmZXRpbWU6IDYsIC8vIExvbmdlciBsaWZldGltZSB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDUpXG4gICAgICAgIHBpZXJjaW5nOiB0cnVlLCAvLyBQZXJmZWN0IHNob3RzIGNhbiBwaWVyY2UgdGhyb3VnaCBlbmVtaWVzXG4gICAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIE5vIGV4cGxvc2lvbiwgYnV0IGhhcyBzcGVjaWFsIHZpc3VhbCBlZmZlY3RzXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH1cbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdwZXJmZWN0X3Nob3QnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHtcbiAgICAgICAgc3BlZWQ6IDQwLFxuICAgICAgICBkYW1hZ2U6IDc1LFxuICAgICAgICBsaWZldGltZTogNixcbiAgICAgICAgcGllcmNpbmc6IHRydWUsXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZHMgdG8gY29uZmlndXJlIHdlYXBvbiBmb3IgdGVzdGluZ1xuICBwdWJsaWMgc2V0V2VhcG9uU3ViY2xhc3Moc3ViY2xhc3M6IFdlYXBvblN1YmNsYXNzKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBzdWJjbGFzcztcbiAgfVxuXG4gIC8vIE1ldGhvZCB0byBzZXQgYm93IHJlbGVhc2UgY2FsbGJhY2tcbiAgcHVibGljIHNldEJvd1JlbGVhc2VDYWxsYmFjayhjYWxsYmFjazogKGZpbmFsUHJvZ3Jlc3M6IG51bWJlciwgaXNQZXJmZWN0U2hvdD86IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREaXZpbmVTdG9ybUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZHVyYXRpb246IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrOiAocHJvamVjdGlsZVR5cGU6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgY29uZmlnOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VmlwZXJTdGluZ0NhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25WaXBlclN0aW5nQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCYXJyYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkJhcnJhZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldFJlYW5pbWF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRGcm9zdE5vdmFDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldENvYnJhU2hvdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Db2JyYVNob3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0Q2hhcmdlQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYXJnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREZWZsZWN0Q2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlZmxlY3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0U2t5ZmFsbENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ta3lmYWxsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldEJhY2tzdGFiQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBkYW1hZ2U6IG51bWJlciwgaXNCYWNrc3RhYjogYm9vbGVhbikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25CYWNrc3RhYkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRTdW5kZXJDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGRhbWFnZTogbnVtYmVyLCBzdGFja0NvdW50OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU3VuZGVyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRTbWl0ZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgb25EYW1hZ2VEZWFsdD86IChkYW1hZ2VEZWFsdDogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25TbWl0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0RGVhdGhHcmFzcENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRXcmFpdGhTdHJpa2VDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uV3JhaXRoU3RyaWtlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb25zdW1lTWFuYUNhbGxiYWNrKGNhbGxiYWNrOiAoYW1vdW50OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29uc3VtZU1hbmFDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldENoZWNrTWFuYUNhbGxiYWNrKGNhbGxiYWNrOiAoYW1vdW50OiBudW1iZXIpID0+IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hlY2tNYW5hQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRDcmVhdGVTYWJyZU1pc3RFZmZlY3RDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNyZWF0ZVNhYnJlTWlzdEVmZmVjdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0U3RlYWx0aENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGlzQWN0aXZhdGluZzogYm9vbGVhbikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25TdGVhbHRoQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRIYXVudGVkU291bEVmZmVjdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uSGF1bnRlZFNvdWxFZmZlY3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldERlYnVmZkNhbGxiYWNrKGNhbGxiYWNrOiAodGFyZ2V0RW50aXR5SWQ6IG51bWJlciwgZGVidWZmVHlwZTogJ2Zyb3plbicgfCAnc2xvd2VkJyB8ICdzdHVubmVkJyB8ICdjb3JydXB0ZWQnIHwgJ2J1cm5pbmcnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgY2FsbGJhY2sgdGhhdCBhbHNvIHRyYWNrcyBkZWJ1ZmZzIGludGVybmFsbHlcbiAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2sgPSAodGFyZ2V0RW50aXR5SWQ6IG51bWJlciwgZGVidWZmVHlwZTogJ2Zyb3plbicgfCAnc2xvd2VkJyB8ICdzdHVubmVkJyB8ICdjb3JydXB0ZWQnIHwgJ2J1cm5pbmcnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4ge1xuICAgICAgLy8gVHJhY2sgdGhlIGRlYnVmZiBlZmZlY3QgaW50ZXJuYWxseSBmb3Igc3R1biBkZXRlY3Rpb25cbiAgICAgIHRoaXMudHJhY2tEZWJ1ZmZFZmZlY3QodGFyZ2V0RW50aXR5SWQsIGRlYnVmZlR5cGUsIGR1cmF0aW9uKTtcblxuICAgICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAgICAgIGlmIChvcmlnaW5hbENhbGxiYWNrKSB7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2sodGFyZ2V0RW50aXR5SWQsIGRlYnVmZlR5cGUsIGR1cmF0aW9uLCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIG1ldGhvZCB0byB0cmFjayBkZWJ1ZmYgZWZmZWN0cyBmb3Igc3R1biBkZXRlY3Rpb25cbiAgcHJpdmF0ZSB0cmFja0RlYnVmZkVmZmVjdChlbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWZmZWN0ID0ge1xuICAgICAgZGVidWZmVHlwZSxcbiAgICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWUsXG4gICAgICBkdXJhdGlvblxuICAgIH07XG5cbiAgICAvLyBHZXQgZXhpc3RpbmcgZWZmZWN0cyBmb3IgdGhpcyBlbnRpdHlcbiAgICBjb25zdCBleGlzdGluZ0VmZmVjdHMgPSB0aGlzLmFjdGl2ZURlYnVmZkVmZmVjdHMuZ2V0KGVudGl0eUlkKSB8fCBbXTtcblxuICAgIC8vIEFkZCB0aGUgbmV3IGVmZmVjdFxuICAgIGV4aXN0aW5nRWZmZWN0cy5wdXNoKGVmZmVjdCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIG1hcFxuICAgIHRoaXMuYWN0aXZlRGVidWZmRWZmZWN0cy5zZXQoZW50aXR5SWQsIGV4aXN0aW5nRWZmZWN0cyk7XG5cbiAgICAvLyBTY2hlZHVsZSBjbGVhbnVwIG9mIGV4cGlyZWQgZWZmZWN0XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0cyA9IHRoaXMuYWN0aXZlRGVidWZmRWZmZWN0cy5nZXQoZW50aXR5SWQpIHx8IFtdO1xuICAgICAgY29uc3QgZmlsdGVyZWRFZmZlY3RzID0gY3VycmVudEVmZmVjdHMuZmlsdGVyKGUgPT4gZSAhPT0gZWZmZWN0KTtcbiAgICAgIGlmIChmaWx0ZXJlZEVmZmVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRGVidWZmRWZmZWN0cy5kZWxldGUoZW50aXR5SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmVEZWJ1ZmZFZmZlY3RzLnNldChlbnRpdHlJZCwgZmlsdGVyZWRFZmZlY3RzKTtcbiAgICAgIH1cbiAgICB9LCBkdXJhdGlvbik7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gY2hlY2sgaWYgYSBwbGF5ZXIvZW50aXR5IGlzIGN1cnJlbnRseSBzdHVubmVkXG4gIHByaXZhdGUgaXNQbGF5ZXJTdHVubmVkKGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWZmZWN0cyA9IHRoaXMuYWN0aXZlRGVidWZmRWZmZWN0cy5nZXQoZW50aXR5SWQpO1xuXG4gICAgaWYgKCFlZmZlY3RzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgYWN0aXZlIGVmZmVjdCBpcyBhIHN0dW4gZWZmZWN0XG4gICAgcmV0dXJuIGVmZmVjdHMuc29tZShlZmZlY3QgPT5cbiAgICAgIGVmZmVjdC5kZWJ1ZmZUeXBlID09PSAnc3R1bm5lZCcgJiZcbiAgICAgIChjdXJyZW50VGltZSAtIGVmZmVjdC5zdGFydFRpbWUpIDwgZWZmZWN0LmR1cmF0aW9uXG4gICAgKTtcbiAgfVxuXG4gIC8vIE1ldGhvZCB0byB0cmlnZ2VyIGJvdyByZWxlYXNlIGVmZmVjdHNcbiAgcHJpdmF0ZSB0cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMoZmluYWxDaGFyZ2VQcm9ncmVzczogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub25Cb3dSZWxlYXNlQ2FsbGJhY2spIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgd2FzIGEgcGVyZmVjdCBzaG90XG4gICAgICBjb25zdCBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCA9IDAuNzU7IC8vIDg1JSBjaGFyZ2VcbiAgICAgIGNvbnN0IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkID0gMC45ODsgLy8gOTUlIGNoYXJnZVxuICAgICAgY29uc3QgaXNQZXJmZWN0U2hvdCA9IGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPj0gcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgJiYgZmluYWxDaGFyZ2VQcm9ncmVzcyA8PSBwZXJmZWN0U2hvdE1heFRocmVzaG9sZDtcbiAgICAgIFxuICAgICAgdGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjayhmaW5hbENoYXJnZVByb2dyZXNzLCBpc1BlcmZlY3RTaG90KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0V2VhcG9uTGV2ZWwobGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudFdlYXBvbkNvbmZpZygpOiB7IHdlYXBvbjogV2VhcG9uVHlwZTsgc3ViY2xhc3M6IFdlYXBvblN1YmNsYXNzOyBsZXZlbDogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB3ZWFwb246IHRoaXMuY3VycmVudFdlYXBvbixcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbFxuICAgIH07XG4gIH1cblxuICAvLyBHZXR0ZXJzIGZvciB3ZWFwb24gc3RhdGUgKGZvciBVSS9yZW5kZXJpbmcpXG4gIHB1YmxpYyBnZXRDdXJyZW50V2VhcG9uKCk6IFdlYXBvblR5cGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRXZWFwb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudFN1YmNsYXNzKCk6IFdlYXBvblN1YmNsYXNzIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3ViY2xhc3M7XG4gIH1cblxuICBwdWJsaWMgaXNXZWFwb25DaGFyZ2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0NoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldENoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNWaXBlclN0aW5nQ2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0VmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzQmFycmFnZUNoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldEJhcnJhZ2VDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc0NvYnJhU2hvdENoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc0Nyb3NzZW50cm9weUNoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ3Jvc3NlbnRyb3B5Q2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3Jvc3NlbnRyb3B5Q2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jcm9zc2VudHJvcHlDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1dlYXBvblN3aW5naW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3dpbmdpbmc7XG4gIH1cblxuICAvLyBTd29yZC1zcGVjaWZpYyBnZXR0ZXJzXG4gIHB1YmxpYyBnZXRTd29yZENvbWJvU3RlcCgpOiAxIHwgMiB8IDMge1xuICAgIHJldHVybiB0aGlzLnN3b3JkQ29tYm9TdGVwO1xuICB9XG5cbiAgcHVibGljIGlzRGl2aW5lU3Rvcm1BY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEaXZpbmVTdG9ybWluZztcbiAgfVxuXG4gIHB1YmxpYyBpc0NoYXJnZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1N3b3JkQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgaXNEZWZsZWN0QWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGVmbGVjdGluZztcbiAgfVxuICBcbiAgcHVibGljIGlzU2t5ZmFsbEFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1NreWZhbGxpbmc7XG4gIH1cbiAgXG4gIHB1YmxpYyBpc0JhY2tzdGFiQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQmFja3N0YWJiaW5nO1xuICB9XG4gIFxuICBwdWJsaWMgaXNTdW5kZXJBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdW5kZXJpbmc7XG4gIH1cbiAgXG4gIHB1YmxpYyBpc1N0ZWFsdGhBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdGVhbHRoaW5nO1xuICB9XG4gIFxuICBwdWJsaWMgaXNQbGF5ZXJJbnZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbnZpc2libGU7XG4gIH1cblxuICBwdWJsaWMgaXNTbWl0ZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1NtaXRpbmc7XG4gIH1cblxuICBwdWJsaWMgaXNEZWF0aEdyYXNwQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGVhdGhHcmFzcGluZztcbiAgfVxuXG4gIHB1YmxpYyBpc1dyYWl0aFN0cmlrZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1dyYWl0aFN0cmlraW5nO1xuICB9XG5cbiAgcHVibGljIGlzQ29ycnVwdGVkQXVyYUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb3JydXB0ZWRBdXJhQWN0aXZlO1xuICB9XG5cbiAgcHVibGljIGlzQ29sb3NzdXNTdHJpa2VBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb2xvc3N1c1N0cmlraW5nO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHN3b3JkIG1lbGVlIGF0dGFja3NcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RlZmxlY3RpbmcgJiYgIXRoaXMuaXNDb2xvc3N1c1N0cmlraW5nKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uXG4gICAgICB0aGlzLnBlcmZvcm1Td29yZE1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIERpdmluZSBTdG9ybSBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZyAmJiAhdGhpcy5pc0NvbG9zc3VzU3RyaWtpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIENoYXJnZSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEaXZpbmVTdG9ybWluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGVmbGVjdGluZyAmJiAhdGhpcy5pc0NvbG9zc3VzU3RyaWtpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybUNoYXJnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBEZWZsZWN0IGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzRGVmbGVjdGluZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzQ29sb3NzdXNTdHJpa2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtRGVmbGVjdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBDb2xvc3N1cyBTdHJpa2UgYWJpbGl0eSB3aXRoICdGJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdmJykgJiYgIXRoaXMuaXNDb2xvc3N1c1N0cmlraW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEZWZsZWN0aW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Db2xvc3N1c1N0cmlrZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb21ibyByZXNldFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3dvcmRBdHRhY2tUaW1lID4gdGhpcy5zd29yZENvbWJvUmVzZXRUaW1lKSB7XG4gICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJ1bmVibGFkZUlucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHJ1bmVibGFkZSBtZWxlZSBhdHRhY2tzXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTbWl0aW5nICYmICF0aGlzLmlzRGVhdGhHcmFzcGluZyAmJiAhdGhpcy5pc1dyYWl0aFN0cmlraW5nKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uXG4gICAgICB0aGlzLnBlcmZvcm1SdW5lYmxhZGVNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTbWl0ZSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1NtaXRpbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc0RlYXRoR3Jhc3BpbmcgJiYgIXRoaXMuaXNXcmFpdGhTdHJpa2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtU21pdGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRGVhdGhHcmFzcCBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSAmJiAhdGhpcy5pc0RlYXRoR3Jhc3BpbmcgJiYgIXRoaXMuaXNTbWl0aW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNXcmFpdGhTdHJpa2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtRGVhdGhHcmFzcChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBDb3JydXB0ZWQgQXVyYSBhYmlsaXR5IHdpdGggJ1InIGtleSAoanVzdCBwcmVzc2VkIGRldGVjdGlvbilcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNTbWl0aW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNEZWF0aEdyYXNwaW5nICYmICF0aGlzLmlzV3JhaXRoU3RyaWtpbmcpIHtcbiAgICAgIC8vIFRyYWNrIGlmIFIga2V5IHdhcyBqdXN0IHByZXNzZWQgKG5vdCBoZWxkIGRvd24pXG4gICAgICBpZiAoIXRoaXMucktleVdhc1ByZXNzZWQpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDb3JydXB0ZWRBdXJhKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMucktleVdhc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB0aGUganVzdCBwcmVzc2VkIGZsYWcgd2hlbiBSIGtleSBpcyByZWxlYXNlZFxuICAgICAgdGhpcy5yS2V5V2FzUHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBXcmFpdGhTdHJpa2UgYWJpbGl0eSB3aXRoICdGJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdmJykgJiYgIXRoaXMuaXNXcmFpdGhTdHJpa2luZyAmJiAhdGhpcy5pc1NtaXRpbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc0RlYXRoR3Jhc3BpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybVdyYWl0aFN0cmlrZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBDb3JydXB0ZWQgQXVyYSBlZmZlY3RzIHdoaWxlIGFjdGl2ZVxuICAgIGlmICh0aGlzLmNvcnJ1cHRlZEF1cmFBY3RpdmUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29ycnVwdGVkQXVyYUVmZmVjdHMocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29tYm8gcmVzZXRcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFN3b3JkQXR0YWNrVGltZSA+IHRoaXMuc3dvcmRDb21ib1Jlc2V0VGltZSkge1xuICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU3dvcmRNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2xpY2tpbmcgKHVzZSBzd29yZC1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc3dvcmRGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMubGFzdFN3b3JkQXR0YWNrVGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IHN3aW5naW5nIHN0YXRlIC0gY29tcGxldGlvbiB3aWxsIGJlIGhhbmRsZWQgYnkgc3dvcmQgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcblxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXJcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gTm90ZTogU3dpbmcgY29tcGxldGlvbiBhbmQgY29tYm8gYWR2YW5jZW1lbnQgaXMgbm93IGhhbmRsZWQgYnkgb25Td29yZFN3aW5nQ29tcGxldGUgY2FsbGJhY2tcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVJ1bmVibGFkZU1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHJ1bmVibGFkZS1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMucnVuZWJsYWRlRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcblxuICAgIC8vIFNldCBzd2luZ2luZyBzdGF0ZSAtIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHJ1bmVibGFkZSBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuXG4gICAgLy8gUGVyZm9ybSBtZWxlZSBkYW1hZ2UgaW4gYSBjb25lIGluIGZyb250IG9mIHBsYXllciAoc2FtZSBhcyBzd29yZClcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gTm90ZTogU3dpbmcgY29tcGxldGlvbiBhbmQgY29tYm8gYWR2YW5jZW1lbnQgaXMgbm93IGhhbmRsZWQgYnkgb25Td29yZFN3aW5nQ29tcGxldGUgY2FsbGJhY2tcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNtaXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdXNpbmcgUnVuZWJsYWRlXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U21pdGVUaW1lIDwgdGhpcy5zbWl0ZUNvb2xkb3duKSB7XG4gICAgICByZXR1cm47IC8vIFN0aWxsIG9uIGNvb2xkb3duXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBzbWl0aW5nXG4gICAgaWYgKHRoaXMuaXNTbWl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMzUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RTbWl0ZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCAobmVlZCAzNSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RTbWl0ZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmlzU21pdGluZyA9IHRydWU7XG5cbiAgICAvLyBTdG9wIHBsYXllciBtb3ZlbWVudCBpbW1lZGlhdGVseSB3aGVuIGNhc3RpbmcgU21pdGVcbiAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS54ID0gMDtcbiAgICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueiA9IDA7XG4gICAgICAgIHBsYXllck1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24obmV3IFZlY3RvcjMoMCwgMCwgMCksIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN1bWUgbWFuYSAoMzUgbWFuYSlcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQmVmb3JlID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgICBjb25zdCBtYW5hQ29uc3VtZWQgPSBnYW1lVUkuY29uc3VtZU1hbmEoMzUpO1xuICAgICAgaWYgKCFtYW5hQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqEgU21pdGU6IEZhaWxlZCB0byBjb25zdW1lIG1hbmEgZGVzcGl0ZSBjYW5DYXN0IGNoZWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogQ29uc3VtZWQgMzUgbWFuYS4gTWFuYTogJHttYW5hQmVmb3JlfSAtPiAke21hbmFBZnRlcn1gKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAvLyBPZmZzZXQgdGhlIHNtaXRlIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gbG9vayBsaWtlIGl0J3MgY29taW5nIGZyb20gdGhlIHJ1bmVibGFkZSBzd2luZ1xuICAgIGNvbnN0IHNtaXRlUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigyLjUpKTtcblxuICAgIC8vIE5PVEU6IERhbWFnZSBkZXRlY3Rpb24gaXMgbm93IGhhbmRsZWQgYnkgdGhlIFNtaXRlIHZpc3VhbCBjb21wb25lbnRcbiAgICAvLyB0byBwcmV2ZW50IGRvdWJsZSBkYW1hZ2UuIFRoZSB2aXN1YWwgY29tcG9uZW50J3MgZGFtYWdlIGRldGVjdGlvbiBpcyBtb3JlXG4gICAgLy8gYWNjdXJhdGUgYW5kIHByb3Blcmx5IHRpbWVkIHdpdGggdGhlIGFuaW1hdGlvbi5cblxuICAgIC8vIFRoZSBoZWFsaW5nIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSB2aXN1YWwgY29tcG9uZW50J3Mgb25EYW1hZ2VEZWFsdCBjYWxsYmFja1xuICAgIC8vIGluc3RlYWQgb2YgdGhlIENvbnRyb2xTeXN0ZW0ncyBwZXJmb3JtU21pdGVEYW1hZ2UgbWV0aG9kLlxuXG4gICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogRGFtYWdlIGRldGVjdGlvbiBkZWxlZ2F0ZWQgdG8gdmlzdWFsIGNvbXBvbmVudGApO1xuXG4gICAgLy8gVHJpZ2dlciBzbWl0ZSBjYWxsYmFjayB3aXRoIGhlYWxpbmcgY2FsbGJhY2tcbiAgICBpZiAodGhpcy5vblNtaXRlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25TbWl0ZUNhbGxiYWNrKHNtaXRlUG9zaXRpb24sIGRpcmVjdGlvbiwgKGRhbWFnZURlYWx0RmxhZzogYm9vbGVhbikgPT4ge1xuICAgICAgICAvLyBIYW5kbGUgaGVhbGluZyB3aGVuIGRhbWFnZSBpcyBkZWFsdCBieSB0aGUgdmlzdWFsIGNvbXBvbmVudFxuICAgICAgICBpZiAoZGFtYWdlRGVhbHRGbGFnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogRGFtYWdlIGRldGVjdGVkIGJ5IHZpc3VhbCBjb21wb25lbnQsIHRyaWdnZXJpbmcgaGVhbGluZ2ApO1xuICAgICAgICAgIHRoaXMucGVyZm9ybVNtaXRlSGVhbGluZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzbWl0aW5nIHN0YXRlIGFmdGVyIGFuaW1hdGlvbiBkdXJhdGlvbiAoc2FtZSBhcyB0aGUgU21pdGUgY29tcG9uZW50KVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5pc1NtaXRpbmcgPSBmYWxzZTtcbiAgICB9LCA5MDApOyAvLyAwLjkgc2Vjb25kcyBtYXRjaGVzIHRoZSBhbmltYXRpb24gZHVyYXRpb25cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNtaXRlRGFtYWdlKHNtaXRlUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBzbWl0ZURhbWFnZSA9IDgwO1xuICAgIGNvbnN0IGRhbWFnZVJhZGl1cyA9IDMuMDsgLy8gU21hbGwgcmFkaXVzIGFyb3VuZCBpbXBhY3QgbG9jYXRpb25cbiAgICBsZXQgZGFtYWdlRGVhbHQgPSBmYWxzZTtcblxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzL3BsYXllcnNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcblxuICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgIGlmIChlbnRpdHkuaWQgPT09IHRoaXMucGxheWVyRW50aXR5Py5pZCkgcmV0dXJuOyAvLyBEb24ndCBkYW1hZ2Ugc2VsZlxuXG4gICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG5cbiAgICAgIGlmICghZW50aXR5VHJhbnNmb3JtIHx8ICFlbnRpdHlIZWFsdGggfHwgZW50aXR5SGVhbHRoLmlzRGVhZCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHNtaXRlUG9zaXRpb24uZGlzdGFuY2VUbyhlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gZGFtYWdlUmFkaXVzKSB7XG4gICAgICAgIC8vIEVudGl0eSBpcyB3aXRoaW4gZGFtYWdlIHJhZGl1cyAtIGFwcGx5IGRhbWFnZVxuICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgc21pdGVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5LCAnc21pdGUnKTtcbiAgICAgICAgICBkYW1hZ2VEZWFsdCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZSBkZWFsdCAke3NtaXRlRGFtYWdlfSBkYW1hZ2UgdG8gZW50aXR5ICR7ZW50aXR5LmlkfSBhdCBkaXN0YW5jZSAke2Rpc3RhbmNlLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogQ291bGQgbm90IGZpbmQgQ29tYmF0U3lzdGVtIG9yIHBsYXllckVudGl0eSB0byBkZWFsIGRhbWFnZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOT1RFOiBQVlAgcGxheWVyIGRhbWFnZSBkZXRlY3Rpb24gaXMgbm93IGhhbmRsZWQgYnkgdGhlIFNtaXRlIHZpc3VhbCBjb21wb25lbnRcbiAgICAvLyB0byBwcmV2ZW50IGRvdWJsZSBkYW1hZ2UuIFRoZSB2aXN1YWwgY29tcG9uZW50IHByb3Blcmx5IGhhbmRsZXMgUFZQIGRhbWFnZVxuICAgIC8vIHRocm91Z2ggdGhlIGJyb2FkY2FzdFBsYXllckRhbWFnZSBzeXN0ZW0uXG5cbiAgICByZXR1cm4gZGFtYWdlRGVhbHQ7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1TbWl0ZUhlYWxpbmcoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogTm8gcGxheWVyIGVudGl0eSBhdmFpbGFibGUgZm9yIGhlYWxpbmdgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyJ3MgaGVhbHRoIGNvbXBvbmVudCBhbmQgaGVhbCBmb3IgMjAgSFAgKGxpa2UgUmVhbmltYXRlIGFiaWxpdHkpXG4gICAgY29uc3QgaGVhbHRoQ29tcG9uZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKGhlYWx0aENvbXBvbmVudCkge1xuICAgICAgY29uc3Qgb2xkSGVhbHRoID0gaGVhbHRoQ29tcG9uZW50LmN1cnJlbnRIZWFsdGg7XG4gICAgICBjb25zdCBtYXhIZWFsdGggPSBoZWFsdGhDb21wb25lbnQubWF4SGVhbHRoO1xuXG4gICAgICAvLyBBbHdheXMgYXR0ZW1wdCB0byBoZWFsLCBldmVuIGlmIGF0IGZ1bGwgaGVhbHRoIChoZWFsIG1ldGhvZCBoYW5kbGVzIHRoaXMpXG4gICAgICBjb25zdCBkaWRIZWFsID0gaGVhbHRoQ29tcG9uZW50LmhlYWwoNDApOyAvLyBTbWl0ZSBoZWFsaW5nIGFtb3VudFxuXG4gICAgICBpZiAoZGlkSGVhbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlIFNVQ0NFU1NGVUxMWSBoZWFsZWQgcGxheWVyIGZvciAyMCBIUCEgSGVhbHRoOiAke29sZEhlYWx0aH0gLT4gJHtoZWFsdGhDb21wb25lbnQuY3VycmVudEhlYWx0aH0vJHttYXhIZWFsdGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBQbGF5ZXIgYWxyZWFkeSBhdCBmdWxsIGhlYWx0aCAoJHtoZWFsdGhDb21wb25lbnQuY3VycmVudEhlYWx0aH0vJHttYXhIZWFsdGh9KSAtIG5vIGhlYWxpbmcgbmVlZGVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgU21pdGU6IENSSVRJQ0FMIEVSUk9SIC0gQ291bGQgbm90IGZpbmQgaGVhbHRoIGNvbXBvbmVudCBmb3IgcGxheWVyIGVudGl0eSAke3RoaXMucGxheWVyRW50aXR5LmlkfWApO1xuXG4gICAgICAvLyBGYWxsYmFjazogVHJ5IHRvIGhlYWwgdGhyb3VnaCBnYW1lVUkgaWYgaGVhbHRoIGNvbXBvbmVudCBpcyBub3QgYXZhaWxhYmxlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgICAgICBpZiAoZ2FtZVVJICYmIHR5cGVvZiBnYW1lVUkuZ2FpbkhlYWx0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdhbWVVSS5nYWluSGVhbHRoKDQwKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBGQUxMQkFDSyBoZWFsaW5nIHRocm91Z2ggZ2FtZVVJIC0gaGVhbGVkIGZvciAyMCBIUGApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBDb3VsZCBub3QgaGVhbCB0aHJvdWdoIGZhbGxiYWNrIG1ldGhvZCBlaXRoZXJgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1EZWF0aEdyYXNwKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdXNpbmcgUnVuZWJsYWRlXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVhdGhHcmFzcFRpbWUgPCB0aGlzLmRlYXRoR3Jhc3BDb29sZG93bikge1xuICAgICAgcmV0dXJuOyAvLyBTdGlsbCBvbiBjb29sZG93blxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgZGVhdGggZ3Jhc3BpbmdcbiAgICBpZiAodGhpcy5pc0RlYXRoR3Jhc3BpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICgyNSBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdERlYXRoR3Jhc3AoKSkge1xuICAgICAgY29uc29sZS5sb2coYPCfkoAgRGVhdGhHcmFzcDogTm90IGVub3VnaCBtYW5hIHRvIGNhc3QgKG5lZWQgMjUpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0RGVhdGhHcmFzcFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmlzRGVhdGhHcmFzcGluZyA9IHRydWU7XG5cbiAgICAvLyBTdG9wIHBsYXllciBtb3ZlbWVudCBpbW1lZGlhdGVseSB3aGVuIGNhc3RpbmcgRGVhdGggR3Jhc3BcbiAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS54ID0gMDtcbiAgICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueiA9IDA7XG4gICAgICAgIHBsYXllck1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24obmV3IFZlY3RvcjMoMCwgMCwgMCksIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN1bWUgbWFuYSAoMjUgbWFuYSlcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQmVmb3JlID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgICBjb25zdCBtYW5hQ29uc3VtZWQgPSBnYW1lVUkuY29uc3VtZU1hbmEoMjUpO1xuICAgICAgaWYgKCFtYW5hQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfwn5KAIERlYXRoR3Jhc3A6IEZhaWxlZCB0byBjb25zdW1lIG1hbmEgZGVzcGl0ZSBjYW5DYXN0IGNoZWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYPCfkoAgRGVhdGhHcmFzcDogQ29uc3VtZWQgMjUgbWFuYS4gTWFuYTogJHttYW5hQmVmb3JlfSAtPiAke21hbmFBZnRlcn1gKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGRlYXRoIGdyYXNwIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2socG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZGVhdGggZ3Jhc3Bpbmcgc3RhdGUgYWZ0ZXIgYW5pbWF0aW9uIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmlzRGVhdGhHcmFzcGluZyA9IGZhbHNlO1xuICAgIH0sIDEyMDApOyAvLyAxLjIgc2Vjb25kcyBtYXRjaGVzIHRoZSBhbmltYXRpb24gZHVyYXRpb25cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVdyYWl0aFN0cmlrZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHVzaW5nIFJ1bmVibGFkZVxuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuUlVORUJMQURFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdyYWl0aFN0cmlrZVRpbWUgPCB0aGlzLndyYWl0aFN0cmlrZUNvb2xkb3duKSB7XG4gICAgICByZXR1cm47IC8vIFN0aWxsIG9uIGNvb2xkb3duXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSB3cmFpdGggc3RyaWtpbmdcbiAgICBpZiAodGhpcy5pc1dyYWl0aFN0cmlraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMzAgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RXcmFpdGhTdHJpa2UoKSkge1xuICAgICAgY29uc29sZS5sb2coYPCfkbsgV3JhaXRoU3RyaWtlOiBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCAobmVlZCAzMClgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RXcmFpdGhTdHJpa2VUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5pc1dyYWl0aFN0cmlraW5nID0gdHJ1ZTtcblxuICAgIC8vIFN0b3AgcGxheWVyIG1vdmVtZW50IGltbWVkaWF0ZWx5IHdoZW4gY2FzdGluZyBXcmFpdGggU3RyaWtlXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueCA9IDA7XG4gICAgICAgIHBsYXllck1vdmVtZW50LnZlbG9jaXR5LnogPSAwO1xuICAgICAgICBwbGF5ZXJNb3ZlbWVudC5zZXRNb3ZlRGlyZWN0aW9uKG5ldyBWZWN0b3IzKDAsIDAsIDApLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIG1hbmEgKDMwIG1hbmEpXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc3QgbWFuYUNvbnN1bWVkID0gZ2FtZVVJLmNvbnN1bWVNYW5hKDMwKTtcbiAgICAgIGlmICghbWFuYUNvbnN1bWVkKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign8J+RuyBXcmFpdGhTdHJpa2U6IEZhaWxlZCB0byBjb25zdW1lIG1hbmEgZGVzcGl0ZSBjYW5DYXN0IGNoZWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYPCfkbsgV3JhaXRoU3RyaWtlOiBDb25zdW1lZCAzMCBtYW5hLiBNYW5hOiAke21hbmFCZWZvcmV9IC0+ICR7bWFuYUFmdGVyfWApO1xuICAgIH1cblxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIC8vIFBlcmZvcm0gd3JhaXRoIHN0cmlrZSBkYW1hZ2UgYW5kIGFwcGx5IGNvcnJ1cHRlZCBkZWJ1ZmZcbiAgICB0aGlzLnBlcmZvcm1XcmFpdGhTdHJpa2VEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcblxuICAgIC8vIFRyaWdnZXIgd3JhaXRoIHN0cmlrZSBjYWxsYmFja1xuICAgIGlmICh0aGlzLm9uV3JhaXRoU3RyaWtlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25XcmFpdGhTdHJpa2VDYWxsYmFjayhwb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB3cmFpdGggc3RyaWtpbmcgc3RhdGUgYWZ0ZXIgYW5pbWF0aW9uIGR1cmF0aW9uIChzYW1lIGFzIDJuZCBzd2luZylcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaXNXcmFpdGhTdHJpa2luZyA9IGZhbHNlO1xuICAgIH0sIDc1MCk7IC8vIDAuNzUgc2Vjb25kcyBtYXRjaGVzIHRoZSAybmQgc3dpbmcgYW5pbWF0aW9uIGR1cmF0aW9uXG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1XcmFpdGhTdHJpa2VEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCB0byBjaGVjayBmb3IgZW5lbWllcy9wbGF5ZXJzXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBmYWNpbmcgZGlyZWN0aW9uIChjYW1lcmEgZGlyZWN0aW9uKVxuICAgIGNvbnN0IHBsYXllckRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24ocGxheWVyRGlyZWN0aW9uKTtcbiAgICBwbGF5ZXJEaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgd3JhaXRoU3RyaWtlUmFuZ2UgPSA0LjU7IC8vIFNhbWUgcmFuZ2UgYXMgbWVsZWUgYXR0YWNrc1xuICAgIGNvbnN0IHdyYWl0aFN0cmlrZUFuZ2xlID0gTWF0aC5QSSAvIDI7IC8vIDkwIGRlZ3JlZSBjb25lXG4gICAgY29uc3Qgd3JhaXRoU3RyaWtlRGFtYWdlID0gMTAwOyAvLyBIaWdoIGRhbWFnZSBmb3Igd3JhaXRoIHN0cmlrZVxuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBhbGxFbnRpdGllcykge1xuICAgICAgaWYgKGVudGl0eSA9PT0gdGhpcy5wbGF5ZXJFbnRpdHkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBcbiAgICAgIGlmICghdGFyZ2V0SGVhbHRoIHx8ICF0YXJnZXRUcmFuc2Zvcm0gfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBpbiByYW5nZVxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBpZiAoZGlzdGFuY2UgPiB3cmFpdGhTdHJpa2VSYW5nZSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBpbiBmcm9udCBvZiBwbGF5ZXIgKGNvbmUgYXR0YWNrKVxuICAgICAgY29uc3QgZGlyZWN0aW9uVG9UYXJnZXQgPSBuZXcgVmVjdG9yMygpXG4gICAgICAgIC5zdWJWZWN0b3JzKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbiwgcGxheWVyUG9zaXRpb24pXG4gICAgICAgIC5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgY29uc3QgZG90UHJvZHVjdCA9IHBsYXllckRpcmVjdGlvbi5kb3QoZGlyZWN0aW9uVG9UYXJnZXQpO1xuICAgICAgY29uc3QgYW5nbGVUaHJlc2hvbGQgPSBNYXRoLmNvcyh3cmFpdGhTdHJpa2VBbmdsZSAvIDIpO1xuICAgICAgXG4gICAgICBpZiAoZG90UHJvZHVjdCA8IGFuZ2xlVGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgZGFtYWdlXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCB3cmFpdGhTdHJpa2VEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5ISwgJ3dyYWl0aF9zdHJpa2UnKTtcbiAgICAgICAgaGl0Q291bnQrKztcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IENvcnJ1cHRlZCBkZWJ1ZmZcbiAgICAgICAgdGhpcy5hcHBseUNvcnJ1cHRlZERlYnVmZihlbnRpdHksIHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+RuyBXcmFpdGhTdHJpa2UgaGl0ICR7aGl0Q291bnR9IHRhcmdldHNgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlDb3JydXB0ZWREZWJ1ZmYoZW50aXR5OiBFbnRpdHksIHBvc2l0aW9uOiBWZWN0b3IzLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICBcbiAgICBpZiAoZW5lbXkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gZW5lbXkgLSBhcHBseSBjb3JydXB0ZWQgZGVidWZmIGRpcmVjdGx5XG4gICAgICBlbmVteS5hcHBseUNvcnJ1cHRlZCg4LjAsIGN1cnJlbnRUaW1lKTsgLy8gOCBzZWNvbmQgZHVyYXRpb25cbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBoYXVudGVkIHNvdWwgdmlzdWFsIGVmZmVjdFxuICAgICAgdGhpcy50cmlnZ2VySGF1bnRlZFNvdWxFZmZlY3QocG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGxpa2VseSBhbm90aGVyIHBsYXllciBpbiBQVlAgbW9kZSAtIGJyb2FkY2FzdCBjb3JydXB0ZWQgZGVidWZmXG4gICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJFbnRpdGllcyA9ICh3aW5kb3cgYXMgYW55KS5zZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICBcbiAgICAgIGlmIChzZXJ2ZXJQbGF5ZXJFbnRpdGllcyAmJiBzZXJ2ZXJQbGF5ZXJFbnRpdGllcy5jdXJyZW50KSB7XG4gICAgICAgIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQuZm9yRWFjaCgobG9jYWxFbnRpdHlJZDogbnVtYmVyLCBwbGF5ZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKGxvY2FsRW50aXR5SWQgPT09IGVudGl0eS5pZCkge1xuICAgICAgICAgICAgdGFyZ2V0UGxheWVySWQgPSBwbGF5ZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBORVZFUiBicm9hZGNhc3QgZGVidWZmIHRvIG91cnNlbHZlc1xuICAgICAgaWYgKHRhcmdldFBsYXllcklkICYmIHRhcmdldFBsYXllcklkICE9PSBsb2NhbFNvY2tldElkKSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdCBjb3JydXB0ZWQgZWZmZWN0IHRvIHRoZSB0YXJnZXQgcGxheWVyXG4gICAgICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+RuyBCcm9hZGNhc3RpbmcgY29ycnVwdGVkIGVmZmVjdCB0byBwbGF5ZXIgJHt0YXJnZXRQbGF5ZXJJZH1gKTtcbiAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnY29ycnVwdGVkJywgODAwMCwgcG9zaXRpb24pOyAvLyA4IHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgaGF1bnRlZCBzb3VsIHZpc3VhbCBlZmZlY3RcbiAgICAgICAgdGhpcy50cmlnZ2VySGF1bnRlZFNvdWxFZmZlY3QocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckhhdW50ZWRTb3VsRWZmZWN0KHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgLy8gVHJpZ2dlciBoYXVudGVkIHNvdWwgdmlzdWFsIGVmZmVjdCB0aHJvdWdoIGNhbGxiYWNrXG4gICAgY29uc29sZS5sb2coYPCfkbsgVHJpZ2dlcmluZyBoYXVudGVkIHNvdWwgZWZmZWN0IGF0IHBvc2l0aW9uOiAke3Bvc2l0aW9uLnh9LCAke3Bvc2l0aW9uLnl9LCAke3Bvc2l0aW9uLnp9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgaGF1bnRlZCBzb3VsIGVmZmVjdCBjYWxsYmFjayBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5vbkhhdW50ZWRTb3VsRWZmZWN0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25IYXVudGVkU291bEVmZmVjdENhbGxiYWNrKHBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gc3dpbmcgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICBwdWJsaWMgb25Td29yZFN3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcblxuICAgIC8vIEFkdmFuY2UgY29tYm8gc3RlcCBmb3IgbmV4dCBhdHRhY2tcbiAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gKHRoaXMuc3dvcmRDb21ib1N0ZXAgJSAzICsgMSkgYXMgMSB8IDIgfCAzO1xuXG4gIH1cblxuICAvLyBDYWxsZWQgYnkgcnVuZWJsYWRlIGNvbXBvbmVudCB3aGVuIHNtaXRlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uU21pdGVDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTbWl0aW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcblxuICAgIC8vIFJlc2V0IHNtaXRpbmcgc3RhdGVcbiAgICB0aGlzLmlzU21pdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHJ1bmVibGFkZSBjb21wb25lbnQgd2hlbiBkZWF0aCBncmFzcCBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvbkRlYXRoR3Jhc3BDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNEZWF0aEdyYXNwaW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcblxuICAgIC8vIFJlc2V0IGRlYXRoIGdyYXNwaW5nIHN0YXRlXG4gICAgdGhpcy5pc0RlYXRoR3Jhc3BpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIENhbGxlZCBieSBydW5lYmxhZGUgY29tcG9uZW50IHdoZW4gd3JhaXRoIHN0cmlrZSBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvbldyYWl0aFN0cmlrZUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1dyYWl0aFN0cmlraW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcblxuICAgIC8vIFJlc2V0IHdyYWl0aCBzdHJpa2luZyBzdGF0ZVxuICAgIHRoaXMuaXNXcmFpdGhTdHJpa2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBsZWZ0IGNsaWNrIGZvciBkdWFsIHNhYnJlIGF0dGFja1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzU2t5ZmFsbGluZyAmJiAhdGhpcy5pc1N1bmRlcmluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU2FicmVzTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFEga2V5IGZvciBCYWNrc3RhYiBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1CYWNrc3RhYihwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRSBrZXkgZm9yIFN1bmRlciBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TdW5kZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFIga2V5IGZvciBTa3lmYWxsIGFiaWxpdHkgKHN3aXRjaGVkIGZyb20gRSlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Ta3lmYWxsKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBGIGtleSBmb3IgU3RlYWx0aCBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZicpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nICYmICF0aGlzLmlzQmFja3N0YWJiaW5nICYmICF0aGlzLmlzU3RlYWx0aGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU3RlYWx0aChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgU2t5ZmFsbCBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU2t5ZmFsbE1vdmVtZW50KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBCYWNrc3RhYiBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc0JhY2tzdGFiYmluZykge1xuICAgICAgdGhpcy51cGRhdGVCYWNrc3RhYlN0YXRlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBTdW5kZXIgc3RhdGUgaWYgYWN0aXZlXG4gICAgaWYgKHRoaXMuaXNTdW5kZXJpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU3VuZGVyU3RhdGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIFN0ZWFsdGggc3RhdGUgaWYgYWN0aXZlXG4gICAgaWYgKHRoaXMuaXNTdGVhbHRoaW5nKSB7XG4gICAgICB0aGlzLnVwZGF0ZVN0ZWFsdGhTdGF0ZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHNhYnJlcy1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2FicmVzRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIFNhYnJlcyBkdWFsIGF0dGFjayBpbml0aWF0ZWQnKTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzYWJyZXMgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyIChkdWFsIGF0dGFjaylcbiAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgd2hlbiBzd2luZyBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvblNhYnJlc1N3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgc3dpbmcgY29tcGxldGVkJyk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIHRoYXQgY291bGQgYmUgZGFtYWdlZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSBhbGxFbnRpdGllcy5maWx0ZXIoZW50aXR5ID0+IFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChIZWFsdGgpICYmIFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChUcmFuc2Zvcm0pICYmXG4gICAgICBlbnRpdHkgIT09IHRoaXMucGxheWVyRW50aXR5XG4gICAgKTtcbiAgICBcbiAgICAvLyBTQUJSRVMgREFNQUdFXG4gICAgY29uc3QgYXR0YWNrUmFuZ2UgPSAzLjg7IC8vIFNsaWdodGx5IGxvbmdlciByYW5nZSB0aGFuIHN3b3JkXG4gICAgY29uc3QgYXR0YWNrQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gNjAgZGVncmVlIGNvbmUgKHdpZGVyIHRoYW4gc3dvcmQpXG4gICAgY29uc3QgbGVmdFNhYnJlRGFtYWdlID0gMTk7XG4gICAgY29uc3QgcmlnaHRTYWJyZURhbWFnZSA9IDIzO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEgZGlyZWN0aW9uIGZvciBhdHRhY2sgZGlyZWN0aW9uXG4gICAgY29uc3QgYXR0YWNrRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihhdHRhY2tEaXJlY3Rpb24pO1xuICAgIGF0dGFja0RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldEhlYWx0aCB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpcmVjdGlvbiB0byB0YXJnZXRcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gZGlyZWN0aW9uVG9UYXJnZXQubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkaXN0YW5jZVRvVGFyZ2V0ID4gYXR0YWNrUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgd2l0aGluIGF0dGFjayBjb25lXG4gICAgICBkaXJlY3Rpb25Ub1RhcmdldC5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBhdHRhY2tEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVG9UYXJnZXQgPSBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGRvdFByb2R1Y3QpKSk7XG4gICAgICBcbiAgICAgIGlmIChhbmdsZVRvVGFyZ2V0ID4gYXR0YWNrQW5nbGUgLyAyKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gVGFyZ2V0IGlzIHdpdGhpbiByYW5nZSBhbmQgY29uZSAtIGFwcGx5IGRhbWFnZSBmcm9tIGJvdGggc2FicmVzXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAvLyBMZWZ0IHNhYnJlIGhpdCAoaW1tZWRpYXRlKVxuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBsZWZ0U2FicmVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodCBzYWJyZSBoaXQgKHdpdGggc21hbGwgZGVsYXkpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghdGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgcmlnaHRTYWJyZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7IC8vIDEwMG1zIGRlbGF5IGJldHdlZW4gc2FicmUgaGl0c1xuICAgICAgICBcbiAgICAgICAgaGl0Q291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTa3lmYWxsIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSA8IHRoaXMuc2t5ZmFsbENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RTa3lmYWxsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgXG4gICAgLy8gU3RhcnQgU2t5ZmFsbFxuICAgIHRoaXMuaXNTa3lmYWxsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdhc2NlbmRpbmcnO1xuICAgIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMubGFzdFNreWZhbGxUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi5jb3B5KHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgXG4gICAgLy8gU2V0IHRhcmdldCBoZWlnaHQgKGRvdWJsZSBqdW1wIGhlaWdodClcbiAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5Py5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgdGhpcy5za3lmYWxsT3JpZ2luYWxHcmF2aXR5ID0gcGxheWVyTW92ZW1lbnQuZ3Jhdml0eTtcbiAgICAgIHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHBsYXllck1vdmVtZW50Lmp1bXBGb3JjZSAqIDEuNCk7IC8vIFJlZHVjZWQgaGVpZ2h0IGJ5IDMwJSAod2FzIDJ4LCBub3cgMS40eClcbiAgICAgICAgICAgIFxuICAgICAgLy8gQXBwbHkgdXB3YXJkIHZlbG9jaXR5XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gcGxheWVyTW92ZW1lbnQuanVtcEZvcmNlICogMjsgLy8gU3Ryb25nZXIgaW5pdGlhbCB2ZWxvY2l0eVxuICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IDA7IC8vIERpc2FibGUgZ3Jhdml0eSBkdXJpbmcgYXNjZW50XG4gICAgICAvLyBEb24ndCBkaXNhYmxlIGNhbk1vdmUgYXMgaXQgcHJldmVudHMgYWxsIHBoeXNpY3MgdXBkYXRlcyBpbmNsdWRpbmcgZ3Jhdml0eVxuICAgICAgLy8gSW5zdGVhZCB3ZSdsbCBjb250cm9sIGhvcml6b250YWwgbW92ZW1lbnQgaW4gdGhlIENvbnRyb2xTeXN0ZW1cbiAgICB9XG5cbiAgICBcbiAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uU2t5ZmFsbENhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIHRoaXMub25Ta3lmYWxsQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBTYWJyZSBSZWFwZXIgTWlzdCBlZmZlY3QgYXQgcGxheWVyIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMub25DcmVhdGVTYWJyZU1pc3RFZmZlY3RDYWxsYmFjaykge1xuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2t5ZmFsbDogQ2FsbGluZyBTYWJyZSBSZWFwZXIgTWlzdCBlZmZlY3QgY2FsbGJhY2sgYXQgcG9zaXRpb246JywgcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMub25DcmVhdGVTYWJyZU1pc3RFZmZlY3RDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gU2t5ZmFsbDogU2FicmUgUmVhcGVyIE1pc3QgZWZmZWN0IGNhbGxiYWNrIG5vdCBzZXQhJyk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZVNreWZhbGxNb3ZlbWVudChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAoIXBsYXllck1vdmVtZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZTtcbiAgICBcblxuICAgIFxuICAgIHN3aXRjaCAodGhpcy5za3lmYWxsUGhhc2UpIHtcbiAgICAgIGNhc2UgJ2FzY2VuZGluZyc6XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGFyZ2V0IGhlaWdodCBvciBzdGFydGVkIGZhbGxpbmdcbiAgICAgICAgaWYgKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ID49IHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCB8fCBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdkZXNjZW5kaW5nJztcbiAgICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhdCBwZWFrXG4gICAgICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IHRoaXMuc2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSAqIDMwOyAvLyBGYXN0ZXIgZGVzY2VudFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2Rlc2NlbmRpbmcnOlxuICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSBsYW5kZWQgKGNsb3NlIHRvIG9yaWdpbmFsIGhlaWdodCBvciBvbiBncm91bmQpXG4gICAgICAgIGlmIChwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24ueSA8PSB0aGlzLnNreWZhbGxTdGFydFBvc2l0aW9uLnkgKyAwLjUpIHtcbiAgICAgICAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdsYW5kaW5nJztcbiAgICAgICAgICB0aGlzLnBlcmZvcm1Ta3lmYWxsTGFuZGluZyhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2xhbmRpbmcnOlxuICAgICAgICAvLyBMYW5kaW5nIHBoYXNlIGNvbXBsZXRlXG4gICAgICAgIHRoaXMuY29tcGxldGVTa3lmYWxsQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgLy8gU2FmZXR5IHRpbWVvdXQgKGlmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBlbmQgYWZ0ZXIgNSBzZWNvbmRzKVxuICAgIGlmIChlbGFwc2VkVGltZSA+IDQuMCkge1xuICAgICAgdGhpcy5jb21wbGV0ZVNreWZhbGxBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHBlcmZvcm1Ta3lmYWxsTGFuZGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIERlZmluZSBjdXJyZW50VGltZSBmb3Igc3R1biBlZmZlY3RzXG5cbiAgICAvLyBEZWFsIGRhbWFnZSB0byBlbmVtaWVzIGluIGxhbmRpbmcgYXJlYVxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IGxhbmRpbmdQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBkYW1hZ2VSYWRpdXMgPSA0LjA7IC8vIDQgdW5pdCByYWRpdXNcbiAgICBjb25zdCBza3lmYWxsRGFtYWdlID0gMTI1OyAvLyAxMjUgZGFtYWdlIGFzIHJlcXVlc3RlZFxuXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBhbGxFbnRpdGllcykge1xuICAgICAgaWYgKGVudGl0eSA9PT0gdGhpcy5wbGF5ZXJFbnRpdHkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBcbiAgICAgIGlmICghdGFyZ2V0SGVhbHRoIHx8ICF0YXJnZXRUcmFuc2Zvcm0gfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGRpc3RhbmNlIHRvIGxhbmRpbmcgcG9zaXRpb25cbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9MYW5kaW5nID0gbGFuZGluZ1Bvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlVG9MYW5kaW5nIDw9IGRhbWFnZVJhZGl1cykge1xuICAgICAgICAvLyBBcHBseSBTa3lmYWxsIGRhbWFnZVxuICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgc2t5ZmFsbERhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICBoaXRDb3VudCsrO1xuXG4gICAgICAgICAgLy8gQXBwbHkgc3R1biBlZmZlY3QgKDIgc2Vjb25kcykgdG8gZW5lbWllcyBoaXQgYnkgU2t5ZmFsbFxuICAgICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgICAgaWYgKGVuZW15KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVuZW15IC0gc3R1biBpdFxuICAgICAgICAgICAgZW5lbXkuZnJlZXplKDIuMCwgY3VycmVudFRpbWUpOyAvLyAyIHNlY29uZCBzdHVuIHVzaW5nIGZyZWV6ZSBtZWNoYW5pY3NcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYW5vdGhlciBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBhcHBseSBzdHVuIGRlYnVmZlxuICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBpZiB3ZSdyZSBhYm91dCB0byB0YXJnZXQgb3Vyc2VsdmVzIGJlZm9yZSBicm9hZGNhc3RpbmcgZGVidWZmXG4gICAgICAgICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJFbnRpdGllcyA9ICh3aW5kb3cgYXMgYW55KS5zZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICAgICAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJQbGF5ZXJFbnRpdGllcyAmJiBzZXJ2ZXJQbGF5ZXJFbnRpdGllcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQuZm9yRWFjaCgobG9jYWxFbnRpdHlJZDogbnVtYmVyLCBwbGF5ZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsRW50aXR5SWQgPT09IGVudGl0eS5pZCkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0UGxheWVySWQgPSBwbGF5ZXJJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBORVZFUiBicm9hZGNhc3QgZGVidWZmIHRvIG91cnNlbHZlc1xuICAgICAgICAgICAgaWYgKHRhcmdldFBsYXllcklkICYmIHRhcmdldFBsYXllcklkICE9PSBsb2NhbFNvY2tldElkKSB7XG4gICAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBzdHVuIGVmZmVjdCB0byB0aGUgdGFyZ2V0IHBsYXllclxuICAgICAgICAgICAgICBpZiAodGhpcy5vbkRlYnVmZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrKGVudGl0eS5pZCwgJ3N0dW5uZWQnLCAyMDAwLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSZXNldCBhbGwgU2t5ZmFsbCBzdGF0ZXNcbiAgICB0aGlzLmlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ25vbmUnO1xuICAgIFxuICAgIC8vIFJlc3RvcmUgcGxheWVyIG1vdmVtZW50XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHk7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhbnkgcmVtYWluaW5nIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZUJhY2tzdGFiU3RhdGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLmJhY2tzdGFiU3RhcnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJhY2tzdGFiIGFuaW1hdGlvbiBkdXJhdGlvbiBoYXMgZWxhcHNlZFxuICAgIGlmIChlbGFwc2VkVGltZSA+PSB0aGlzLmJhY2tzdGFiRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuaXNCYWNrc3RhYmJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFN1bmRlciBhYmlsaXR5IGltcGxlbWVudGF0aW9uXG4gIHByaXZhdGUgcGVyZm9ybVN1bmRlcihwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTdW5kZXJUaW1lIDwgdGhpcy5zdW5kZXJDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBlbmVyZ3kgY29zdCAoMzUgZW5lcmd5KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKCFnYW1lVUkgfHwgIWdhbWVVSS5jYW5DYXN0U3VuZGVyKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBnYW1lVUkuY29uc3VtZUVuZXJneSgzNSk7XG4gICAgXG4gICAgLy8gU2V0IGNvb2xkb3duXG4gICAgdGhpcy5sYXN0U3VuZGVyVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IHN1bmRlciBhbmltYXRpb24gKHNhbWUgYXMgYmFja3N0YWIpXG4gICAgdGhpcy5pc1N1bmRlcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdW5kZXJTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIHN1bmRlciBkYW1hZ2Ugd2l0aCBzdGFja2luZyBsb2dpY1xuICAgIHRoaXMucGVyZm9ybVN1bmRlckRhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZVN1bmRlclN0YXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5zdW5kZXJTdGFydFRpbWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgc3VuZGVyIGFuaW1hdGlvbiBkdXJhdGlvbiBoYXMgZWxhcHNlZFxuICAgIGlmIChlbGFwc2VkVGltZSA+PSB0aGlzLnN1bmRlckR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmlzU3VuZGVyaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHBlcmZvcm1TdW5kZXJEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCB0byBjaGVjayBmb3IgZW5lbWllcy9wbGF5ZXJzXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBmYWNpbmcgZGlyZWN0aW9uIChjYW1lcmEgZGlyZWN0aW9uKVxuICAgIGNvbnN0IHBsYXllckRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24ocGxheWVyRGlyZWN0aW9uKTtcbiAgICBwbGF5ZXJEaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgc3VuZGVyUmFuZ2UgPSAzLjU7IC8vIFNhbWUgcmFuZ2UgYXMgYmFja3N0YWJcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYWxsRW50aXRpZXMpIHtcbiAgICAgIGlmIChlbnRpdHkgPT09IHRoaXMucGxheWVyRW50aXR5KSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgaW4gcmFuZ2VcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gcGxheWVyUG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgaWYgKGRpc3RhbmNlID4gc3VuZGVyUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgaW4gZnJvbnQgb2YgcGxheWVyIChjb25lIGF0dGFjaylcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKVxuICAgICAgICAuc3ViVmVjdG9ycyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24sIHBsYXllclBvc2l0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBwbGF5ZXJEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVGhyZXNob2xkID0gTWF0aC5jb3MoTWF0aC5QSSAvIDQpOyAvLyA2MCBkZWdyZWUgY29uZVxuICAgICAgXG4gICAgICBpZiAoZG90UHJvZHVjdCA8IGFuZ2xlVGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgU3VuZGVyIHN0YWNrcyBhbmQgY2FsY3VsYXRlIGRhbWFnZVxuICAgICAgY29uc3QgeyBkYW1hZ2UsIHN0YWNrQ291bnQsIGlzU3R1bm5lZCB9ID0gdGhpcy5hcHBseVN1bmRlclN0YWNrKGVudGl0eS5pZCwgY3VycmVudFRpbWUpO1xuICAgICAgXG4gICAgICAvLyBBcHBseSBkYW1hZ2VcbiAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgZGFtYWdlLFxuICAgICAgICAgIHRoaXMucGxheWVyRW50aXR5ISxcbiAgICAgICAgICAnc3VuZGVyJ1xuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgc3R1biBlZmZlY3QgaWYgYXQgMyBzdGFja3NcbiAgICAgICAgaWYgKGlzU3R1bm5lZCkge1xuICAgICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgICAgaWYgKGVuZW15KSB7XG4gICAgICAgICAgICBlbmVteS5mcmVlemUoNC4wLCBjdXJyZW50VGltZSk7IC8vIDQgc2Vjb25kIHN0dW4gKHVzaW5nIGZyZWV6ZSBtZWNoYW5pY3MgZm9yIG1vdmVtZW50KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdmlzdWFsIHN0dW4gZWZmZWN0IChkaWZmZXJlbnQgZnJvbSBmcmVlemUpXG4gICAgICAgICAgICBhZGRHbG9iYWxTdHVubmVkRW5lbXkoZW50aXR5LmlkLnRvU3RyaW5nKCksIHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEJyb2FkY2FzdCBzdHVuIGVmZmVjdCBmb3IgUFZQICh1c2luZyBuZXcgJ3N0dW5uZWQnIHR5cGUpXG4gICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBpZiB3ZSdyZSBhYm91dCB0byB0YXJnZXQgb3Vyc2VsdmVzIGJlZm9yZSBicm9hZGNhc3RpbmcgZGVidWZmXG4gICAgICAgICAgaWYgKHRoaXMub25EZWJ1ZmZDYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTb2NrZXRJZCA9ICh3aW5kb3cgYXMgYW55KS5sb2NhbFNvY2tldElkO1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyUGxheWVyRW50aXRpZXMgPSAod2luZG93IGFzIGFueSkuc2VydmVyUGxheWVyRW50aXRpZXM7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0UGxheWVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc2VydmVyUGxheWVyRW50aXRpZXMgJiYgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudCkge1xuICAgICAgICAgICAgICBzZXJ2ZXJQbGF5ZXJFbnRpdGllcy5jdXJyZW50LmZvckVhY2goKGxvY2FsRW50aXR5SWQ6IG51bWJlciwgcGxheWVySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEVudGl0eUlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTkVWRVIgYnJvYWRjYXN0IGRlYnVmZiB0byBvdXJzZWx2ZXNcbiAgICAgICAgICAgIGlmICh0YXJnZXRQbGF5ZXJJZCAmJiB0YXJnZXRQbGF5ZXJJZCAhPT0gbG9jYWxTb2NrZXRJZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBCcm9hZGNhc3Rpbmcgc3R1biBlZmZlY3QgdG8gcGxheWVyICR7dGFyZ2V0UGxheWVySWR9IChOT1QgbG9jYWwgcGxheWVyICR7bG9jYWxTb2NrZXRJZH0pYCk7XG4gICAgICAgICAgICAgIHRoaXMub25EZWJ1ZmZDYWxsYmFjayhlbnRpdHkuaWQsICdzdHVubmVkJywgNDAwMCwgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gU2tpcHBpbmcgc3R1biBicm9hZGNhc3QgLSB3b3VsZCB0YXJnZXQgbG9jYWwgcGxheWVyICR7bG9jYWxTb2NrZXRJZH0gb3IgaW52YWxpZCB0YXJnZXQgJHt0YXJnZXRQbGF5ZXJJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGhpdENvdW50Kys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyL3Zpc3VhbCBlZmZlY3RzXG4gICAgICBpZiAodGhpcy5vblN1bmRlckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25TdW5kZXJDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIHBsYXllckRpcmVjdGlvbiwgZGFtYWdlLCBzdGFja0NvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgYXBwbHlTdW5kZXJTdGFjayhlbnRpdHlJZDogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogeyBkYW1hZ2U6IG51bWJlcjsgc3RhY2tDb3VudDogbnVtYmVyOyBpc1N0dW5uZWQ6IGJvb2xlYW4gfSB7XG4gICAgY29uc3Qgc3RhY2tEdXJhdGlvbiA9IDEwLjA7IC8vIDEwIHNlY29uZHNcbiAgICBsZXQgY3VycmVudFN0YWNrcyA9IHRoaXMuc3VuZGVyU3RhY2tzLmdldChlbnRpdHlJZCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhwaXJlZCBzdGFja3Mgb3IgaW5pdGlhbGl6ZSBuZXcgZW50cnlcbiAgICBpZiAoIWN1cnJlbnRTdGFja3MgfHwgKGN1cnJlbnRUaW1lIC0gY3VycmVudFN0YWNrcy5sYXN0QXBwbGllZCkgPiBzdGFja0R1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhY2tzID0geyBzdGFja3M6IDAsIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSwgZHVyYXRpb246IHN0YWNrRHVyYXRpb24gfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRhbWFnZSBiYXNlZCBvbiBjdXJyZW50IHN0YWNrIGNvdW50IChiZWZvcmUgYWRkaW5nIG5ldyBzdGFjaylcbiAgICBjb25zdCBiYXNlRGFtYWdlcyA9IFs2MCwgNzAsIDgwLCA5MF07IC8vIDAsIDEsIDIsIDMgc3RhY2tzXG4gICAgY29uc3QgZGFtYWdlID0gYmFzZURhbWFnZXNbTWF0aC5taW4oY3VycmVudFN0YWNrcy5zdGFja3MsIDMpXTtcbiAgICBcbiAgICBsZXQgaXNTdHVubmVkID0gZmFsc2U7XG4gICAgbGV0IG5ld1N0YWNrQ291bnQgPSBjdXJyZW50U3RhY2tzLnN0YWNrcztcbiAgICBcbiAgICAvLyBBcHBseSBuZXcgc3RhY2tcbiAgICBpZiAoY3VycmVudFN0YWNrcy5zdGFja3MgPCAzKSB7XG4gICAgICBuZXdTdGFja0NvdW50ID0gY3VycmVudFN0YWNrcy5zdGFja3MgKyAxO1xuICAgICAgdGhpcy5zdW5kZXJTdGFja3Muc2V0KGVudGl0eUlkLCB7XG4gICAgICAgIHN0YWNrczogbmV3U3RhY2tDb3VudCxcbiAgICAgICAgbGFzdEFwcGxpZWQ6IGN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogc3RhY2tEdXJhdGlvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IDMgc3RhY2tzLCBhcHBseSBzdHVuIGFuZCByZXNldCB0byAwIHN0YWNrc1xuICAgICAgaXNTdHVubmVkID0gdHJ1ZTtcbiAgICAgIG5ld1N0YWNrQ291bnQgPSAwO1xuICAgICAgdGhpcy5zdW5kZXJTdGFja3Muc2V0KGVudGl0eUlkLCB7XG4gICAgICAgIHN0YWNrczogMCxcbiAgICAgICAgbGFzdEFwcGxpZWQ6IGN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogc3RhY2tEdXJhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGRhbWFnZSwgc3RhY2tDb3VudDogbmV3U3RhY2tDb3VudCwgaXNTdHVubmVkIH07XG4gIH1cblxuICAvLyBBcHBseSBidXJuaW5nIHN0YWNrIGFuZCBjYWxjdWxhdGUgZGFtYWdlIGJvbnVzXG4gIHB1YmxpYyBhcHBseUJ1cm5pbmdTdGFjayhlbnRpdHlJZDogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyLCBpc0VudHJvcGljQm9sdDogYm9vbGVhbiA9IHRydWUpOiB7IGRhbWFnZUJvbnVzOiBudW1iZXI7IHN0YWNrQ291bnQ6IG51bWJlciB9IHtcbiAgICBjb25zdCBzdGFja0R1cmF0aW9uID0gNS4wOyAvLyA1IHNlY29uZHNcbiAgICBjb25zdCBtYXhTdGFja3MgPSAxNTsgLy8gTWF4aW11bSAxNSBzdGFja3NcbiAgICBsZXQgY3VycmVudFN0YWNrcyA9IHRoaXMuYnVybmluZ1N0YWNrcy5nZXQoZW50aXR5SWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgc3RhY2tzIG9yIGluaXRpYWxpemUgbmV3IGVudHJ5XG4gICAgaWYgKCFjdXJyZW50U3RhY2tzIHx8IChjdXJyZW50VGltZSAtIGN1cnJlbnRTdGFja3MubGFzdEFwcGxpZWQpID4gc3RhY2tEdXJhdGlvbikge1xuICAgICAgY3VycmVudFN0YWNrcyA9IHsgc3RhY2tzOiAwLCBsYXN0QXBwbGllZDogY3VycmVudFRpbWUsIGR1cmF0aW9uOiBzdGFja0R1cmF0aW9uIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBkYW1hZ2UgYm9udXMgYmFzZWQgb24gY3VycmVudCBzdGFjayBjb3VudCAoYmVmb3JlIGFkZGluZyBuZXcgc3RhY2spXG4gICAgbGV0IGRhbWFnZUJvbnVzID0gMDtcbiAgICBpZiAoaXNFbnRyb3BpY0JvbHQpIHtcbiAgICAgIC8vIEVudHJvcGljIEJvbHQ6ICsxIGRhbWFnZSBwZXIgc3RhY2tcbiAgICAgIGRhbWFnZUJvbnVzID0gY3VycmVudFN0YWNrcy5zdGFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyb3NzZW50cm9weSBCb2x0OiArMjAgZGFtYWdlIHBlciBzdGFja1xuICAgICAgZGFtYWdlQm9udXMgPSBjdXJyZW50U3RhY2tzLnN0YWNrcyAqIDIwO1xuICAgIH1cbiAgICBcbiAgICBsZXQgbmV3U3RhY2tDb3VudCA9IGN1cnJlbnRTdGFja3Muc3RhY2tzO1xuICAgIFxuICAgIC8vIEFwcGx5IG5ldyBzdGFjayAodXAgdG8gbWF4aW11bSlcbiAgICBpZiAoY3VycmVudFN0YWNrcy5zdGFja3MgPCBtYXhTdGFja3MpIHtcbiAgICAgIG5ld1N0YWNrQ291bnQgPSBjdXJyZW50U3RhY2tzLnN0YWNrcyArIDE7XG4gICAgICB0aGlzLmJ1cm5pbmdTdGFja3Muc2V0KGVudGl0eUlkLCB7XG4gICAgICAgIHN0YWNrczogbmV3U3RhY2tDb3VudCxcbiAgICAgICAgbGFzdEFwcGxpZWQ6IGN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogc3RhY2tEdXJhdGlvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IG1heCBzdGFja3MsIGp1c3QgcmVmcmVzaCB0aGUgZHVyYXRpb25cbiAgICAgIHRoaXMuYnVybmluZ1N0YWNrcy5zZXQoZW50aXR5SWQsIHtcbiAgICAgICAgc3RhY2tzOiBtYXhTdGFja3MsXG4gICAgICAgIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IHN0YWNrRHVyYXRpb25cbiAgICAgIH0pO1xuICAgICAgbmV3U3RhY2tDb3VudCA9IG1heFN0YWNrcztcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IGJ1cm5pbmcgZGVidWZmIGVmZmVjdCBpbiBQVlAgbW9kZVxuICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2sgJiYgbmV3U3RhY2tDb3VudCA+IDApIHtcbiAgICAgIC8vIEZpbmQgdGhlIGVudGl0eSB0byBnZXQgaXRzIHBvc2l0aW9uXG4gICAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eShlbnRpdHlJZCk7XG4gICAgICBpZiAodGFyZ2V0RW50aXR5KSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldEVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHBvc2l0aW9uIHdpdGggc3RhY2sgY291bnQgaW5mb3JtYXRpb25cbiAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhTdGFja3MgPSB0cmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAocG9zaXRpb25XaXRoU3RhY2tzIGFzIGFueSkuc3RhY2tDb3VudCA9IG5ld1N0YWNrQ291bnQ7IC8vIEF0dGFjaCBzdGFjayBjb3VudCB0byBwb3NpdGlvblxuICAgICAgICAgIHRoaXMub25EZWJ1ZmZDYWxsYmFjayhlbnRpdHlJZCwgJ2J1cm5pbmcnLCBzdGFja0R1cmF0aW9uICogMTAwMCwgcG9zaXRpb25XaXRoU3RhY2tzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBkYW1hZ2VCb251cywgc3RhY2tDb3VudDogbmV3U3RhY2tDb3VudCB9O1xuICB9XG4gIFxuICAvLyBDbGVhbiB1cCBleHBpcmVkIFN1bmRlciBzdGFja3MgcGVyaW9kaWNhbGx5XG4gIHByaXZhdGUgY2xlYW51cFN1bmRlclN0YWNrcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSAxMC4wO1xuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgdG8gYXZvaWQgaXRlcmF0aW9uIGlzc3Vlc1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuc3VuZGVyU3RhY2tzLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIHN0YWNrRGF0YV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKChjdXJyZW50VGltZSAtIHN0YWNrRGF0YS5sYXN0QXBwbGllZCkgPiBzdGFja0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLmRlbGV0ZShlbnRpdHlJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgZXhwaXJlZCBCdXJuaW5nIHN0YWNrcyBwZXJpb2RpY2FsbHlcbiAgcHJpdmF0ZSBjbGVhbnVwQnVybmluZ1N0YWNrcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSA1LjA7XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBhcnJheSB0byBhdm9pZCBpdGVyYXRpb24gaXNzdWVzXG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5idXJuaW5nU3RhY2tzLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIHN0YWNrRGF0YV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKChjdXJyZW50VGltZSAtIHN0YWNrRGF0YS5sYXN0QXBwbGllZCkgPiBzdGFja0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuYnVybmluZ1N0YWNrcy5kZWxldGUoZW50aXR5SWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RlYWx0aCBhYmlsaXR5IGltcGxlbWVudGF0aW9uXG4gIHByaXZhdGUgcGVyZm9ybVN0ZWFsdGgocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3RlYWx0aFRpbWUgPCB0aGlzLnN0ZWFsdGhDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBObyBlbmVyZ3kgY29zdCBmb3IgU3RlYWx0aCBhYmlsaXR5XG4gICAgXG4gICAgLy8gU2V0IGNvb2xkb3duXG4gICAgdGhpcy5sYXN0U3RlYWx0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBzdGVhbHRoIGFuaW1hdGlvblxuICAgIHRoaXMuaXNTdGVhbHRoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN0ZWFsdGhTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBDcmVhdGUgU2FicmUgUmVhcGVyIE1pc3QgZWZmZWN0IGF0IHBsYXllciBwb3NpdGlvblxuICAgIGlmICh0aGlzLm9uQ3JlYXRlU2FicmVNaXN0RWZmZWN0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25DcmVhdGVTYWJyZU1pc3RFZmZlY3RDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IGJyb2FkY2FzdCBzdGVhbHRoIHN0YXRlIGltbWVkaWF0ZWx5IC0gd2FpdCBmb3IgaW52aXNpYmlsaXR5IGFjdGl2YXRpb25cbiAgICBcbiAgICAvLyBTY2hlZHVsZSBpbnZpc2liaWxpdHkgYWN0aXZhdGlvbiBhZnRlciBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNTdGVhbHRoaW5nKSB7IC8vIE9ubHkgYWN0aXZhdGUgaWYgc3RlYWx0aCB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMuaXNJbnZpc2libGUgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+ltyBTdGVhbHRoOiBQbGF5ZXIgaXMgbm93IGludmlzaWJsZScpO1xuICAgICAgICBcbiAgICAgICAgLy8gQnJvYWRjYXN0IGludmlzaWJpbGl0eSBzdGF0ZSB0byBvdGhlciBwbGF5ZXJzXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0U3RlYWx0aFN0YXRlKHRydWUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuc3RlYWx0aERlbGF5RHVyYXRpb24gKiAxMDAwKTtcbiAgICBcbiAgICAvLyBTY2hlZHVsZSBpbnZpc2liaWxpdHkgZGVhY3RpdmF0aW9uIHdpdGggcHJvcGVyIGNsZWFudXBcbiAgICBjb25zdCB0b3RhbFN0ZWFsdGhEdXJhdGlvbiA9IHRoaXMuc3RlYWx0aERlbGF5RHVyYXRpb24gKyB0aGlzLnN0ZWFsdGhJbnZpc2liaWxpdHlEdXJhdGlvbjtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNTdGVhbHRoaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6W3IFN0ZWFsdGg6IER1cmF0aW9uIGV4cGlyZWQsIGVuZGluZyBzdGVhbHRoIGVmZmVjdCcpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBjbGVhbiB1cCBhbGwgc3RlYWx0aCBzdGF0ZXNcbiAgICAgICAgdGhpcy5pc0ludmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RlYWx0aGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0ZWFsdGhTdGFydFRpbWUgPSAwO1xuXG4gICAgICAgIC8vIEZvcmNlIGJyb2FkY2FzdCB0aGUgdmlzaWJpbGl0eSBzdGF0ZSB0byBlbnN1cmUgYWxsIGNsaWVudHMgc2VlIHRoZSBwbGF5ZXIgYWdhaW5cbiAgICAgICAgdGhpcy5icm9hZGNhc3RTdGVhbHRoU3RhdGUoZmFsc2UpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6W3IFN0ZWFsdGg6IFBsYXllciBpcyBub3cgdmlzaWJsZSBhZ2FpbicpO1xuICAgICAgfVxuICAgIH0sIHRvdGFsU3RlYWx0aER1cmF0aW9uICogMTAwMCk7XG4gIH1cbiAgXG4gIHByaXZhdGUgdXBkYXRlU3RlYWx0aFN0YXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gT25seSBjaGVjayBpZiBzdGVhbHRoIHN0YXRlIG5lZWRzIGNsZWFudXAgaWYgd2UgaGF2ZSBhbiBhY3RpdmUgc3RlYWx0aCBlZmZlY3RcbiAgICBpZiAoIXRoaXMuaXNTdGVhbHRoaW5nIHx8IHRoaXMuc3RlYWx0aFN0YXJ0VGltZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc3RlYWx0aFN0YXJ0VGltZTtcbiAgICBjb25zdCB0b3RhbFN0ZWFsdGhEdXJhdGlvbiA9IHRoaXMuc3RlYWx0aERlbGF5RHVyYXRpb24gKyB0aGlzLnN0ZWFsdGhJbnZpc2liaWxpdHlEdXJhdGlvbjtcblxuICAgIC8vIE9ubHkgY2xlYW4gdXAgaWYgdGhlIHNldFRpbWVvdXQgbWlnaHQgaGF2ZSBmYWlsZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgLy8gVGhpcyBpcyBhIHNhZmV0eSBuZXQsIG5vdCB0aGUgcHJpbWFyeSBjbGVhbnVwIG1lY2hhbmlzbVxuICAgIGlmIChlbGFwc2VkVGltZSA+PSB0b3RhbFN0ZWFsdGhEdXJhdGlvbiArIDEuMCkgeyAvLyBBZGQgMSBzZWNvbmQgYnVmZmVyXG4gICAgICBjb25zb2xlLmxvZygn8J+ltyBTdGVhbHRoOiBTYWZldHkgY2xlYW51cCB0cmlnZ2VyZWQgLSBzZXRUaW1lb3V0IG1heSBoYXZlIGZhaWxlZCcpO1xuXG4gICAgICB0aGlzLmlzU3RlYWx0aGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0ludmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGVhbHRoU3RhcnRUaW1lID0gMDtcblxuICAgICAgLy8gRW1lcmdlbmN5IGJyb2FkY2FzdCBpbiBjYXNlIHRoZSBub3JtYWwgYnJvYWRjYXN0IGZhaWxlZFxuICAgICAgdGhpcy5icm9hZGNhc3RTdGVhbHRoU3RhdGUoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBicm9hZGNhc3RTdGVhbHRoU3RhdGUoaXNJbnZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyhg8J+ltyBCcm9hZGNhc3Rpbmcgc3RlYWx0aCBzdGF0ZTogJHtpc0ludmlzaWJsZSA/ICdpbnZpc2libGUnIDogJ3Zpc2libGUnfWApO1xuXG4gICAgLy8gQnJvYWRjYXN0IHN0ZWFsdGggc3RhdGUgdGhyb3VnaCB0aGUgbXVsdGlwbGF5ZXIgc3lzdGVtXG4gICAgY29uc3QgbXVsdGlwbGF5ZXJDb250ZXh0ID0gKHdpbmRvdyBhcyBhbnkpLm11bHRpcGxheWVyQ29udGV4dDtcbiAgICBpZiAobXVsdGlwbGF5ZXJDb250ZXh0ICYmIG11bHRpcGxheWVyQ29udGV4dC5icm9hZGNhc3RQbGF5ZXJTdGVhbHRoKSB7XG4gICAgICBtdWx0aXBsYXllckNvbnRleHQuYnJvYWRjYXN0UGxheWVyU3RlYWx0aChpc0ludmlzaWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTXVsdGlwbGF5ZXIgY29udGV4dCBub3QgYXZhaWxhYmxlIGZvciBzdGVhbHRoIGJyb2FkY2FzdCcpO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSByZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICB0aGlzLmlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ25vbmUnO1xuICAgIHRoaXMuaXNCYWNrc3RhYmJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3VuZGVyaW5nID0gZmFsc2U7XG5cbiAgICAvLyBDbGVhbiB1cCBzdGVhbHRoIHN0YXRlIGFuZCBlbnN1cmUgdmlzaWJpbGl0eSBpcyByZXN0b3JlZFxuICAgIGlmICh0aGlzLmlzU3RlYWx0aGluZyB8fCB0aGlzLmlzSW52aXNpYmxlKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+ltyBTdGVhbHRoOiBDbGVhbmluZyB1cCBzdGVhbHRoIHN0YXRlIGR1ZSB0byB3ZWFwb24gc3dpdGNoJyk7XG4gICAgICB0aGlzLmlzU3RlYWx0aGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0ludmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGVhbHRoU3RhcnRUaW1lID0gMDtcblxuICAgICAgLy8gQnJvYWRjYXN0IHZpc2liaWxpdHkgcmVzdG9yYXRpb24gd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgdGhpcy5icm9hZGNhc3RTdGVhbHRoU3RhdGUoZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuaXNEaXZpbmVTdG9ybWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTd29yZENoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0RlZmxlY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ29sb3NzdXNTdHJpa2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNXcmFpdGhTdHJpa2luZyA9IGZhbHNlOyAvLyBSZXNldCBXcmFpdGhTdHJpa2Ugd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgIHRoaXMuY29ycnVwdGVkQXVyYUFjdGl2ZSA9IGZhbHNlOyAvLyBSZXNldCBDb3JydXB0ZWQgQXVyYSB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG5cbiAgICAvLyBDbGVhciBTdW5kZXIgc3RhY2tzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICB0aGlzLnN1bmRlclN0YWNrcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXIgQ29ycnVwdGVkIEF1cmEgc2xvd2VkIGVudGl0aWVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICB0aGlzLmNvcnJ1cHRlZEF1cmFTbG93ZWRFbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXIgYWN0aXZlIGRlYnVmZiBlZmZlY3RzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnMgKGZvciBzdHVuIGRldGVjdGlvbilcbiAgICB0aGlzLmFjdGl2ZURlYnVmZkVmZmVjdHMuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgdG9nZ2xlQ29ycnVwdGVkQXVyYShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgdG8gYWN0aXZhdGUgKG1pbmltdW0gOCBtYW5hKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKCF0aGlzLmNvcnJ1cHRlZEF1cmFBY3RpdmUgJiYgZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdENvcnJ1cHRlZEF1cmEoKSkge1xuICAgICAgcmV0dXJuOyAvLyBOb3QgZW5vdWdoIG1hbmEgdG8gYWN0aXZhdGVcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgdGhlIGF1cmFcbiAgICB0aGlzLmNvcnJ1cHRlZEF1cmFBY3RpdmUgPSAhdGhpcy5jb3JydXB0ZWRBdXJhQWN0aXZlO1xuXG4gICAgLy8gUmVzZXQgbWFuYSBkcmFpbiB0aW1lciB3aGVuIGFjdGl2YXRpbmdcbiAgICBpZiAodGhpcy5jb3JydXB0ZWRBdXJhQWN0aXZlKSB7XG4gICAgICB0aGlzLmxhc3RNYW5hRHJhaW5UaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFsbCBzbG93ZWQgZW50aXRpZXMgd2hlbiBkZWFjdGl2YXRpbmdcbiAgICAgIHRoaXMuY29ycnVwdGVkQXVyYVNsb3dlZEVudGl0aWVzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBjYWxsYmFjayB0byB1cGRhdGUgdmlzdWFsIGNvbXBvbmVudFxuICAgIGlmICh0aGlzLm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrKHRoaXMuY29ycnVwdGVkQXVyYUFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb3JydXB0ZWRBdXJhRWZmZWN0cyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBIYW5kbGUgbWFuYSBkcmFpbmluZyAoOCBtYW5hIHBlciBzZWNvbmQpXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0TWFuYURyYWluVGltZSA+PSAxLjApIHtcbiAgICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICAgIGNvbnN0IG1hbmFDb25zdW1lZCA9IGdhbWVVSS5jb25zdW1lTWFuYSh0aGlzLmNvcnJ1cHRlZEF1cmFNYW5hQ29zdCk7XG4gICAgICAgIGlmICghbWFuYUNvbnN1bWVkKSB7XG4gICAgICAgICAgLy8gTm90IGVub3VnaCBtYW5hIC0gZGVhY3RpdmF0ZSBhdXJhXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkoAgQ29ycnVwdGVkIEF1cmE6IE5vdCBlbm91Z2ggbWFuYSwgZGVhY3RpdmF0aW5nIGF1cmEnKTtcbiAgICAgICAgICB0aGlzLmNvcnJ1cHRlZEF1cmFBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvcnJ1cHRlZEF1cmFTbG93ZWRFbnRpdGllcy5jbGVhcigpO1xuICAgICAgICAgIGlmICh0aGlzLm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdE1hbmFEcmFpblRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBzbG93IGVmZmVjdCB0byBlbmVtaWVzL3BsYXllcnMgd2l0aGluIHJhbmdlXG4gICAgdGhpcy5hcHBseUNvcnJ1cHRlZEF1cmFTbG93KHBsYXllclBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gIH1cblxuICBwcml2YXRlIGFwcGx5Q29ycnVwdGVkQXVyYVNsb3cocGxheWVyUG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgaWYgKGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47IC8vIERvbid0IHNsb3cgc2VsZlxuXG4gICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbnRpdHlNb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5TW92ZW1lbnQpIHJldHVybjtcblxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBjb25zdCBpc0luUmFuZ2UgPSBkaXN0YW5jZSA8PSB0aGlzLmNvcnJ1cHRlZEF1cmFSYW5nZTtcbiAgICAgIGNvbnN0IHdhc1Nsb3dlZCA9IHRoaXMuY29ycnVwdGVkQXVyYVNsb3dlZEVudGl0aWVzLmdldChlbnRpdHkuaWQpIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoaXNJblJhbmdlICYmICF3YXNTbG93ZWQpIHtcbiAgICAgICAgLy8gRW50aXR5IGp1c3QgZW50ZXJlZCByYW5nZSAtIGFwcGx5IHNsb3dcbiAgICAgICAgZW50aXR5TW92ZW1lbnQubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSB0aGlzLmNvcnJ1cHRlZEF1cmFTbG93RWZmZWN0O1xuICAgICAgICB0aGlzLmNvcnJ1cHRlZEF1cmFTbG93ZWRFbnRpdGllcy5zZXQoZW50aXR5LmlkLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzSW5SYW5nZSAmJiB3YXNTbG93ZWQpIHtcbiAgICAgICAgLy8gRW50aXR5IGp1c3QgbGVmdCByYW5nZSAtIHJlbW92ZSBzbG93XG4gICAgICAgIGVudGl0eU1vdmVtZW50Lm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgICAgICB0aGlzLmNvcnJ1cHRlZEF1cmFTbG93ZWRFbnRpdGllcy5kZWxldGUoZW50aXR5LmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGxiYWNrIGZvciBDb3JydXB0ZWQgQXVyYSB0b2dnbGVcbiAgcHJpdmF0ZSBvbkNvcnJ1cHRlZEF1cmFUb2dnbGVDYWxsYmFjaz86IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIENvbG9zc3VzIFN0cmlrZSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25Db2xvc3N1c1N0cmlrZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIHJhZ2VTcGVudDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBzZXRDb3JydXB0ZWRBdXJhVG9nZ2xlQ2FsbGJhY2soY2FsbGJhY2s6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29sb3NzdXNTdHJpa2VDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIHJhZ2VTcGVudDogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNvbG9zc3VzU3RyaWtlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8vIEJhY2tzdGFiIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtQmFja3N0YWIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFja3N0YWJUaW1lIDwgdGhpcy5iYWNrc3RhYkNvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RCYWNrc3RhYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgIFxuICAgIC8vIFNldCBjb29sZG93blxuICAgIHRoaXMubGFzdEJhY2tzdGFiVGltZSA9IGN1cnJlbnRUaW1lO1xuICBcbiAgICBcbiAgICAvLyBTdGFydCBiYWNrc3RhYiBhbmltYXRpb25cbiAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmJhY2tzdGFiU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXIvdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgdGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24sIDc1LCBmYWxzZSk7IC8vIEJhc2UgZGFtYWdlLCBub3QgYmFja3N0YWIgYnkgZGVmYXVsdFxuICAgIH1cbiAgICBcbiAgICAvLyBQZXJmb3JtIGJhY2tzdGFiIGRhbWFnZVxuICAgIHRoaXMucGVyZm9ybUJhY2tzdGFiRGFtYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1CYWNrc3RhYkRhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzL3BsYXllcnNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgcGxheWVyRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihwbGF5ZXJEaXJlY3Rpb24pO1xuICAgIHBsYXllckRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCBiYWNrc3RhYlJhbmdlID0gNC4yNTsgLy8gU2FicmUgbWVsZWUgcmFuZ2VcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllckVudGl0eSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIHJhbmdlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA+IGJhY2tzdGFiUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgaW4gZnJvbnQgb2YgcGxheWVyIChjb25lIGF0dGFjaylcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKVxuICAgICAgICAuc3ViVmVjdG9ycyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24sIHBsYXllclBvc2l0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBwbGF5ZXJEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVGhyZXNob2xkID0gTWF0aC5jb3MoTWF0aC5QSSAvIDMpOyAvLyA2MCBkZWdyZWUgY29uZVxuICAgICAgXG4gICAgICBpZiAoZG90UHJvZHVjdCA8IGFuZ2xlVGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBiYWNrc3RhYiAoYXR0YWNraW5nIGZyb20gYmVoaW5kIHRoZSB0YXJnZXQpXG4gICAgICBsZXQgaXNCYWNrc3RhYiA9IGZhbHNlO1xuICAgICAgbGV0IGRhbWFnZSA9IDc1OyAvLyBCYXNlIGRhbWFnZVxuICAgICAgXG4gICAgICAvLyBGb3IgUFZQIHBsYXllcnMsIGNoZWNrIGlmIHdlJ3JlIGJlaGluZCB0aGVtXG4gICAgICBjb25zdCBwdnBQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnM7XG4gICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICBcbiAgICAgIGlmIChwdnBQbGF5ZXJzICYmIGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgdGFyZ2V0IHBsYXllciBpbiBQVlAgcGxheWVycyBtYXBcbiAgICAgICAgbGV0IHRhcmdldFBsYXllciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgW3BsYXllcklkLCBwbGF5ZXJdIG9mIHB2cFBsYXllcnMpIHtcbiAgICAgICAgICBpZiAocGxheWVySWQgIT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHBsYXllci5wb3NpdGlvbi54LCBwbGF5ZXIucG9zaXRpb24ueSwgcGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICAgICAgaWYgKHBsYXllclBvcy5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgPCAwLjUpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0UGxheWVyID0gcGxheWVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXRQbGF5ZXIpIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGFyZ2V0J3MgZmFjaW5nIGRpcmVjdGlvbiBmcm9tIHRoZWlyIHJvdGF0aW9uXG4gICAgICAgICAgY29uc3QgdGFyZ2V0RmFjaW5nRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoXG4gICAgICAgICAgICBNYXRoLnNpbih0YXJnZXRQbGF5ZXIucm90YXRpb24ueSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5jb3ModGFyZ2V0UGxheWVyLnJvdGF0aW9uLnkpXG4gICAgICAgICAgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZWN0b3IgZnJvbSB0YXJnZXQgdG8gYXR0YWNrZXJcbiAgICAgICAgICBjb25zdCBhdHRhY2tlckRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgICAgIC5zdWJWZWN0b3JzKHBsYXllclBvc2l0aW9uLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pXG4gICAgICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYXR0YWNrZXIgaXMgYmVoaW5kIHRhcmdldCAoZG90IHByb2R1Y3QgPCAwIG1lYW5zIG9wcG9zaXRlIGRpcmVjdGlvbilcbiAgICAgICAgICBjb25zdCBiZWhpbmREb3RQcm9kdWN0ID0gdGFyZ2V0RmFjaW5nRGlyZWN0aW9uLmRvdChhdHRhY2tlckRpcmVjdGlvbik7XG4gICAgICAgICAgaXNCYWNrc3RhYiA9IGJlaGluZERvdFByb2R1Y3QgPCAtMC4zOyAvLyA3MCBkZWdyZWUgY29uZSBiZWhpbmQgdGFyZ2V0XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGlzQmFja3N0YWIpIHtcbiAgICAgICAgICAgIGRhbWFnZSA9IDE3NTsgLy8gQmFja3N0YWIgZGFtYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBzdHVubmVkIChmb3IgZW5lcmd5IHJlZnVuZClcbiAgICAgIGxldCBpc1RhcmdldFN0dW5uZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGVuZW15IHN0dW4gc3RhdHVzIChzaW5nbGUgcGxheWVyIG1vZGUpXG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgaWYgKGVuZW15KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVuZW15IGlzIGN1cnJlbnRseSBmcm96ZW4vc3R1bm5lZFxuICAgICAgICBpc1RhcmdldFN0dW5uZWQgPSBlbmVteS5pc0Zyb3plbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBQVlAgcGxheWVyIHN0dW4gc3RhdHVzIHVzaW5nIENvbnRyb2xTeXN0ZW0ncyBpbnRlcm5hbCB0cmFja2luZ1xuICAgICAgICBpc1RhcmdldFN0dW5uZWQgPSB0aGlzLmlzUGxheWVyU3R1bm5lZChlbnRpdHkuaWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBkYW1hZ2VcbiAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgZGFtYWdlLFxuICAgICAgICAgIHRoaXMucGxheWVyRW50aXR5ISxcbiAgICAgICAgICAnYmFja3N0YWInXG4gICAgICAgICk7XG5cbiAgICAgICAgaGl0Q291bnQrKztcblxuICAgICAgICAvLyBSZWZ1bmQgZW5lcmd5IGlmIHRhcmdldCBpcyBzdHVubmVkICg2MCBlbmVyZ3kpXG4gICAgICAgIGlmIChpc1RhcmdldFN0dW5uZWQpIHtcbiAgICAgICAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgICAgICAgIGlmIChnYW1lVUkgJiYgZ2FtZVVJLmdhaW5FbmVyZ3kpIHtcbiAgICAgICAgICAgIGdhbWVVSS5nYWluRW5lcmd5KDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBmYWNpbmcgZGlyZWN0aW9uIChjYW1lcmEgZGlyZWN0aW9uKVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gTWVsZWUgYXR0YWNrIHBhcmFtZXRlcnMgLSBpbmNyZWFzZWQgZm9yIFBWUCBjb21iYXRcbiAgICBjb25zdCBtZWxlZVJhbmdlID0gNC41OyAvLyBJbmNyZWFzZWQgYXR0YWNrIHJhbmdlIGZvciBQVlBcbiAgICBjb25zdCBtZWxlZUFuZ2xlID0gTWF0aC5QSSAvIDI7IC8vIDEyMCBkZWdyZWUgY29uZSAoNjAgZGVncmVlcyBlYWNoIHNpZGUpXG4gICAgXG4gICAgLy8gQmFzZSBkYW1hZ2UgdmFsdWVzIGJhc2VkIG9uIGNvbWJvIHN0ZXAgYW5kIHdlYXBvbiB0eXBlXG4gICAgbGV0IGJhc2VEYW1hZ2UgPSA0NTsgLy8gRGVmYXVsdCBiYXNlIGRhbWFnZVxuXG4gICAgLy8gV2VhcG9uLXNwZWNpZmljIGRhbWFnZSBzY2FsaW5nXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgLy8gU3dvcmQgZGFtYWdlIHZhbHVlc1xuICAgICAgc3dpdGNoICh0aGlzLnN3b3JkQ29tYm9TdGVwKSB7XG4gICAgICAgIGNhc2UgMTogYmFzZURhbWFnZSA9IDQwOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBiYXNlRGFtYWdlID0gNDU7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGJhc2VEYW1hZ2UgPSA1NTsgYnJlYWs7IC8vIEZpbmlzaGVyIGRvZXMgbW9yZSBkYW1hZ2VcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIC8vIFJ1bmVibGFkZSBkYW1hZ2UgdmFsdWVzXG4gICAgICBzd2l0Y2ggKHRoaXMuc3dvcmRDb21ib1N0ZXApIHtcbiAgICAgICAgY2FzZSAxOiBiYXNlRGFtYWdlID0gMzA7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGJhc2VEYW1hZ2UgPSAzNTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogYmFzZURhbWFnZSA9IDQ1OyBicmVhazsgLy8gRmluaXNoZXIgZG9lcyBtb3JlIGRhbWFnZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgY29tYmF0IHN5c3RlbSB0byBhcHBseSBkYW1hZ2VcbiAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgIFxuICAgIC8vIFRyYWNrIGVuZW1pZXMgaGl0IGZvciByYWdlIGdlbmVyYXRpb25cbiAgICBsZXQgZW5lbWllc0hpdCA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyBlbmVteSBjb21wb25lbnQgYW5kIGhlYWx0aFxuICAgICAgY29uc3QgZW5lbXlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbmVteUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGlmICghZW5lbXlUcmFuc2Zvcm0gfHwgIWVuZW15SGVhbHRoIHx8IGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZW15UG9zaXRpb24gPSBlbmVteVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IHRvRW5lbXkgPSBlbmVteVBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG9FbmVteS5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgUFZQIGhpdCBkZXRlY3Rpb25cbiAgICAgIFxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbmVteSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkaXN0YW5jZSA8PSBtZWxlZVJhbmdlKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVuZW15IGlzIHdpdGhpbiBhdHRhY2sgY29uZVxuICAgICAgICB0b0VuZW15Lm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGRpcmVjdGlvbi5hbmdsZVRvKHRvRW5lbXkpO1xuICAgICAgICBjb25zdCBhbmdsZURlZ3JlZXMgPSBhbmdsZSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IG1heEFuZ2xlRGVncmVlcyA9IChtZWxlZUFuZ2xlIC8gMikgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChhbmdsZSA8PSBtZWxlZUFuZ2xlIC8gMikge1xuICAgICAgICAgIC8vIEVuZW15IGlzIHdpdGhpbiBhdHRhY2sgY29uZSAtIGRlYWwgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gKHdoaWNoIHdpbGwgcm91dGUgdG8gbXVsdGlwbGF5ZXIgZm9yIGVuZW1pZXMpXG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBiYXNlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ21lbGVlJyk7XG4gICAgICAgICAgICBlbmVtaWVzSGl0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcmFnZSBvbmx5IGlmIHdlIGhpdCBlbmVtaWVzICg1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nKVxuICAgIGlmIChlbmVtaWVzSGl0ID4gMCkge1xuICAgICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICAgIGlmIChnYW1lVUkpIHtcbiAgICAgICAgY29uc3QgcmFnZVRvR2FpbiA9IE1hdGgubWluKGVuZW1pZXNIaXQgKiA1LCA1KTsgLy8gNSByYWdlIHBlciBoaXQsIG1heCA1IHBlciBzd2luZ1xuICAgICAgICBnYW1lVUkuZ2FpblJhZ2UocmFnZVRvR2Fpbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZvckRhc2hJbnB1dChtb3ZlbWVudDogTW92ZW1lbnQsIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgZm9yIGRvdWJsZS10YXAgb24gbW92ZW1lbnQga2V5c1xuICAgIGNvbnN0IGRhc2hEaXJlY3Rpb25zID0gW1xuICAgICAgeyBrZXk6ICd3JywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAtMSkgfSwgLy8gRm9yd2FyZFxuICAgICAgeyBrZXk6ICdzJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAxKSB9LCAgLy8gQmFja3dhcmRcbiAgICAgIHsga2V5OiAnYScsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoLTEsIDAsIDApIH0sIC8vIExlZnRcbiAgICAgIHsga2V5OiAnZCcsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoMSwgMCwgMCkgfSAgIC8vIFJpZ2h0XG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgeyBrZXksIGRpcmVjdGlvbiB9IG9mIGRhc2hEaXJlY3Rpb25zKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuY2hlY2tEb3VibGVUYXAoa2V5KSkge1xuICAgICAgICAvLyBEZWJ1ZzogTG9nIHRoZSBkb3VibGUgdGFwIGRldGVjdGlvblxuICAgICAgICBjb25zdCBkZWJ1Z0luZm8gPSB0aGlzLmlucHV0TWFuYWdlci5nZXREb3VibGVUYXBEZWJ1Z0luZm8oa2V5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGNhbWVyYSBvcmllbnRhdGlvblxuICAgICAgICBjb25zdCB3b3JsZERpcmVjdGlvbiA9IHRoaXMuZ2V0V29ybGRTcGFjZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdGFydCBkYXNoXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgICAgICBjb25zdCBkYXNoU3RhcnRlZCA9IG1vdmVtZW50LnN0YXJ0RGFzaCh3b3JsZERpcmVjdGlvbiwgdHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGFzaFN0YXJ0ZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgZG91YmxlLXRhcCBzdGF0ZSB0byBwcmV2ZW50IG11bHRpcGxlIGRhc2hlc1xuICAgICAgICAgIHRoaXMuaW5wdXRNYW5hZ2VyLnJlc2V0RG91YmxlVGFwKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJyZWFrOyAvLyBPbmx5IHByb2Nlc3Mgb25lIGRhc2ggcGVyIGZyYW1lXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVEYXNoTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNEYXNoaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICBjb25zdCBkYXNoUmVzdWx0ID0gbW92ZW1lbnQudXBkYXRlRGFzaChjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nIChzaW1pbGFyIHRvIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICAgIGNvbnN0IE1BWF9EQVNIX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGRhc2hSZXN1bHQubmV3UG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZUZyb21PcmlnaW4gPD0gTUFYX0RBU0hfQk9VTkRTKSB7XG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGRhc2hSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FuY2VsIGRhc2ggaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIC8vIGNvbnNvbGUud2FybihgRGFzaCBjYW5jZWxsZWQ6IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpbiAoJHtkaXN0YW5jZUZyb21PcmlnaW4udG9GaXhlZCgyKX0gPiAke01BWF9EQVNIX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbERhc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNoYXJnZU1vdmVtZW50KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIW1vdmVtZW50LmlzQ2hhcmdpbmcpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGNoYXJnZSB3YXMgc3RvcHBlZCBieSBjb2xsaXNpb25cbiAgICBpZiAodGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjaGFyZ2VSZXN1bHQgPSBtb3ZlbWVudC51cGRhdGVDaGFyZ2UoY3VycmVudFRpbWUpO1xuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nXG4gICAgICBjb25zdCBNQVhfQ0hBUkdFX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBjb2xsaXNpb25cbiAgICAgIGNvbnN0IHBpbGxhckNvbGxpc2lvbiA9IHRoaXMuY2hlY2tQaWxsYXJDb2xsaXNpb24oY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlRnJvbU9yaWdpbiA+IE1BWF9DSEFSR0VfQk9VTkRTKSB7XG4gICAgICAgIC8vIENhbmNlbCBjaGFyZ2UgaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBjb2xsaWRlIHdpdGggYSBwaWxsYXJcbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBjb2xsaWRlIHdpdGggcGlsbGFyIGF0IFske3BpbGxhckNvbGxpc2lvbi5waWxsYXJDZW50ZXIudG9BcnJheSgpLmpvaW4oJywgJyl9XWApO1xuICAgICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSB3YXMgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgcG9zaXRpb24gaWYgbm90IHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5pc0NvbXBsZXRlIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBtb3ZlbWVudCBjb21wbGV0ZWQnKTtcbiAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2UgaXMgY29tcGxldGVcbiAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGdldFdvcmxkU3BhY2VEaXJlY3Rpb24oaW5wdXREaXJlY3Rpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICAvLyBHZXQgY2FtZXJhIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB3b3JsZERpcmVjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggcmFnZSAobWluaW11bSAyMCByYWdlIHJlcXVpcmVkKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3REaXZpbmVTdG9ybSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSA8IHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IHJhZ2UgYW1vdW50IGFuZCBjb25zdW1lIEFMTCByYWdlXG4gICAgY29uc3QgY3VycmVudFJhZ2UgPSBnYW1lVUkgPyBnYW1lVUkuZ2V0Q3VycmVudFJhZ2UoKSA6IDQwOyAvLyBGYWxsYmFjayB0byA0MCBpZiBnYW1lVUkgbm90IGF2YWlsYWJsZVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lQWxsUmFnZSgpOyAvLyBDb25zdW1lIGFsbCByYWdlIGluc3RlYWQgb2YganVzdCAyMFxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBleHRlbmRlZCBkdXJhdGlvbjogYmFzZSA0IHNlY29uZHMgKyAxIHNlY29uZCBwZXIgMTAgcmFnZSBjb25zdW1lZFxuICAgIGNvbnN0IGJhc2VTdG9ybUR1cmF0aW9uID0gMTAwMDsgLy8gNCBzZWNvbmRzIGJhc2VcbiAgICBjb25zdCBib251c0R1cmF0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50UmFnZSAvIDEwKSAqIDUwMDsgLy8gMSBzZWNvbmQgcGVyIDEwIHJhZ2VcbiAgICBjb25zdCB0b3RhbERpdmluZVN0b3JtRHVyYXRpb24gPSBiYXNlU3Rvcm1EdXJhdGlvbiArIGJvbnVzRHVyYXRpb247XG5cbiAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRGl2aW5lIFN0b3JtIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllclxuICAgIGlmICh0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uLCB0b3RhbERpdmluZVN0b3JtRHVyYXRpb24pO1xuICAgIH1cblxuICAgIC8vIERpdmluZSBTdG9ybSBsYXN0cyBmb3IgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5pc0RpdmluZVN0b3JtaW5nID0gZmFsc2U7XG4gICAgfSwgdG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUNoYXJnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDaGFyZ2VUaW1lIDwgdGhpcy5jaGFyZ2VDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNTd29yZENoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RDaGFyZ2VUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gUmVzZXQgY29sbGlzaW9uIHRyYWNraW5nIGZvciBuZXcgY2hhcmdlXG4gICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIENoYXJnZSBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXJcbiAgICBpZiAodGhpcy5vbkNoYXJnZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25DaGFyZ2VDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2FpbiByYWdlIGZvciB1c2luZyBjaGFyZ2UgYWJpbGl0eSAoKzIwIHJhZ2UpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuZ2FpblJhZ2UoMjApO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCB0aGUgY2hhcmdlIG1vdmVtZW50IHVzaW5nIHRoZSBzZXBhcmF0ZSBjaGFyZ2Ugc3lzdGVtXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgLy8gR2V0IGNoYXJnZSBkaXJlY3Rpb24gZnJvbSBjYW1lcmFcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSAwOyAvLyBLZWVwIG1vdmVtZW50IGhvcml6b250YWxcbiAgICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgY2hhcmdlIHdpdGggMTAuNSBkaXN0YW5jZSAoc2VwYXJhdGUgZnJvbSBkYXNoIHN5c3RlbSlcbiAgICAgICAgY29uc3QgY2hhcmdlU3RhcnRlZCA9IHBsYXllck1vdmVtZW50LnN0YXJ0Q2hhcmdlKGRpcmVjdGlvbiwgcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhcmdlU3RhcnRlZCkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGNoYXJnZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBtb3ZlbWVudFxuICAgICAgICAgIHRoaXMuc2NoZWR1bGVDaGFyZ2VEYW1hZ2UocGxheWVyVHJhbnNmb3JtLCBkaXJlY3Rpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNrIGNoYXJnZSBoaXQgZW50aXRpZXMgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzIGFuZCBlbmFibGUgY29sbGlzaW9uIHN0b3BwaW5nXG4gIHByaXZhdGUgY2hhcmdlSGl0RW50aXRpZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcblxuICAvLyBTY2hlZHVsZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBjaGFyZ2UgbW92ZW1lbnRcbiAgcHJpdmF0ZSBzY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgY2hhcmdlRGlyZWN0aW9uOiBWZWN0b3IzLCBzdGFydFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMC42OyBcbiAgICBjb25zdCBkYW1hZ2VDaGVja0ludGVydmFsID0gNTA7IC8vIENoZWNrIGZvciBkYW1hZ2UgZXZlcnkgNTBtcyBmb3IgYmV0dGVyIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICBjb25zdCBjaGFyZ2VEYW1hZ2UgPSA0MDsgLy8gSGlnaCBkYW1hZ2UgZm9yIGNoYXJnZSBhYmlsaXR5XG4gICAgY29uc3QgY2hhcmdlUmFkaXVzID0gMi41OyAvLyBEYW1hZ2UgcmFkaXVzIGFyb3VuZCBwbGF5ZXIgZHVyaW5nIGNoYXJnZVxuICAgIFxuICAgIC8vIFJlc2V0IGNoYXJnZSBoaXQgdHJhY2tpbmdcbiAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmNsZWFyKCk7XG4gICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBkYW1hZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgaWYgY2hhcmdlIGlzIGNvbXBsZXRlLCBjYW5jZWxsZWQsIG9yIHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICBpZiAoIXRoaXMuaXNTd29yZENoYXJnaW5nIHx8IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lID4gY2hhcmdlRHVyYXRpb24gfHwgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkYW1hZ2VJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGRhbWFnZVxuICAgICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIFxuICAgICAgbGV0IGhpdFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBEZWJ1ZzogTG9nIGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgZHVyaW5nIGNoYXJnZVxuICAgICAgXG4gICAgICAvLyBFTkhBTkNFRDogQWxzbyBjaGVjayBhZ2FpbnN0IHNlcnZlciBwbGF5ZXIgcG9zaXRpb25zIGRpcmVjdGx5IGFzIGEgZmFsbGJhY2tcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBtaXNzIGNvbGxpc2lvbnMgZHVlIHRvIGVudGl0eSBzeW5jIGlzc3Vlc1xuICAgICAgY29uc3Qgc2VydmVyUGxheWVycyA9ICh3aW5kb3cgYXMgYW55KS5wdnBQbGF5ZXJzIHx8IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgICAgIFxuICAgICAgc2VydmVyUGxheWVycy5mb3JFYWNoKChzZXJ2ZXJQbGF5ZXI6IGFueSwgcGxheWVySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBTa2lwIHNlbGZcbiAgICAgICAgaWYgKHBsYXllcklkID09PSBsb2NhbFNvY2tldElkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIGFscmVhZHkgaGl0IHBsYXllcnMgKHVzZSBoYXNoIG9mIHBsYXllciBJRCBmb3IgdHJhY2tpbmcpXG4gICAgICAgIGNvbnN0IHBsYXllcklkSGFzaCA9IHBsYXllcklkLmxlbmd0aCAqIDEwMDAgKyBwbGF5ZXJJZC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5oYXMocGxheWVySWRIYXNoKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2VydmVyUGxheWVyUG9zID0gbmV3IFZlY3RvcjMoc2VydmVyUGxheWVyLnBvc2l0aW9uLngsIHNlcnZlclBsYXllci5wb3NpdGlvbi55LCBzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueik7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcGxheWVyUG9zaXRpb24uZGlzdGFuY2VUbyhzZXJ2ZXJQbGF5ZXJQb3MpO1xuICAgICAgICBjb25zdCBzdG9wRGlzdGFuY2UgPSAwLjkgKyAxLjA7IC8vIFBsYXllciBjb2xsaXNpb24gcmFkaXVzICsgYnVmZmVyXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHN0b3BEaXN0YW5jZSAmJiBzZXJ2ZXJQbGF5ZXIuaGVhbHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuYWRkKHBsYXllcklkSGFzaCk7XG4gICAgICAgICAgaGl0U29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHBseSBkYW1hZ2UgdGhyb3VnaCBQVlAgc3lzdGVtIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3N3b3JkX2NoYXJnZV9oaXQnLCBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpLCBjaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKSwge1xuICAgICAgICAgICAgICBkYW1hZ2U6IGNoYXJnZURhbWFnZSxcbiAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHBsYXllcklkLFxuICAgICAgICAgICAgICBoaXRQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHNlcnZlclBsYXllclBvcy54LFxuICAgICAgICAgICAgICAgIHk6IHNlcnZlclBsYXllclBvcy55LFxuICAgICAgICAgICAgICAgIHo6IHNlcnZlclBsYXllclBvcy56XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IHRoaXMucGxheWVyRW50aXR5Py5pZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGhpdCBlbnRpdGllc1xuICAgICAgICBpZiAodGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5oYXMoZW50aXR5LmlkKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyB0cmFuc2Zvcm0gYW5kIGhlYWx0aCAoY291bGQgYmUgZW5lbXkgb3IgcGxheWVyKVxuICAgICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IGVudGl0eUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgICAgY29uc3QgZW50aXR5Q29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnOiBMb2cgZW50aXR5IGRldGFpbHNcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IGVuZW15ID8gYEVuZW15KCR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IGBQbGF5ZXIoJHtlbnRpdHkuaWR9KWA7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5SGVhbHRoIHx8IGVudGl0eUhlYWx0aC5pc0RlYWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVudGl0eVBvc2l0aW9uID0gZW50aXR5VHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGlzIHdpdGhpbiBjaGFyZ2UgZGFtYWdlIHJhZGl1c1xuICAgICAgICAvLyBJbiBQVlAsIHdlIHdhbnQgdG8gc3RvcCBqdXN0IGJlZm9yZSBoaXR0aW5nIHRoZSBlbmVteSwgbm90IG92ZXJsYXAgd2l0aCB0aGVtXG4gICAgICAgIGNvbnN0IHN0b3BEaXN0YW5jZSA9IGVudGl0eUNvbGxpZGVyID8gZW50aXR5Q29sbGlkZXIucmFkaXVzICsgMS4wIDogY2hhcmdlUmFkaXVzOyAvLyBTdG9wIDEgdW5pdCBhd2F5IGZyb20gZW5lbXkgZWRnZVxuICAgICAgICBcbiAgICAgICAgLy8gRGVidWc6IExvZyBwb3NpdGlvbiBhbmQgZGlzdGFuY2UgaW5mb3JtYXRpb25cbiAgICAgICAgXG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBzdG9wRGlzdGFuY2UpIHtcbiAgICAgICAgICAvLyBNYXJrIGFzIGhpdCB0byBwcmV2ZW50IG11bHRpcGxlIGhpdHNcbiAgICAgICAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmFkZChlbnRpdHkuaWQpO1xuICAgICAgICAgIGhpdFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbVxuICAgICAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSAmJiB0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgY2hhcmdlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ2NoYXJnZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IGVuZW15ID8gYEVuZW15KCR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IGBQbGF5ZXIoJHtlbnRpdHkuaWR9KWA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBjaGFyZ2UgYXR0YWNrIGZvciBQVlAgKGluY2x1ZGVzIGRhbWFnZSBhbmQgYW5pbWF0aW9uKVxuICAgICAgICAgICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdzd29yZF9jaGFyZ2VfaGl0JywgcGxheWVyUG9zaXRpb24uY2xvbmUoKSwgY2hhcmdlRGlyZWN0aW9uLmNsb25lKCksIHtcbiAgICAgICAgICAgICAgICBkYW1hZ2U6IGNoYXJnZURhbWFnZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogZW50aXR5LmlkLFxuICAgICAgICAgICAgICAgIGhpdFBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBlbnRpdHlQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgeTogZW50aXR5UG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgIHo6IGVudGl0eVBvc2l0aW9uLnpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEluIFBWUCBtb2RlLCBzdG9wIGNoYXJnZSB3aGVuIGhpdHRpbmcgc29tZXRoaW5nXG4gICAgICBpZiAoaGl0U29tZXRoaW5nKSB7XG4gICAgICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3AgdGhlIGNoYXJnZSBtb3ZlbWVudCBpbW1lZGlhdGVseVxuICAgICAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICAgICAgICBwbGF5ZXJNb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIHRoZSBkYW1hZ2UgaW50ZXJ2YWwgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBmdXJ0aGVyIGhpdHNcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkYW1hZ2VJbnRlcnZhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIGNoYXJnZSBjb21wbGV0aW9uXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0sIGRhbWFnZUNoZWNrSW50ZXJ2YWwpO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIENoYXJnZSBjb21wbGV0ZXNcbiAgcHVibGljIG9uQ2hhcmdlQ29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5pc1N3b3JkQ2hhcmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURlZmxlY3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUgPCB0aGlzLmRlZmxlY3RDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3REZWZsZWN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRGVmbGVjdCBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXJcbiAgICBpZiAodGhpcy5vbkRlZmxlY3RDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uRGVmbGVjdENhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgdXAgZGVmbGVjdCBiYXJyaWVyIHRoYXQgYmxvY2tzIGRhbWFnZSBhbmQgcmVmbGVjdHMgcHJvamVjdGlsZXNcbiAgICB0aGlzLnNldHVwRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBBdXRvLWNvbXBsZXRlIGRlZmxlY3QgYWZ0ZXIgZHVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMub25EZWZsZWN0Q29tcGxldGUoKTtcbiAgICB9LCB0aGlzLmRlZmxlY3REdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSA8IHRoaXMudmlwZXJTdGluZ0ZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg2MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0VmlwZXJTdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg2MCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU3RhcnQgY2hhcmdpbmcgYW5pbWF0aW9uXG4gICAgY29uc3QgY2hhcmdlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDEwMDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVWaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAwLjgyNTsgLy8gU2hvb3QgZnJvbSBjaGVzdCBsZXZlbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2FtZSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gYXMgb3RoZXIgcHJvamVjdGlsZXNcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE9mZnNldCBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBcbiAgICAvLyBOb3RlOiBWaXBlciBTdGluZyBkYW1hZ2UgaXMgaGFuZGxlZCBieSBWaXBlclN0aW5nTWFuYWdlciwgbm90IEVDUyBwcm9qZWN0aWxlc1xuICAgIC8vIFRoaXMgcHJldmVudHMgZHVwbGljYXRlIHByb2plY3RpbGVzIGFuZCBkYW1hZ2VcbiAgICBcbiAgICAvLyBUcmlnZ2VyIFZpcGVyIFN0aW5nIGNhbGxiYWNrIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcmlnZ2VyIHRoZSBnbG9iYWwgVmlwZXIgU3RpbmcgbWFuYWdlciBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBjb25zdCBzdWNjZXNzID0gdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcoKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ/CfkI0gVmlwZXIgU3RpbmcgdmlzdWFsIGVmZmVjdHMgc3VjY2Vzc2Z1bGx5IHRyaWdnZXJlZCEnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3ZpcGVyX3N0aW5nX3Byb2plY3RpbGUnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHtcbiAgICAgICAgc3BlZWQ6IDE2LFxuICAgICAgICBkYW1hZ2U6IDYxLFxuICAgICAgICBsaWZldGltZTogNSxcbiAgICAgICAgaXNSZXR1cm5pbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1CYXJyYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lIDwgdGhpcy5iYXJyYWdlRmlyZVJhdGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgQmFycmFnZSBvbiBjb29sZG93biBmb3IgJHsodGhpcy5iYXJyYWdlRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNDAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdEJhcnJhZ2UoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNDApO1xuICAgIH1cblxuICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RCYXJyYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA1MDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVCYXJyYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAwLjgyNTsgLy8gU2hvb3QgZnJvbSBjaGVzdCBsZXZlbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBzYW1lIGRvd253YXJkIGNvbXBlbnNhdGlvbiBhcyBwcm9qZWN0aWxlIHN5c3RlbVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXNcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSA1IGFycm93czogY2VudGVyICgwwrApLCBsZWZ0ICgxNcKwLCAzMMKwKSwgcmlnaHQgKC0xNcKwLCAtMzDCsCkgdXNpbmcgcHJvcGVyIEVDUyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IGFuZ2xlcyA9IFswLCBNYXRoLlBJIC8gMTIsIC1NYXRoLlBJIC8gMTIsIE1hdGguUEkgLyA2LCAtTWF0aC5QSSAvIDZdOyAvLyAwwrAsIDE1wrAsIC0xNcKwLCAzMMKwLCAtMzDCsFxuICAgIFxuICAgIGFuZ2xlcy5mb3JFYWNoKGFuZ2xlID0+IHtcbiAgICAgIC8vIFJvdGF0ZSB0aGUgYmFzZSBkaXJlY3Rpb24gYnkgdGhlIHNwZWNpZmllZCBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICAgICAgY29uc3QgcHJvamVjdGlsZURpcmVjdGlvbiA9IGRpcmVjdGlvbi5jbG9uZSgpO1xuICAgICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpLm1ha2VSb3RhdGlvblkoYW5nbGUpO1xuICAgICAgcHJvamVjdGlsZURpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgICAgcHJvamVjdGlsZURpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gT2Zmc2V0IHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICAgIHNwYXduUG9zaXRpb24uYWRkKHByb2plY3RpbGVEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBwcm9wZXIgRUNTIHByb2plY3RpbGUgZW50aXR5XG4gICAgICBjb25zdCBwcm9qZWN0aWxlQ29uZmlnID0ge1xuICAgICAgICBzcGVlZDogMjIsIC8vIFNsaWdodGx5IGZhc3RlciB0aGFuIHJlZ3VsYXIgYXJyb3dzICgyMClcbiAgICAgICAgZGFtYWdlOiAzMCwgLy8gSGlnaCBkYW1hZ2UgZm9yIGJhcnJhZ2UgYXJyb3dzXG4gICAgICAgIGxpZmV0aW1lOiA4LFxuICAgICAgICBtYXhEaXN0YW5jZTogMjUsIC8vIExpbWl0IGJhcnJhZ2UgYXJyb3dzIHRvIDI1IHVuaXRzIGRpc3RhbmNlIChzYW1lIGFzIHJlZ3VsYXIgYXJyb3dzKVxuICAgICAgICBwaWVyY2luZzogZmFsc2UsXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgc291cmNlUGxheWVySWQ6IHRoaXMucGxheWVyRW50aXR5Py51c2VyRGF0YT8ucGxheWVySWQgfHwgJ3Vua25vd24nXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24sXG4gICAgICAgIHRoaXMucGxheWVyRW50aXR5IS5pZCxcbiAgICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBhcyBiYXJyYWdlIGFycm93IGZvciB2aXN1YWwgaWRlbnRpZmljYXRpb25cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpIGFzIFJlbmRlcmVyO1xuICAgICAgaWYgKHJlbmRlcmVyPy5tZXNoKSB7XG4gICAgICAgIHJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNCYXJyYWdlQXJyb3cgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gZmFsc2U7IC8vIE92ZXJyaWRlIHJlZ3VsYXIgYXJyb3cgbWFya2luZ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2JhcnJhZ2VfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIHByb2plY3RpbGVEaXJlY3Rpb24sIHByb2plY3RpbGVDb25maWcpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBCYXJyYWdlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHZpc3VhbCBlZmZlY3RzIGlmIG5lZWRlZFxuICAgIGlmICh0aGlzLm9uQmFycmFnZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQmFycmFnZUNhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEFjdGl2YXRlIHRoZSBkZWZsZWN0IGJhcnJpZXJcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgY29uc3QgcGxheWVyUm90YXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBVc2UgU0FNRSByb3RhdGlvbiBsb2dpYyBhcyBEcmFnb25SZW5kZXJlciBmb3IgY29uc2lzdGVuY3kgd2l0aCB2aXN1YWwgc2hpZWxkXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDAuMSkge1xuICAgICAgICAvLyBQbGF5ZXIgaXMgYWN0aXZlbHkgbW92aW5nIC0gdXNlIG1vdmVtZW50IGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlcilcbiAgICAgICAgY29uc3QgbW92ZURpciA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb247XG4gICAgICAgIGlmIChtb3ZlRGlyLmxlbmd0aCgpID4gMC4xKSB7XG4gICAgICAgICAgY29uc3QgbW92ZUFuZ2xlID0gTWF0aC5hdGFuMihtb3ZlRGlyLngsIG1vdmVEaXIueik7XG4gICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IG1vdmVBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IG1vdmluZyAtIHVzZSBjYW1lcmEgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyIGZhbGxiYWNrKVxuICAgICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gTWF0aC5hdGFuMihjYW1lcmFEaXJlY3Rpb24ueCwgY2FtZXJhRGlyZWN0aW9uLnopO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLmFjdGl2YXRlKHBsYXllclBvc2l0aW9uLCBwbGF5ZXJSb3RhdGlvbiwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgZGVmbGVjdCBiYXJyaWVyIHBvc2l0aW9uIGlmIGl0J3MgYWN0aXZlXG4gICAgaWYgKHRoaXMuZGVmbGVjdEJhcnJpZXIuaXNCYXJyaWVyQWN0aXZlKCkpIHtcbiAgICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IHBsYXllclJvdGF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBTQU1FIHJvdGF0aW9uIGxvZ2ljIGFzIERyYWdvblJlbmRlcmVyIGZvciBjb25zaXN0ZW5jeSB3aXRoIHZpc3VhbCBzaGllbGRcbiAgICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICBjb25zdCBtb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgIGlmIChtb3ZlbWVudCAmJiBtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMC4xKSB7XG4gICAgICAgICAgLy8gUGxheWVyIGlzIGFjdGl2ZWx5IG1vdmluZyAtIHVzZSBtb3ZlbWVudCBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIpXG4gICAgICAgICAgY29uc3QgbW92ZURpciA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb247XG4gICAgICAgICAgaWYgKG1vdmVEaXIubGVuZ3RoKCkgPiAwLjEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVBbmdsZSA9IE1hdGguYXRhbjIobW92ZURpci54LCBtb3ZlRGlyLnopO1xuICAgICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IG1vdmVBbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm90IG1vdmluZyAtIHVzZSBjYW1lcmEgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyIGZhbGxiYWNrKVxuICAgICAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gTWF0aC5hdGFuMihjYW1lcmFEaXJlY3Rpb24ueCwgY2FtZXJhRGlyZWN0aW9uLnopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBiYXJyaWVyIHBvc2l0aW9uIHRvIGZvbGxvdyBwbGF5ZXJcbiAgICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIudXBkYXRlUG9zaXRpb24ocGxheWVyUG9zaXRpb24sIHBsYXllclJvdGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gRGVmbGVjdCBjb21wbGV0ZXNcbiAgcHVibGljIG9uRGVmbGVjdENvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1Db2xvc3N1c1N0cmlrZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHVzaW5nIFN3b3JkXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2xvc3N1c1N0cmlrZVRpbWUgPCB0aGlzLmNvbG9zc3VzU3RyaWtlQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjsgLy8gU3RpbGwgb24gY29vbGRvd25cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHBlcmZvcm1pbmcgQ29sb3NzdXMgU3RyaWtlXG4gICAgaWYgKHRoaXMuaXNDb2xvc3N1c1N0cmlraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggcmFnZSAobWluaW11bSA0MCByYWdlIHJlcXVpcmVkKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RDb2xvc3N1c1N0cmlrZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIENvbG9zc3VzIFN0cmlrZTogTm90IGVub3VnaCByYWdlIHRvIGNhc3QgKG5lZWQgNDApYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q29sb3NzdXNTdHJpa2VUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5pc0NvbG9zc3VzU3RyaWtpbmcgPSB0cnVlO1xuXG4gICAgLy8gU3RvcCBwbGF5ZXIgbW92ZW1lbnQgaW1tZWRpYXRlbHkgd2hlbiBjYXN0aW5nIENvbG9zc3VzIFN0cmlrZVxuICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICAgIHBsYXllck1vdmVtZW50LnZlbG9jaXR5LnggPSAwO1xuICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS56ID0gMDtcbiAgICAgICAgcGxheWVyTW92ZW1lbnQuc2V0TW92ZURpcmVjdGlvbihuZXcgVmVjdG9yMygwLCAwLCAwKSwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgcmFnZSBhbW91bnQgYW5kIGNvbnN1bWUgQUxMIHJhZ2UgKGxpa2UgRGl2aW5lIFN0b3JtKVxuICAgIGNvbnN0IGN1cnJlbnRSYWdlID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiA0MDtcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUFsbFJhZ2UoKTsgLy8gQ29uc3VtZSBhbGwgcmFnZSBpbnN0ZWFkIG9mIGp1c3QgNDBcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg4pqhIENvbG9zc3VzIFN0cmlrZTogQ29uc3VtZWQgJHtjdXJyZW50UmFnZX0gcmFnZWApO1xuXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uXG4gICAgY29uc3QgcG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gT2Zmc2V0IHRoZSBjb2xvc3N1cyBzdHJpa2UgcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBsb29rIGxpa2UgaXQncyBjb21pbmcgZnJvbSB0aGUgc3dvcmQgc3dpbmcgKGxpa2UgU21pdGUpXG4gICAgY29uc3QgY29sb3NzdXNTdHJpa2VQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDIuNSkpO1xuXG4gICAgLy8gVHJpZ2dlciBjb2xvc3N1cyBzdHJpa2UgY2FsbGJhY2sgd2l0aCByYWdlIHNwZW50XG4gICAgaWYgKHRoaXMub25Db2xvc3N1c1N0cmlrZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQ29sb3NzdXNTdHJpa2VDYWxsYmFjayhjb2xvc3N1c1N0cmlrZVBvc2l0aW9uLCBkaXJlY3Rpb24sIGN1cnJlbnRSYWdlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBjb2xvc3N1cyBzdHJpa2luZyBzdGF0ZSBhZnRlciBhbmltYXRpb24gZHVyYXRpb24gKHNhbWUgYXMgdGhlIFN3b3JkIGNvbXBvbmVudClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaXNDb2xvc3N1c1N0cmlraW5nID0gZmFsc2U7XG4gICAgfSwgOTAwKTsgLy8gMC45IHNlY29uZHMgbWF0Y2hlcyB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uXG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gQ29sb3NzdXMgU3RyaWtlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uQ29sb3NzdXNTdHJpa2VDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNDb2xvc3N1c1N0cmlraW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcblxuICAgIC8vIFJlc2V0IGNvbG9zc3VzIHN0cmlraW5nIHN0YXRlXG4gICAgdGhpcy5pc0NvbG9zc3VzU3RyaWtpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBtZXRob2RzIHRvIGdldCBjb29sZG93biBpbmZvcm1hdGlvbiBmb3IgVUlcbiAgcHVibGljIGdldFdlYXBvblN3aXRjaENvb2xkb3duKCk6IHsgY3VycmVudDogbnVtYmVyOyBtYXg6IG51bWJlciB9IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSkpLFxuICAgICAgbWF4OiB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBYmlsaXR5Q29vbGRvd25zKCk6IFJlY29yZDxzdHJpbmcsIHsgY3VycmVudDogbnVtYmVyOyBtYXg6IG51bWJlcjsgaXNBY3RpdmU6IGJvb2xlYW4gfT4ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgY29uc3QgY29vbGRvd25zOiBSZWNvcmQ8c3RyaW5nLCB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXI7IGlzQWN0aXZlOiBib29sZWFuIH0+ID0ge307XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZGVmbGVjdENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmRlZmxlY3RDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNEZWZsZWN0aW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY2hhcmdlQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDaGFyZ2VUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jaGFyZ2VDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNTd29yZENoYXJnaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNEaXZpbmVTdG9ybWluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNvbG9zc3VzU3RyaWtlQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2xvc3N1c1N0cmlrZVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmNvbG9zc3VzU3RyaWtlQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQ29sb3NzdXNTdHJpa2luZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5iYXJyYWdlRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY29icmFTaG90RmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2JyYVNob3RUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jb2JyYVNob3RGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMudmlwZXJTdGluZ0ZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgMS4wIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVhbmltYXRlVGltZSkpLFxuICAgICAgICBtYXg6IDEuMCxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5mcm9zdE5vdmFGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNDcm9zc2VudHJvcHlDaGFyZ2luZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmJhY2tzdGFiQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYWNrc3RhYlRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmJhY2tzdGFiQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQmFja3N0YWJiaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuc3VuZGVyQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTdW5kZXJUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5zdW5kZXJDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNTdW5kZXJpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5za3lmYWxsQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuc2t5ZmFsbENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1NreWZhbGxpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0YnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5zdGVhbHRoQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTdGVhbHRoVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuc3RlYWx0aENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1N0ZWFsdGhpbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuUlVORUJMQURFKSB7XG4gICAgICAvLyBSVU5FQkxBREUgYWJpbGl0aWVzXG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5kZWF0aEdyYXNwQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REZWF0aEdyYXNwVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZGVhdGhHcmFzcENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0RlYXRoR3Jhc3BpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5zbWl0ZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U21pdGVUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5zbWl0ZUNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1NtaXRpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogdGhpcy5jb3JydXB0ZWRBdXJhQWN0aXZlID8gMCA6IDAsIC8vIE5vIGNvb2xkb3duLCBqdXN0IGFjdGl2ZS9pbmFjdGl2ZSBzdGF0ZVxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmNvcnJ1cHRlZEF1cmFBY3RpdmVcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0YnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy53cmFpdGhTdHJpa2VDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdyYWl0aFN0cmlrZVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLndyYWl0aFN0cmlrZUNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1dyYWl0aFN0cmlraW5nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBjb29sZG93bnM7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMyIsIk1hdHJpeDQiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkhlYWx0aCIsIkVuZW15IiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbWJhdFN5c3RlbSIsIldlYXBvblN1YmNsYXNzIiwiV2VhcG9uVHlwZSIsIkRlZmxlY3RCYXJyaWVyIiwidHJpZ2dlckdsb2JhbEZyb3N0Tm92YSIsImFkZEdsb2JhbEZyb3plbkVuZW15IiwiYWRkR2xvYmFsU3R1bm5lZEVuZW15IiwidHJpZ2dlckdsb2JhbENvYnJhU2hvdCIsInRyaWdnZXJHbG9iYWxWaXBlclN0aW5nIiwiQ29udHJvbFN5c3RlbSIsInNldFBsYXllciIsImVudGl0eSIsInBsYXllckVudGl0eSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicGxheWVyVHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwicGxheWVyTW92ZW1lbnQiLCJ1cGRhdGVEZWJ1ZmZzIiwiY2xlYW51cFN1bmRlclN0YWNrcyIsImNsZWFudXBCdXJuaW5nU3RhY2tzIiwiaGFuZGxlV2VhcG9uU3dpdGNoaW5nIiwiaGFuZGxlRGFzaE1vdmVtZW50IiwiaGFuZGxlQ2hhcmdlTW92ZW1lbnQiLCJpc0Rhc2hpbmciLCJpc0NoYXJnaW5nIiwiaXNGcm96ZW4iLCJoYW5kbGVNb3ZlbWVudElucHV0IiwiaGFuZGxlQ29tYmF0SW5wdXQiLCJ1cGRhdGVEZWZsZWN0QmFycmllciIsIm1vdmVtZW50IiwiY2hlY2tGb3JEYXNoSW5wdXQiLCJpbnB1dERpcmVjdGlvbiIsImhhc0lucHV0IiwiaW5wdXRNYW5hZ2VyIiwiaXNLZXlQcmVzc2VkIiwieiIsIngiLCJsZW5ndGgiLCJub3JtYWxpemUiLCJjYW1lcmFEaXJlY3Rpb24iLCJjYW1lcmEiLCJnZXRXb3JsZERpcmVjdGlvbiIsImNhbWVyYVJpZ2h0IiwiY3Jvc3NWZWN0b3JzIiwiY2FtZXJhRm9yd2FyZCIsIndvcmxkRGlyZWN0aW9uIiwiYWRkU2NhbGVkVmVjdG9yIiwic2V0TW92ZURpcmVjdGlvbiIsImp1bXAiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJsYXN0V2VhcG9uU3dpdGNoVGltZSIsIndlYXBvblN3aXRjaENvb2xkb3duIiwiY3VycmVudFdlYXBvbiIsIlNXT1JEIiwicmVzZXRBbGxBYmlsaXR5U3RhdGVzIiwiY3VycmVudFN1YmNsYXNzIiwiRElWSU5JVFkiLCJmaXJlUmF0ZSIsInN3b3JkRmlyZVJhdGUiLCJzd29yZENvbWJvU3RlcCIsIkJPVyIsIkVMRU1FTlRBTCIsIlNDWVRIRSIsIkNIQU9TIiwic2N5dGhlRmlyZVJhdGUiLCJTQUJSRVMiLCJGUk9TVCIsInNhYnJlc0ZpcmVSYXRlIiwiUlVORUJMQURFIiwiQVJDQU5FIiwicnVuZWJsYWRlRmlyZVJhdGUiLCJoYW5kbGVCb3dJbnB1dCIsImhhbmRsZVNjeXRoZUlucHV0IiwiaGFuZGxlU3dvcmRJbnB1dCIsImhhbmRsZVNhYnJlc0lucHV0IiwiaGFuZGxlUnVuZWJsYWRlSW5wdXQiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZyIsInBlcmZvcm1WaXBlclN0aW5nIiwiaXNCYXJyYWdlQ2hhcmdpbmciLCJwZXJmb3JtQmFycmFnZSIsImlzQ29icmFTaG90Q2hhcmdpbmciLCJwZXJmb3JtQ29icmFTaG90IiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJjaGFyZ2VQcm9ncmVzcyIsIk1hdGgiLCJtaW4iLCJmaW5hbENoYXJnZVByb2dyZXNzIiwiZmlyZVByb2plY3RpbGUiLCJ0cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMiLCJjb25zb2xlIiwibG9nIiwiZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJpc0Nyb3NzZW50cm9weUNoYXJnaW5nIiwicGVyZm9ybUNyb3NzZW50cm9weUFiaWxpdHkiLCJwZXJmb3JtUmVhbmltYXRlQWJpbGl0eSIsInBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5IiwibGFzdEZpcmVUaW1lIiwiZGlyZWN0aW9uIiwiY29tcGVuc2F0aW9uQW5nbGUiLCJQSSIsInJvdGF0aW9uTWF0cml4IiwibWFrZVJvdGF0aW9uQXhpcyIsImFwcGx5TWF0cml4NCIsInBlcmZlY3RTaG90TWluVGhyZXNob2xkIiwicGVyZmVjdFNob3RNYXhUaHJlc2hvbGQiLCJpc1BlcmZlY3RTaG90IiwiY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZSIsInBvc2l0aW9uIiwiY2xvbmUiLCJjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUiLCJhbmdsZSIsImF0YW4yIiwiY3JlYXRlUHJvamVjdGlsZSIsInNwaW5TdGF0dXMiLCJjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlIiwibGFzdENyb3NzZW50cm9weVRpbWUiLCJjcm9zc2VudHJvcHlGaXJlUmF0ZSIsImdhbWVVSSIsIndpbmRvdyIsImNhbkNhc3RDcm9zc2VudHJvcHlCb2x0IiwibWFuYUJlZm9yZSIsImdldEN1cnJlbnRNYW5hIiwibWFuYUNvbnN1bWVkIiwiY29uc3VtZU1hbmEiLCJ3YXJuIiwiY3Jvc3NlbnRyb3B5Q2hhcmdlUHJvZ3Jlc3MiLCJjaGFyZ2VTdGFydFRpbWUiLCJjaGFyZ2VEdXJhdGlvbiIsImNoYXJnZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwiY2xlYXJJbnRlcnZhbCIsImZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eUFmdGVyQ2hhcmdlIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJwb3RlbnRpYWxUYXJnZXRzIiwid29ybGQiLCJxdWVyeUVudGl0aWVzIiwidmFsaWRUYXJnZXRzIiwiZmlsdGVyIiwidGFyZ2V0IiwiaWQiLCJpc0RlYWQiLCJoYXNWYWxpZFRhcmdldHMiLCJzaG91bGRCcm9hZGNhc3QiLCJvblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2siLCJ1bmRlZmluZWQiLCJzcGF3blBvc2l0aW9uIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJ5IiwicHJvamVjdGlsZUNvbmZpZyIsInNwZWVkIiwiZGFtYWdlIiwibGlmZXRpbWUiLCJtYXhEaXN0YW5jZSIsInN1YmNsYXNzIiwibGV2ZWwiLCJjdXJyZW50TGV2ZWwiLCJvcGFjaXR5Iiwic291cmNlUGxheWVySWQiLCJ1c2VyRGF0YSIsInBsYXllcklkIiwicHJvamVjdGlsZVN5c3RlbSIsImNhbkNhc3RFbnRyb3BpY0JvbHQiLCJlbnRyb3BpY0NvbmZpZyIsInBpZXJjaW5nIiwiZXhwbG9zaXZlIiwiZXhwbG9zaW9uUmFkaXVzIiwiY3Jvc3NlbnRyb3B5Q29uZmlnIiwibGFzdFJlYW5pbWF0ZVRpbWUiLCJjdXJyZW50TWFuYSIsImNhbkNhc3RSZWFuaW1hdGUiLCJtYW5hQWZ0ZXIiLCJ0cmlnZ2VyUmVhbmltYXRlRWZmZWN0IiwiaGVhbHRoQ29tcG9uZW50IiwiZGlkSGVhbCIsImhlYWwiLCJvblJlYW5pbWF0ZUNhbGxiYWNrIiwicGxheWVyUG9zaXRpb24iLCJsYXN0RnJvc3ROb3ZhVGltZSIsImZyb3N0Tm92YUZpcmVSYXRlIiwiY2FuQ2FzdEZyb3N0Tm92YSIsImdldFdvcmxkUG9zaXRpb24iLCJvbkZyb3N0Tm92YUNhbGxiYWNrIiwiZnJlZXplRW5lbWllc0luUmFkaXVzIiwibGFzdENvYnJhU2hvdFRpbWUiLCJjb2JyYVNob3RGaXJlUmF0ZSIsImNhbkNhc3RDb2JyYVNob3QiLCJjb25zdW1lRW5lcmd5IiwiY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MiLCJmaXJlQ29icmFTaG90Iiwib25Db2JyYVNob3RDYWxsYmFjayIsInZlbm9tRHVyYXRpb24iLCJjZW50ZXJQb3NpdGlvbiIsInJhZGl1cyIsImFsbEVudGl0aWVzIiwiZ2V0QWxsRW50aXRpZXMiLCJmcm96ZW5Db3VudCIsImRhbWFnZWRQbGF5ZXJzIiwibG9jYWxTb2NrZXRJZCIsImZvckVhY2giLCJlbnRpdHlUcmFuc2Zvcm0iLCJlbnRpdHlIZWFsdGgiLCJlbnRpdHlQb3NpdGlvbiIsImRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsImVuZW15IiwiZnJlZXplIiwidG9TdHJpbmciLCJzZXJ2ZXJQbGF5ZXJFbnRpdGllcyIsInRhcmdldFBsYXllcklkIiwiY3VycmVudCIsImxvY2FsRW50aXR5SWQiLCJjb21iYXRTeXN0ZW0iLCJnZXRTeXN0ZW0iLCJmcm9zdE5vdmFEYW1hZ2UiLCJxdWV1ZURhbWFnZSIsIm9uRGVidWZmQ2FsbGJhY2siLCJjaGFyZ2VkQXJyb3dDb25maWciLCJzZXRXZWFwb25TdWJjbGFzcyIsInNldEJvd1JlbGVhc2VDYWxsYmFjayIsImNhbGxiYWNrIiwib25Cb3dSZWxlYXNlQ2FsbGJhY2siLCJzZXREaXZpbmVTdG9ybUNhbGxiYWNrIiwib25EaXZpbmVTdG9ybUNhbGxiYWNrIiwic2V0UHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayIsInNldFZpcGVyU3RpbmdDYWxsYmFjayIsIm9uVmlwZXJTdGluZ0NhbGxiYWNrIiwic2V0QmFycmFnZUNhbGxiYWNrIiwib25CYXJyYWdlQ2FsbGJhY2siLCJzZXRSZWFuaW1hdGVDYWxsYmFjayIsInNldEZyb3N0Tm92YUNhbGxiYWNrIiwic2V0Q29icmFTaG90Q2FsbGJhY2siLCJzZXRDaGFyZ2VDYWxsYmFjayIsIm9uQ2hhcmdlQ2FsbGJhY2siLCJzZXREZWZsZWN0Q2FsbGJhY2siLCJvbkRlZmxlY3RDYWxsYmFjayIsInNldFNreWZhbGxDYWxsYmFjayIsIm9uU2t5ZmFsbENhbGxiYWNrIiwic2V0QmFja3N0YWJDYWxsYmFjayIsIm9uQmFja3N0YWJDYWxsYmFjayIsInNldFN1bmRlckNhbGxiYWNrIiwib25TdW5kZXJDYWxsYmFjayIsInNldFNtaXRlQ2FsbGJhY2siLCJvblNtaXRlQ2FsbGJhY2siLCJzZXREZWF0aEdyYXNwQ2FsbGJhY2siLCJvbkRlYXRoR3Jhc3BDYWxsYmFjayIsInNldFdyYWl0aFN0cmlrZUNhbGxiYWNrIiwib25XcmFpdGhTdHJpa2VDYWxsYmFjayIsInNldENvbnN1bWVNYW5hQ2FsbGJhY2siLCJvbkNvbnN1bWVNYW5hQ2FsbGJhY2siLCJzZXRDaGVja01hbmFDYWxsYmFjayIsIm9uQ2hlY2tNYW5hQ2FsbGJhY2siLCJzZXRDcmVhdGVTYWJyZU1pc3RFZmZlY3RDYWxsYmFjayIsIm9uQ3JlYXRlU2FicmVNaXN0RWZmZWN0Q2FsbGJhY2siLCJzZXRTdGVhbHRoQ2FsbGJhY2siLCJvblN0ZWFsdGhDYWxsYmFjayIsInNldEhhdW50ZWRTb3VsRWZmZWN0Q2FsbGJhY2siLCJvbkhhdW50ZWRTb3VsRWZmZWN0Q2FsbGJhY2siLCJzZXREZWJ1ZmZDYWxsYmFjayIsIm9yaWdpbmFsQ2FsbGJhY2siLCJ0YXJnZXRFbnRpdHlJZCIsImRlYnVmZlR5cGUiLCJkdXJhdGlvbiIsInRyYWNrRGVidWZmRWZmZWN0IiwiZW50aXR5SWQiLCJlZmZlY3QiLCJzdGFydFRpbWUiLCJleGlzdGluZ0VmZmVjdHMiLCJhY3RpdmVEZWJ1ZmZFZmZlY3RzIiwiZ2V0IiwicHVzaCIsInNldCIsInNldFRpbWVvdXQiLCJjdXJyZW50RWZmZWN0cyIsImZpbHRlcmVkRWZmZWN0cyIsImUiLCJkZWxldGUiLCJpc1BsYXllclN0dW5uZWQiLCJlZmZlY3RzIiwic29tZSIsInNldFdlYXBvbkxldmVsIiwiZ2V0Q3VycmVudFdlYXBvbkNvbmZpZyIsIndlYXBvbiIsImdldEN1cnJlbnRXZWFwb24iLCJnZXRDdXJyZW50U3ViY2xhc3MiLCJpc1dlYXBvbkNoYXJnaW5nIiwiZ2V0Q2hhcmdlUHJvZ3Jlc3MiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZ0FjdGl2ZSIsImdldFZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsInZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsImlzQmFycmFnZUNoYXJnaW5nQWN0aXZlIiwiZ2V0QmFycmFnZUNoYXJnZVByb2dyZXNzIiwiYmFycmFnZUNoYXJnZVByb2dyZXNzIiwiaXNDb2JyYVNob3RDaGFyZ2luZ0FjdGl2ZSIsImdldENvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiaXNDcm9zc2VudHJvcHlDaGFyZ2luZ0FjdGl2ZSIsImdldENyb3NzZW50cm9weUNoYXJnZVByb2dyZXNzIiwiaXNXZWFwb25Td2luZ2luZyIsImlzU3dpbmdpbmciLCJnZXRTd29yZENvbWJvU3RlcCIsImlzRGl2aW5lU3Rvcm1BY3RpdmUiLCJpc0RpdmluZVN0b3JtaW5nIiwiaXNDaGFyZ2VBY3RpdmUiLCJpc1N3b3JkQ2hhcmdpbmciLCJpc0RlZmxlY3RBY3RpdmUiLCJpc0RlZmxlY3RpbmciLCJpc1NreWZhbGxBY3RpdmUiLCJpc1NreWZhbGxpbmciLCJpc0JhY2tzdGFiQWN0aXZlIiwiaXNCYWNrc3RhYmJpbmciLCJpc1N1bmRlckFjdGl2ZSIsImlzU3VuZGVyaW5nIiwiaXNTdGVhbHRoQWN0aXZlIiwiaXNTdGVhbHRoaW5nIiwiaXNQbGF5ZXJJbnZpc2libGUiLCJpc0ludmlzaWJsZSIsImlzU21pdGVBY3RpdmUiLCJpc1NtaXRpbmciLCJpc0RlYXRoR3Jhc3BBY3RpdmUiLCJpc0RlYXRoR3Jhc3BpbmciLCJpc1dyYWl0aFN0cmlrZUFjdGl2ZSIsImlzV3JhaXRoU3RyaWtpbmciLCJpc0NvcnJ1cHRlZEF1cmFBY3RpdmUiLCJjb3JydXB0ZWRBdXJhQWN0aXZlIiwiaXNDb2xvc3N1c1N0cmlrZUFjdGl2ZSIsImlzQ29sb3NzdXNTdHJpa2luZyIsInBlcmZvcm1Td29yZE1lbGVlQXR0YWNrIiwicGVyZm9ybURpdmluZVN0b3JtIiwicGVyZm9ybUNoYXJnZSIsInBlcmZvcm1EZWZsZWN0IiwicGVyZm9ybUNvbG9zc3VzU3RyaWtlIiwibGFzdFN3b3JkQXR0YWNrVGltZSIsInN3b3JkQ29tYm9SZXNldFRpbWUiLCJwZXJmb3JtUnVuZWJsYWRlTWVsZWVBdHRhY2siLCJwZXJmb3JtU21pdGUiLCJwZXJmb3JtRGVhdGhHcmFzcCIsInJLZXlXYXNQcmVzc2VkIiwidG9nZ2xlQ29ycnVwdGVkQXVyYSIsInBlcmZvcm1XcmFpdGhTdHJpa2UiLCJ1cGRhdGVDb3JydXB0ZWRBdXJhRWZmZWN0cyIsInBlcmZvcm1NZWxlZURhbWFnZSIsImxhc3RTbWl0ZVRpbWUiLCJzbWl0ZUNvb2xkb3duIiwiY2FuQ2FzdFNtaXRlIiwidmVsb2NpdHkiLCJzbWl0ZVBvc2l0aW9uIiwiZGFtYWdlRGVhbHRGbGFnIiwicGVyZm9ybVNtaXRlSGVhbGluZyIsInBlcmZvcm1TbWl0ZURhbWFnZSIsInNtaXRlRGFtYWdlIiwiZGFtYWdlUmFkaXVzIiwiZGFtYWdlRGVhbHQiLCJ0b0ZpeGVkIiwib2xkSGVhbHRoIiwiY3VycmVudEhlYWx0aCIsIm1heEhlYWx0aCIsImdhaW5IZWFsdGgiLCJlcnJvciIsImxhc3REZWF0aEdyYXNwVGltZSIsImRlYXRoR3Jhc3BDb29sZG93biIsImNhbkNhc3REZWF0aEdyYXNwIiwibGFzdFdyYWl0aFN0cmlrZVRpbWUiLCJ3cmFpdGhTdHJpa2VDb29sZG93biIsImNhbkNhc3RXcmFpdGhTdHJpa2UiLCJwZXJmb3JtV3JhaXRoU3RyaWtlRGFtYWdlIiwicGxheWVyRGlyZWN0aW9uIiwid3JhaXRoU3RyaWtlUmFuZ2UiLCJ3cmFpdGhTdHJpa2VBbmdsZSIsIndyYWl0aFN0cmlrZURhbWFnZSIsImhpdENvdW50IiwidGFyZ2V0SGVhbHRoIiwidGFyZ2V0VHJhbnNmb3JtIiwiZGlyZWN0aW9uVG9UYXJnZXQiLCJzdWJWZWN0b3JzIiwiZG90UHJvZHVjdCIsImRvdCIsImFuZ2xlVGhyZXNob2xkIiwiY29zIiwiYXBwbHlDb3JydXB0ZWREZWJ1ZmYiLCJhcHBseUNvcnJ1cHRlZCIsInRyaWdnZXJIYXVudGVkU291bEVmZmVjdCIsIm9uU3dvcmRTd2luZ0NvbXBsZXRlIiwib25TbWl0ZUNvbXBsZXRlIiwib25EZWF0aEdyYXNwQ29tcGxldGUiLCJvbldyYWl0aFN0cmlrZUNvbXBsZXRlIiwicGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrIiwicGVyZm9ybUJhY2tzdGFiIiwicGVyZm9ybVN1bmRlciIsInBlcmZvcm1Ta3lmYWxsIiwicGVyZm9ybVN0ZWFsdGgiLCJ1cGRhdGVTa3lmYWxsTW92ZW1lbnQiLCJ1cGRhdGVCYWNrc3RhYlN0YXRlIiwidXBkYXRlU3VuZGVyU3RhdGUiLCJ1cGRhdGVTdGVhbHRoU3RhdGUiLCJwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UiLCJvblNhYnJlc1N3aW5nQ29tcGxldGUiLCJoYXNDb21wb25lbnQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0FuZ2xlIiwibGVmdFNhYnJlRGFtYWdlIiwicmlnaHRTYWJyZURhbWFnZSIsImF0dGFja0RpcmVjdGlvbiIsInN1YiIsImRpc3RhbmNlVG9UYXJnZXQiLCJhbmdsZVRvVGFyZ2V0IiwiYWNvcyIsIm1heCIsImxhc3RTa3lmYWxsVGltZSIsInNreWZhbGxDb29sZG93biIsImNhbkNhc3RTa3lmYWxsIiwic2t5ZmFsbFBoYXNlIiwic2t5ZmFsbFN0YXJ0VGltZSIsInNreWZhbGxTdGFydFBvc2l0aW9uIiwiY29weSIsInNreWZhbGxPcmlnaW5hbEdyYXZpdHkiLCJncmF2aXR5Iiwic2t5ZmFsbFRhcmdldEhlaWdodCIsImp1bXBGb3JjZSIsImVsYXBzZWRUaW1lIiwicGVyZm9ybVNreWZhbGxMYW5kaW5nIiwiY29tcGxldGVTa3lmYWxsQWJpbGl0eSIsImxhbmRpbmdQb3NpdGlvbiIsInNreWZhbGxEYW1hZ2UiLCJkaXN0YW5jZVRvTGFuZGluZyIsImJhY2tzdGFiU3RhcnRUaW1lIiwiYmFja3N0YWJEdXJhdGlvbiIsImxhc3RTdW5kZXJUaW1lIiwic3VuZGVyQ29vbGRvd24iLCJjYW5DYXN0U3VuZGVyIiwic3VuZGVyU3RhcnRUaW1lIiwicGVyZm9ybVN1bmRlckRhbWFnZSIsInN1bmRlckR1cmF0aW9uIiwic3VuZGVyUmFuZ2UiLCJzdGFja0NvdW50IiwiaXNTdHVubmVkIiwiYXBwbHlTdW5kZXJTdGFjayIsInN0YWNrRHVyYXRpb24iLCJjdXJyZW50U3RhY2tzIiwic3VuZGVyU3RhY2tzIiwibGFzdEFwcGxpZWQiLCJzdGFja3MiLCJiYXNlRGFtYWdlcyIsIm5ld1N0YWNrQ291bnQiLCJhcHBseUJ1cm5pbmdTdGFjayIsImlzRW50cm9waWNCb2x0IiwibWF4U3RhY2tzIiwiYnVybmluZ1N0YWNrcyIsImRhbWFnZUJvbnVzIiwidGFyZ2V0RW50aXR5IiwiZ2V0RW50aXR5IiwidHJhbnNmb3JtIiwicG9zaXRpb25XaXRoU3RhY2tzIiwiZW50cmllcyIsIkFycmF5IiwiZnJvbSIsInN0YWNrRGF0YSIsImxhc3RTdGVhbHRoVGltZSIsInN0ZWFsdGhDb29sZG93biIsInN0ZWFsdGhTdGFydFRpbWUiLCJicm9hZGNhc3RTdGVhbHRoU3RhdGUiLCJzdGVhbHRoRGVsYXlEdXJhdGlvbiIsInRvdGFsU3RlYWx0aER1cmF0aW9uIiwic3RlYWx0aEludmlzaWJpbGl0eUR1cmF0aW9uIiwibXVsdGlwbGF5ZXJDb250ZXh0IiwiYnJvYWRjYXN0UGxheWVyU3RlYWx0aCIsImNsZWFyIiwiY29ycnVwdGVkQXVyYVNsb3dlZEVudGl0aWVzIiwiY2FuQ2FzdENvcnJ1cHRlZEF1cmEiLCJsYXN0TWFuYURyYWluVGltZSIsIm9uQ29ycnVwdGVkQXVyYVRvZ2dsZUNhbGxiYWNrIiwiY29ycnVwdGVkQXVyYU1hbmFDb3N0IiwiYXBwbHlDb3JydXB0ZWRBdXJhU2xvdyIsImVudGl0eU1vdmVtZW50IiwiaXNJblJhbmdlIiwiY29ycnVwdGVkQXVyYVJhbmdlIiwid2FzU2xvd2VkIiwibW92ZW1lbnRTcGVlZE11bHRpcGxpZXIiLCJjb3JydXB0ZWRBdXJhU2xvd0VmZmVjdCIsInNldENvcnJ1cHRlZEF1cmFUb2dnbGVDYWxsYmFjayIsInNldENvbG9zc3VzU3RyaWtlQ2FsbGJhY2siLCJvbkNvbG9zc3VzU3RyaWtlQ2FsbGJhY2siLCJsYXN0QmFja3N0YWJUaW1lIiwiYmFja3N0YWJDb29sZG93biIsImNhbkNhc3RCYWNrc3RhYiIsInBlcmZvcm1CYWNrc3RhYkRhbWFnZSIsImJhY2tzdGFiUmFuZ2UiLCJpc0JhY2tzdGFiIiwicHZwUGxheWVycyIsInRhcmdldFBsYXllciIsInBsYXllciIsInBsYXllclBvcyIsInRhcmdldEZhY2luZ0RpcmVjdGlvbiIsInNpbiIsInJvdGF0aW9uIiwiYXR0YWNrZXJEaXJlY3Rpb24iLCJiZWhpbmREb3RQcm9kdWN0IiwiaXNUYXJnZXRTdHVubmVkIiwiZ2FpbkVuZXJneSIsIm1lbGVlUmFuZ2UiLCJtZWxlZUFuZ2xlIiwiYmFzZURhbWFnZSIsImVuZW1pZXNIaXQiLCJlbmVteVRyYW5zZm9ybSIsImVuZW15SGVhbHRoIiwiZW5lbXlQb3NpdGlvbiIsInRvRW5lbXkiLCJhbmdsZVRvIiwiYW5nbGVEZWdyZWVzIiwibWF4QW5nbGVEZWdyZWVzIiwicmFnZVRvR2FpbiIsImdhaW5SYWdlIiwiZGFzaERpcmVjdGlvbnMiLCJrZXkiLCJjaGVja0RvdWJsZVRhcCIsImRlYnVnSW5mbyIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsImdldFdvcmxkU3BhY2VEaXJlY3Rpb24iLCJkYXNoU3RhcnRlZCIsInN0YXJ0RGFzaCIsInJlc2V0RG91YmxlVGFwIiwiZGFzaFJlc3VsdCIsInVwZGF0ZURhc2giLCJuZXdQb3NpdGlvbiIsIk1BWF9EQVNIX0JPVU5EUyIsImRpc3RhbmNlRnJvbU9yaWdpbiIsImNhbmNlbERhc2giLCJjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24iLCJjYW5jZWxDaGFyZ2UiLCJjaGFyZ2VSZXN1bHQiLCJ1cGRhdGVDaGFyZ2UiLCJNQVhfQ0hBUkdFX0JPVU5EUyIsInBpbGxhckNvbGxpc2lvbiIsImNoZWNrUGlsbGFyQ29sbGlzaW9uIiwib25DaGFyZ2VDb21wbGV0ZSIsImhhc0NvbGxpc2lvbiIsInBpbGxhckNlbnRlciIsInRvQXJyYXkiLCJqb2luIiwiaXNDb21wbGV0ZSIsInBpbGxhclBvcyIsIlBJTExBUl9QT1NJVElPTlMiLCJob3Jpem9udGFsUG9zIiwicGlsbGFySG9yaXpvbnRhbCIsIlBJTExBUl9SQURJVVMiLCJub3JtYWwiLCJjYW5DYXN0RGl2aW5lU3Rvcm0iLCJsYXN0RGl2aW5lU3Rvcm1UaW1lIiwiZGl2aW5lU3Rvcm1Db29sZG93biIsImN1cnJlbnRSYWdlIiwiZ2V0Q3VycmVudFJhZ2UiLCJjb25zdW1lQWxsUmFnZSIsImJhc2VTdG9ybUR1cmF0aW9uIiwiYm9udXNEdXJhdGlvbiIsImZsb29yIiwidG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uIiwibGFzdENoYXJnZVRpbWUiLCJjaGFyZ2VDb29sZG93biIsImNoYXJnZVN0YXJ0ZWQiLCJzdGFydENoYXJnZSIsInNjaGVkdWxlQ2hhcmdlRGFtYWdlIiwiY2hhcmdlRGlyZWN0aW9uIiwiZGFtYWdlQ2hlY2tJbnRlcnZhbCIsImNoYXJnZURhbWFnZSIsImNoYXJnZVJhZGl1cyIsImNoYXJnZUhpdEVudGl0aWVzIiwiZGFtYWdlSW50ZXJ2YWwiLCJoaXRTb21ldGhpbmciLCJzZXJ2ZXJQbGF5ZXJzIiwiTWFwIiwic2VydmVyUGxheWVyIiwicGxheWVySWRIYXNoIiwiY2hhckNvZGVBdCIsImhhcyIsInNlcnZlclBsYXllclBvcyIsInN0b3BEaXN0YW5jZSIsImhlYWx0aCIsInRhcmdldElkIiwiaGl0UG9zaXRpb24iLCJlbnRpdHlDb2xsaWRlciIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImxhc3REZWZsZWN0VGltZSIsImRlZmxlY3RDb29sZG93biIsInNldHVwRGVmbGVjdEJhcnJpZXIiLCJvbkRlZmxlY3RDb21wbGV0ZSIsImRlZmxlY3REdXJhdGlvbiIsImxhc3RWaXBlclN0aW5nVGltZSIsInZpcGVyU3RpbmdGaXJlUmF0ZSIsImNhbkNhc3RWaXBlclN0aW5nIiwiZmlyZVZpcGVyU3RpbmciLCJzdWNjZXNzIiwiaXNSZXR1cm5pbmciLCJsYXN0QmFycmFnZVRpbWUiLCJiYXJyYWdlRmlyZVJhdGUiLCJjYW5DYXN0QmFycmFnZSIsImZpcmVCYXJyYWdlIiwiYW5nbGVzIiwicHJvamVjdGlsZURpcmVjdGlvbiIsIm1ha2VSb3RhdGlvblkiLCJwcm9qZWN0aWxlRW50aXR5IiwicmVuZGVyZXIiLCJtZXNoIiwiaXNCYXJyYWdlQXJyb3ciLCJpc1JlZ3VsYXJBcnJvdyIsInBsYXllclJvdGF0aW9uIiwiaW5wdXRTdHJlbmd0aCIsIm1vdmVEaXIiLCJtb3ZlRGlyZWN0aW9uIiwibW92ZUFuZ2xlIiwiZGVmbGVjdEJhcnJpZXIiLCJhY3RpdmF0ZSIsImlzQmFycmllckFjdGl2ZSIsInVwZGF0ZVBvc2l0aW9uIiwiZGVhY3RpdmF0ZSIsImxhc3RDb2xvc3N1c1N0cmlrZVRpbWUiLCJjb2xvc3N1c1N0cmlrZUNvb2xkb3duIiwiY2FuQ2FzdENvbG9zc3VzU3RyaWtlIiwiY29sb3NzdXNTdHJpa2VQb3NpdGlvbiIsIm9uQ29sb3NzdXNTdHJpa2VDb21wbGV0ZSIsImdldFdlYXBvblN3aXRjaENvb2xkb3duIiwiZ2V0QWJpbGl0eUNvb2xkb3ducyIsImNvb2xkb3ducyIsImlzQWN0aXZlIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJTZXQiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/InterpolationSystem.ts":
/*!********************************************!*\
  !*** ./src/systems/InterpolationSystem.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationSystem: function() { return /* binding */ InterpolationSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Interpolation */ \"(app-pages-browser)/./src/ecs/components/Interpolation.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Interpolation system for smooth entity movement and rotation\n\n\n\n\n\nclass InterpolationSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    /**\n   * Update interpolation for all entities with interpolation buffers\n   */ update(entities, deltaTime) {\n        this.currentTime = performance.now();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__.Movement);\n            if (!(transform === null || transform === void 0 ? void 0 : transform.enabled) || !(interpolationBuffer === null || interpolationBuffer === void 0 ? void 0 : interpolationBuffer.enabled)) {\n                continue;\n            }\n            // Skip local players (entities that can move) - they should not be interpolated\n            // Only remote players (canMove = false) should use interpolation\n            if (movement && movement.canMove) {\n                continue;\n            }\n            this.interpolateEntity(transform, interpolationBuffer);\n        }\n    }\n    /**\n   * Render interpolation (called during render phase for smooth visuals)\n   */ render(entities, deltaTime) {\n        // For now, render and update phases are the same for interpolation\n        // In the future, we could separate concerns if needed\n        this.update(entities, deltaTime);\n    }\n    /**\n   * Interpolate a single entity's transform\n   */ interpolateEntity(transform, interpolationBuffer) {\n        const interpolatedTransform = interpolationBuffer.getInterpolatedTransform(this.currentTime);\n        // Apply interpolated position\n        transform.position.copy(interpolatedTransform.position);\n        // Apply interpolated rotation\n        transform.quaternion.copy(interpolatedTransform.rotation);\n        // Update the transform's Euler rotation to match the quaternion\n        transform.rotation.setFromQuaternion(transform.quaternion);\n        // Mark matrices as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    /**\n   * Add server state to an entity's interpolation buffer\n   */ addServerState(entity, position, rotation, timestamp) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.addServerState(position, rotation, timestamp);\n        }\n    }\n    /**\n   * Get interpolation statistics for debugging\n   */ getInterpolationStats(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            return interpolationBuffer.getBufferStats();\n        }\n        return null;\n    }\n    /**\n   * Clear interpolation buffer for an entity\n   */ clearInterpolationBuffer(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.clearBuffer();\n        }\n    }\n    /**\n   * Set interpolation delay for all entities (in milliseconds)\n   */ setInterpolationDelay(entity, delayMs) {\n        // Note: This would require modifying the InterpolationBuffer component\n        // For now, the delay is fixed in the component itself\n        console.warn(\"Interpolation delay is currently fixed in InterpolationBuffer component\");\n    }\n    /**\n   * Get the current render time used for interpolation\n   */ getCurrentRenderTime() {\n        return this.currentTime;\n    }\n    /**\n   * Advanced interpolation methods for smoother movement\n   */ /**\n   * Hermite spline interpolation for smoother curves\n   * This provides better interpolation between keyframes by considering velocity\n   */ static hermiteInterpolate(p0, p1, v0, v1, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Hermite basis functions\n        const h00 = 2 * t3 - 3 * t2 + 1; // (1 + 2t)(1 - t)^2\n        const h10 = t3 - 2 * t2 + t; // t(1 - t)^2\n        const h01 = -2 * t3 + 3 * t2; // t^2(3 - 2t)\n        const h11 = t3 - t2; // t^2(t - 1)\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, h00);\n        result.addScaledVector(v0, h10);\n        result.addScaledVector(p1, h01);\n        result.addScaledVector(v1, h11);\n        return result;\n    }\n    /**\n   * Catmull-Rom spline interpolation for smooth curves through waypoints\n   */ static catmullRomInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Catmull-Rom basis functions\n        const c00 = -0.5 * t3 + t2 - 0.5 * t;\n        const c10 = 1.5 * t3 - 2.5 * t2 + 1;\n        const c20 = -1.5 * t3 + 2 * t2 + 0.5 * t;\n        const c30 = 0.5 * t3 - 0.5 * t2;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, c00);\n        result.addScaledVector(p1, c10);\n        result.addScaledVector(p2, c20);\n        result.addScaledVector(p3, c30);\n        return result;\n    }\n    /**\n   * Cubic Bezier interpolation for smooth curves with control points\n   */ static bezierInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const u = 1 - t;\n        const tt = t * t;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ttt = tt * t;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, uuu); // (1-t)^3 * p0\n        result.addScaledVector(p1, 3 * uu * t); // 3*(1-t)^2*t * p1\n        result.addScaledVector(p2, 3 * u * tt); // 3*(1-t)*t^2 * p2\n        result.addScaledVector(p3, ttt); // t^3 * p3\n        return result;\n    }\n    /**\n   * Smooth step interpolation for easing\n   */ static smoothStepInterpolate(start, end, t) {\n        // Smoothstep function: 3t^2 - 2t^3\n        const smoothT = t * t * (3 - 2 * t);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    /**\n   * Smoother step interpolation for even smoother easing\n   */ static smootherStepInterpolate(start, end, t) {\n        // Smootherstep function: 6t^5 - 15t^4 + 10t^3\n        const smoothT = t * t * t * (t * (6 * t - 15) + 10);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer\n        ];\n        this.currentTime = 0;\n        this.priority = 20; // Run after physics but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsK0RBQStEO0FBQ0g7QUFDdEI7QUFFaUI7QUFDYztBQUNoQjtBQUU5QyxNQUFNSyw0QkFBNEJKLCtDQUFNQTtJQVM3Qzs7R0FFQyxHQUNELE9BQWNNLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDQyxXQUFXLEdBQUdDLFlBQVlDLEdBQUc7UUFFbEMsS0FBSyxNQUFNQyxVQUFVTCxTQUFVO1lBQzdCLE1BQU1NLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1osZ0VBQVNBO1lBQy9DLE1BQU1hLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1lBQ25FLE1BQU1hLFdBQVdKLE9BQU9FLFlBQVksQ0FBQ1YsOERBQVFBO1lBRTdDLElBQUksRUFBQ1Msc0JBQUFBLGdDQUFBQSxVQUFXSSxPQUFPLEtBQUksRUFBQ0YsZ0NBQUFBLDBDQUFBQSxvQkFBcUJFLE9BQU8sR0FBRTtnQkFDeEQ7WUFDRjtZQUVBLGdGQUFnRjtZQUNoRixpRUFBaUU7WUFDakUsSUFBSUQsWUFBWUEsU0FBU0UsT0FBTyxFQUFFO2dCQUNoQztZQUNGO1lBRUEsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ04sV0FBV0U7UUFDcEM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBY1IsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxtRUFBbUU7UUFDbkUsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ0YsTUFBTSxDQUFDQyxVQUFVQztJQUN4QjtJQUVBOztHQUVDLEdBQ0Qsa0JBQTBCSyxTQUFvQixFQUFFRSxtQkFBd0MsRUFBUTtRQUM5RixNQUFNTSx3QkFBd0JOLG9CQUFvQk8sd0JBQXdCLENBQUMsSUFBSSxDQUFDYixXQUFXO1FBRTNGLDhCQUE4QjtRQUM5QkksVUFBVVUsUUFBUSxDQUFDQyxJQUFJLENBQUNILHNCQUFzQkUsUUFBUTtR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Qyw4RUFBbUJBO1NBQUM7YUFDN0RNLGNBQWM7UUFJcEIsSUFBSSxDQUFDa0UsUUFBUSxHQUFHLElBQUkseUNBQXlDO0lBQy9EO0FBNk1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHM/NjNlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbnRlcnBvbGF0aW9uIHN5c3RlbSBmb3Igc21vb3RoIGVudGl0eSBtb3ZlbWVudCBhbmQgcm90YXRpb25cbmltcG9ydCB7IFZlY3RvcjMsIFF1YXRlcm5pb24gfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBJbnRlcnBvbGF0aW9uQnVmZmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIEludGVycG9sYXRpb25CdWZmZXJdO1xuICBwcml2YXRlIGN1cnJlbnRUaW1lID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIHBoeXNpY3MgYnV0IGJlZm9yZSByZW5kZXJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJwb2xhdGlvbiBmb3IgYWxsIGVudGl0aWVzIHdpdGggaW50ZXJwb2xhdGlvbiBidWZmZXJzXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbkJ1ZmZlciA9IGVudGl0eS5nZXRDb21wb25lbnQoSW50ZXJwb2xhdGlvbkJ1ZmZlcik7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhaW50ZXJwb2xhdGlvbkJ1ZmZlcj8uZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBsb2NhbCBwbGF5ZXJzIChlbnRpdGllcyB0aGF0IGNhbiBtb3ZlKSAtIHRoZXkgc2hvdWxkIG5vdCBiZSBpbnRlcnBvbGF0ZWRcbiAgICAgIC8vIE9ubHkgcmVtb3RlIHBsYXllcnMgKGNhbk1vdmUgPSBmYWxzZSkgc2hvdWxkIHVzZSBpbnRlcnBvbGF0aW9uXG4gICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuY2FuTW92ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm0sIGludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgaW50ZXJwb2xhdGlvbiAoY2FsbGVkIGR1cmluZyByZW5kZXIgcGhhc2UgZm9yIHNtb290aCB2aXN1YWxzKVxuICAgKi9cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRm9yIG5vdywgcmVuZGVyIGFuZCB1cGRhdGUgcGhhc2VzIGFyZSB0aGUgc2FtZSBmb3IgaW50ZXJwb2xhdGlvblxuICAgIC8vIEluIHRoZSBmdXR1cmUsIHdlIGNvdWxkIHNlcGFyYXRlIGNvbmNlcm5zIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlKGVudGl0aWVzLCBkZWx0YVRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc2luZ2xlIGVudGl0eSdzIHRyYW5zZm9ybVxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgaW50ZXJwb2xhdGlvbkJ1ZmZlcjogSW50ZXJwb2xhdGlvbkJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRlZFRyYW5zZm9ybSA9IGludGVycG9sYXRpb25CdWZmZXIuZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gICAgLy8gQXBwbHkgaW50ZXJwb2xhdGVkIHBvc2l0aW9uXG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnBvc2l0aW9uKTtcblxuICAgIC8vIEFwcGx5IGludGVycG9sYXRlZCByb3RhdGlvblxuICAgIHRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnJvdGF0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNmb3JtJ3MgRXVsZXIgcm90YXRpb24gdG8gbWF0Y2ggdGhlIHF1YXRlcm5pb25cbiAgICB0cmFuc2Zvcm0ucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuXG4gICAgLy8gTWFyayBtYXRyaWNlcyBhcyBuZWVkaW5nIHVwZGF0ZVxuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNlcnZlciBzdGF0ZSB0byBhbiBlbnRpdHkncyBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGFkZFNlcnZlclN0YXRlKGVudGl0eTogRW50aXR5LCBwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmFkZFNlcnZlclN0YXRlKHBvc2l0aW9uLCByb3RhdGlvbiwgdGltZXN0YW1wKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGludGVycG9sYXRpb24gc3RhdGlzdGljcyBmb3IgZGVidWdnaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGlvblN0YXRzKGVudGl0eTogRW50aXR5KTogYW55IHtcbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQnVmZmVyID0gZW50aXR5LmdldENvbXBvbmVudChJbnRlcnBvbGF0aW9uQnVmZmVyKTtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbkJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGludGVycG9sYXRpb25CdWZmZXIuZ2V0QnVmZmVyU3RhdHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgaW50ZXJwb2xhdGlvbiBidWZmZXIgZm9yIGFuIGVudGl0eVxuICAgKi9cbiAgcHVibGljIGNsZWFySW50ZXJwb2xhdGlvbkJ1ZmZlcihlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmNsZWFyQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcnBvbGF0aW9uIGRlbGF5IGZvciBhbGwgZW50aXRpZXMgKGluIG1pbGxpc2Vjb25kcylcbiAgICovXG4gIHB1YmxpYyBzZXRJbnRlcnBvbGF0aW9uRGVsYXkoZW50aXR5OiBFbnRpdHksIGRlbGF5TXM6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIE5vdGU6IFRoaXMgd291bGQgcmVxdWlyZSBtb2RpZnlpbmcgdGhlIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50XG4gICAgLy8gRm9yIG5vdywgdGhlIGRlbGF5IGlzIGZpeGVkIGluIHRoZSBjb21wb25lbnQgaXRzZWxmXG4gICAgY29uc29sZS53YXJuKCdJbnRlcnBvbGF0aW9uIGRlbGF5IGlzIGN1cnJlbnRseSBmaXhlZCBpbiBJbnRlcnBvbGF0aW9uQnVmZmVyIGNvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByZW5kZXIgdGltZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0Q3VycmVudFJlbmRlclRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlZCBpbnRlcnBvbGF0aW9uIG1ldGhvZHMgZm9yIHNtb290aGVyIG1vdmVtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBIZXJtaXRlIHNwbGluZSBpbnRlcnBvbGF0aW9uIGZvciBzbW9vdGhlciBjdXJ2ZXNcbiAgICogVGhpcyBwcm92aWRlcyBiZXR0ZXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGtleWZyYW1lcyBieSBjb25zaWRlcmluZyB2ZWxvY2l0eVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBoZXJtaXRlSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvc2l0aW9uXG4gICAgcDE6IFZlY3RvcjMsIC8vIEVuZCBwb3NpdGlvblxuICAgIHYwOiBWZWN0b3IzLCAvLyBTdGFydCB2ZWxvY2l0eSAodGFuZ2VudClcbiAgICB2MTogVmVjdG9yMywgLy8gRW5kIHZlbG9jaXR5ICh0YW5nZW50KVxuICAgIHQ6IG51bWJlciAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBIZXJtaXRlIGJhc2lzIGZ1bmN0aW9uc1xuICAgIGNvbnN0IGgwMCA9IDIgKiB0MyAtIDMgKiB0MiArIDE7ICAgIC8vICgxICsgMnQpKDEgLSB0KV4yXG4gICAgY29uc3QgaDEwID0gdDMgLSAyICogdDIgKyB0OyAgICAgICAgLy8gdCgxIC0gdCleMlxuICAgIGNvbnN0IGgwMSA9IC0yICogdDMgKyAzICogdDI7ICAgICAgIC8vIHReMigzIC0gMnQpXG4gICAgY29uc3QgaDExID0gdDMgLSB0MjsgICAgICAgICAgICAgICAgLy8gdF4yKHQgLSAxKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBoMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IodjAsIGgxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgaDAxKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHYxLCBoMTEpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXRtdWxsLVJvbSBzcGxpbmUgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB0aHJvdWdoIHdheXBvaW50c1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFByZXZpb3VzIHBvaW50XG4gICAgcDE6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvaW50XG4gICAgcDI6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHAzOiBWZWN0b3IzLCAvLyBOZXh0IHBvaW50XG4gICAgdDogbnVtYmVyICAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBDYXRtdWxsLVJvbSBiYXNpcyBmdW5jdGlvbnNcbiAgICBjb25zdCBjMDAgPSAtMC41ICogdDMgKyB0MiAtIDAuNSAqIHQ7XG4gICAgY29uc3QgYzEwID0gMS41ICogdDMgLSAyLjUgKiB0MiArIDE7XG4gICAgY29uc3QgYzIwID0gLTEuNSAqIHQzICsgMiAqIHQyICsgMC41ICogdDtcbiAgICBjb25zdCBjMzAgPSAwLjUgKiB0MyAtIDAuNSAqIHQyO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBjMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDEsIGMxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMiwgYzIwKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCBjMzApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBCZXppZXIgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB3aXRoIGNvbnRyb2wgcG9pbnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGJlemllckludGVycG9sYXRlKFxuICAgIHAwOiBWZWN0b3IzLCAvLyBTdGFydCBwb2ludFxuICAgIHAxOiBWZWN0b3IzLCAvLyBDb250cm9sIHBvaW50IDFcbiAgICBwMjogVmVjdG9yMywgLy8gQ29udHJvbCBwb2ludCAyXG4gICAgcDM6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHQ6IG51bWJlciAgICAvLyBJbnRlcnBvbGF0aW9uIGZhY3RvciBbMCwxXVxuICApOiBWZWN0b3IzIHtcbiAgICBjb25zdCB1ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB1dSA9IHUgKiB1O1xuICAgIGNvbnN0IHV1dSA9IHV1ICogdTtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDAsIHV1dSk7ICAgICAgLy8gKDEtdCleMyAqIHAwXG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgMyAqIHV1ICogdCk7IC8vIDMqKDEtdCleMip0ICogcDFcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAyLCAzICogdSAqIHR0KTsgIC8vIDMqKDEtdCkqdF4yICogcDJcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCB0dHQpOyAgICAgICAvLyB0XjMgKiBwM1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTbW9vdGggc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBlYXNpbmdcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc21vb3RoU3RlcEludGVycG9sYXRlKHN0YXJ0OiBWZWN0b3IzLCBlbmQ6IFZlY3RvcjMsIHQ6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIC8vIFNtb290aHN0ZXAgZnVuY3Rpb246IDN0XjIgLSAydF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogKDMgLSAyICogdCk7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkubGVycFZlY3RvcnMoc3RhcnQsIGVuZCwgc21vb3RoVCk7XG4gIH1cblxuICAvKipcbiAgICogU21vb3RoZXIgc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBldmVuIHNtb290aGVyIGVhc2luZ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZShzdGFydDogVmVjdG9yMywgZW5kOiBWZWN0b3IzLCB0OiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAvLyBTbW9vdGhlcnN0ZXAgZnVuY3Rpb246IDZ0XjUgLSAxNXReNCArIDEwdF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogdCAqICh0ICogKDYgKiB0IC0gMTUpICsgMTApO1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygpLmxlcnBWZWN0b3JzKHN0YXJ0LCBlbmQsIHNtb290aFQpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkludGVycG9sYXRpb25CdWZmZXIiLCJNb3ZlbWVudCIsIkludGVycG9sYXRpb25TeXN0ZW0iLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImN1cnJlbnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJpbnRlcnBvbGF0aW9uQnVmZmVyIiwibW92ZW1lbnQiLCJlbmFibGVkIiwiY2FuTW92ZSIsImludGVycG9sYXRlRW50aXR5IiwicmVuZGVyIiwiaW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwicG9zaXRpb24iLCJjb3B5IiwicXVhdGVybmlvbiIsInJvdGF0aW9uIiwic2V0RnJvbVF1YXRlcm5pb24iLCJtYXRyaXhOZWVkc1VwZGF0ZSIsImFkZFNlcnZlclN0YXRlIiwidGltZXN0YW1wIiwiZ2V0SW50ZXJwb2xhdGlvblN0YXRzIiwiZ2V0QnVmZmVyU3RhdHMiLCJjbGVhckludGVycG9sYXRpb25CdWZmZXIiLCJjbGVhckJ1ZmZlciIsInNldEludGVycG9sYXRpb25EZWxheSIsImRlbGF5TXMiLCJjb25zb2xlIiwid2FybiIsImdldEN1cnJlbnRSZW5kZXJUaW1lIiwiaGVybWl0ZUludGVycG9sYXRlIiwicDAiLCJwMSIsInYwIiwidjEiLCJ0IiwidDIiLCJ0MyIsImgwMCIsImgxMCIsImgwMSIsImgxMSIsInJlc3VsdCIsImFkZFNjYWxlZFZlY3RvciIsImNhdG11bGxSb21JbnRlcnBvbGF0ZSIsInAyIiwicDMiLCJjMDAiLCJjMTAiLCJjMjAiLCJjMzAiLCJiZXppZXJJbnRlcnBvbGF0ZSIsInUiLCJ0dCIsInV1IiwidXV1IiwidHR0Iiwic21vb3RoU3RlcEludGVycG9sYXRlIiwic3RhcnQiLCJlbmQiLCJzbW9vdGhUIiwibGVycFZlY3RvcnMiLCJzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/InterpolationSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n            // console.warn(' Movement component missing updateDebuffs method:', movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar and tree collisions\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        const treeCollision = this.checkTreeCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else if (treeCollision.hasCollision) {\n            // Handle tree collision with smooth sliding\n            const slidePosition = this.calculateTreeSliding(currentPosition, deltaPosition, treeCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the tree to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(treeCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    checkTreeCollision(position) {\n        for (const treePos of this.TREE_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const treeHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(treePos.x, 0, treePos.z);\n            const distance = horizontalPos.distanceTo(treeHorizontal);\n            if (distance < this.TREE_RADIUS) {\n                // Calculate normal vector pointing away from tree center\n                const normal = horizontalPos.clone().sub(treeHorizontal).normalize();\n                // Handle case where player is exactly at tree center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    treeCenter: treePos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            treeCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    calculateTreeSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from tree center\n        const treeHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.treeCenter.x, 0, collision.treeCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(treeHorizontal);\n        if (distanceAfterSlide < this.TREE_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(treeHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = treeHorizontal.clone().add(pushDirection.multiplyScalar(this.TREE_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Define tree positions (same as in Environment.tsx - reduced by half)\n        this.TREE_POSITIONS = [\n            // Middle ring trees (selectively kept)\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(15, 0, 5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-15, 0, 5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(5, 0, 15),\n            // Outer ring trees (kept all - furthest from center)\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(20, 0, 10),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-20, 0, 10),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(20, 0, -10),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-20, 0, -10),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(10, 0, 20),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-10, 0, 20),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(10, 0, -20),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-10, 0, -20),\n            // Additional scattered tree (kept one for natural look)\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(12, 0, 12)\n        ];\n        this.TREE_RADIUS = 0.3 // Roughly half the pillar diameter\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO1lBQ0wsaUZBQWlGO1lBQ25GO1lBRUEsSUFBSSxDQUFDQyxjQUFjLENBQUNOLFdBQVdFLFVBQVVKO1FBQzNDO0lBQ0Y7SUFFT1MsWUFBWVYsUUFBa0IsRUFBRVcsY0FBc0IsRUFBUTtRQUNuRSwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNVCxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLFdBQVdILE9BQU9FLFlBQVksQ0FBQ04sOERBQVFBO1lBRTdDLDBDQUEwQztZQUMxQyxJQUFJLENBQUNLLGFBQWEsQ0FBQ0UsVUFBVTtnQkFDM0I7WUFDRjtZQUVBLElBQUksQ0FBQ0YsVUFBVUcsT0FBTyxJQUFJLENBQUNELFNBQVNDLE9BQU8sSUFBSSxDQUFDRCxTQUFTRSxPQUFPLEVB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REksaUJBQWlCO1lBQ2hDLHVDQUF1QztZQUN2QyxJQUFJbkUseURBQU9BLENBQUMsSUFBSSxHQUFHO1lBQUksSUFBSUEseURBQU9BLENBQUMsQ0FBQyxJQUFJLEdBQUc7WUFBSSxJQUFJQSx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7WUFDakUscURBQXFEO1lBQ3JELElBQUlBLHlEQUFPQSxDQUFDLElBQUksR0FBRztZQUFLLElBQUlBLHlEQUFPQSxDQUFDLENBQUMsSUFBSSxHQUFHO1lBQUssSUFBSUEseURBQU9BLENBQUMsSUFBSSxHQUFHLENBQUM7WUFBSyxJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDO1lBQy9GLElBQUlBLHlEQUFPQSxDQUFDLElBQUksR0FBRztZQUFLLElBQUlBLHlEQUFPQSxDQUFDLENBQUMsSUFBSSxHQUFHO1lBQUssSUFBSUEseURBQU9BLENBQUMsSUFBSSxHQUFHLENBQUM7WUFBSyxJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDO1lBQy9GLHdEQUF3RDtZQUN4RCxJQUFJQSx5REFBT0EsQ0FBQyxJQUFJLEdBQUc7U0FDcEI7YUFDZ0JxRSxjQUFjLElBQUssbUNBQW1DOztRQXBJckUsSUFBSSxDQUFDbUIsUUFBUSxHQUFHLElBQUksZ0RBQWdEO0lBQ3RFO0FBeVJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHM/MGNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaHlzaWNzIHN5c3RlbSBmb3IgaGFuZGxpbmcgbW92ZW1lbnQgcGh5c2ljc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIGFzIEJhc2VQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgUGh5c2ljc1N5c3RlbSBleHRlbmRzIEJhc2VQaHlzaWNzU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIE1vdmVtZW50XTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxNTsgLy8gUnVuIGFmdGVyIGNvbnRyb2wgc3lzdGVtIGJ1dCBiZWZvcmUgcmVuZGVyaW5nXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgZXZlcnkgZnJhbWUgZm9yIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXNcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcblxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBjb21wb25lbnRzIGFyZSBtaXNzaW5nXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhbW92ZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIW1vdmVtZW50LmVuYWJsZWQgfHwgIW1vdmVtZW50LmNhbk1vdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIChmcm96ZW4sIHNsb3dlZCwgZXRjLilcbiAgICAgIGlmICh0eXBlb2YgbW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBNb3ZlbWVudCBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVEZWJ1ZmZzIG1ldGhvZDonLCBtb3ZlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtLCBtb3ZlbWVudCwgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGx5UGh5c2ljcyh0cmFuc2Zvcm0sIG1vdmVtZW50LCBmaXhlZERlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3ZlbWVudCh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eVxuICAgIGNvbnN0IGRlbHRhUG9zaXRpb24gPSBtb3ZlbWVudC52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBvdGVudGlhbCBuZXcgcG9zaXRpb25cbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0cmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICBjb25zdCBwb3RlbnRpYWxQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkZWx0YVBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBtYXAgYm91bmRhcnkgY29uc3RyYWludHMgd2l0aCBzbW9vdGggc2xpZGluZyAocmFkaXVzIG9mIDI5IHVuaXRzIGZyb20gb3JpZ2luKVxuICAgIGNvbnN0IE1BUF9SQURJVVMgPSAyOTtcbiAgICBcbiAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZIGZvciBib3VuZGFyeSlcbiAgICBjb25zdCBob3Jpem9udGFsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhwb3RlbnRpYWxQb3NpdGlvbi54LCAwLCBwb3RlbnRpYWxQb3NpdGlvbi56KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBob3Jpem9udGFsUG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBhbmQgdHJlZSBjb2xsaXNpb25zXG4gICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihwb3RlbnRpYWxQb3NpdGlvbik7XG4gICAgY29uc3QgdHJlZUNvbGxpc2lvbiA9IHRoaXMuY2hlY2tUcmVlQ29sbGlzaW9uKHBvdGVudGlhbFBvc2l0aW9uKTtcblxuICAgIGlmIChkaXN0YW5jZUZyb21DZW50ZXIgPj0gTUFQX1JBRElVUykge1xuICAgICAgLy8gSWYgd2UgaGl0IHRoZSBib3VuZGFyeSwgY2FsY3VsYXRlIHRhbmdlbnQgbW92ZW1lbnQgZm9yIHNtb290aCBzbGlkaW5nXG4gICAgICBjb25zdCBjdXJyZW50SG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKGN1cnJlbnRQb3NpdGlvbi54LCAwLCBjdXJyZW50UG9zaXRpb24ueik7XG4gICAgICBjb25zdCB0b0NlbnRlciA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmNsb25lKCkubm9ybWFsaXplKCk7XG5cbiAgICAgIC8vIENyZWF0ZSB0YW5nZW50IHZlY3RvciAocGVycGVuZGljdWxhciB0byByYWRpdXMpXG4gICAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLXRvQ2VudGVyLnosIDAsIHRvQ2VudGVyLngpO1xuXG4gICAgICAvLyBQcm9qZWN0IG91ciBob3Jpem9udGFsIG1vdmVtZW50IG9udG8gdGhlIHRhbmdlbnRcbiAgICAgIGNvbnN0IGhvcml6b250YWxNb3ZlbWVudCA9IG5ldyBWZWN0b3IzKGRlbHRhUG9zaXRpb24ueCwgMCwgZGVsdGFQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRhbmdlbnRNb3ZlbWVudCA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIoaG9yaXpvbnRhbE1vdmVtZW50LmRvdCh0YW5nZW50KSk7XG5cbiAgICAgIC8vIEFwcGx5IHRoZSB0YW5nZW50aWFsIG1vdmVtZW50IHdoaWxlIGtlZXBpbmcgZGlzdGFuY2UgdG8gY2VudGVyIGNvbnN0YW50XG4gICAgICBjb25zdCBuZXdIb3Jpem9udGFsUG9zaXRpb24gPSBjdXJyZW50SG9yaXpvbnRhbFBvcy5hZGQodGFuZ2VudE1vdmVtZW50KTtcbiAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihNQVBfUkFESVVTKTtcblxuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIHdpdGggdGFuZ2VudCBtb3ZlbWVudCBhbmQgcHJlc2VydmUgWSBtb3ZlbWVudFxuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKFxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24ueCxcbiAgICAgICAgY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksIC8vIEFsbG93IHZlcnRpY2FsIG1vdmVtZW50IChqdW1waW5nLCBmYWxsaW5nKVxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24uelxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgIC8vIEhhbmRsZSBwaWxsYXIgY29sbGlzaW9uIHdpdGggc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uLCBkZWx0YVBvc2l0aW9uLCBwaWxsYXJDb2xsaXNpb24pO1xuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKHNsaWRlUG9zaXRpb24ueCwgc2xpZGVQb3NpdGlvbi55LCBzbGlkZVBvc2l0aW9uLnopO1xuXG4gICAgICAvLyBSZWR1Y2UgdmVsb2NpdHkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlsbGFyIHRvIHByZXZlbnQgYm91bmNpbmdcbiAgICAgIGNvbnN0IHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50ID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IocGlsbGFyQ29sbGlzaW9uLm5vcm1hbCk7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS5zdWIodmVsb2NpdHlOb3JtYWxDb21wb25lbnQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgfSBlbHNlIGlmICh0cmVlQ29sbGlzaW9uLmhhc0NvbGxpc2lvbikge1xuICAgICAgLy8gSGFuZGxlIHRyZWUgY29sbGlzaW9uIHdpdGggc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVRyZWVTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbiwgZGVsdGFQb3NpdGlvbiwgdHJlZUNvbGxpc2lvbik7XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oc2xpZGVQb3NpdGlvbi54LCBzbGlkZVBvc2l0aW9uLnksIHNsaWRlUG9zaXRpb24ueik7XG5cbiAgICAgIC8vIFJlZHVjZSB2ZWxvY2l0eSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmVlIHRvIHByZXZlbnQgYm91bmNpbmdcbiAgICAgIGNvbnN0IHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50ID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IodHJlZUNvbGxpc2lvbi5ub3JtYWwpO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkuc3ViKHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50Lm11bHRpcGx5U2NhbGFyKDAuNSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3aXRoaW4gYm91bmRzIGFuZCBubyBjb2xsaXNpb24sIG1vdmUgbm9ybWFsbHlcbiAgICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoZGVsdGFQb3NpdGlvbi54LCBkZWx0YVBvc2l0aW9uLnksIGRlbHRhUG9zaXRpb24ueik7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0cmFuc2Zvcm0gbWF0cml4IGFzIG5lZWRpbmcgdXBkYXRlXG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgLy8gRGVmaW5lIHRyZWUgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeCAtIHJlZHVjZWQgYnkgaGFsZilcbiAgcHJpdmF0ZSByZWFkb25seSBUUkVFX1BPU0lUSU9OUyA9IFtcbiAgICAvLyBNaWRkbGUgcmluZyB0cmVlcyAoc2VsZWN0aXZlbHkga2VwdClcbiAgICBuZXcgVmVjdG9yMygxNSwgMCwgNSksIG5ldyBWZWN0b3IzKC0xNSwgMCwgNSksIG5ldyBWZWN0b3IzKDUsIDAsIDE1KSxcbiAgICAvLyBPdXRlciByaW5nIHRyZWVzIChrZXB0IGFsbCAtIGZ1cnRoZXN0IGZyb20gY2VudGVyKVxuICAgIG5ldyBWZWN0b3IzKDIwLCAwLCAxMCksIG5ldyBWZWN0b3IzKC0yMCwgMCwgMTApLCBuZXcgVmVjdG9yMygyMCwgMCwgLTEwKSwgbmV3IFZlY3RvcjMoLTIwLCAwLCAtMTApLFxuICAgIG5ldyBWZWN0b3IzKDEwLCAwLCAyMCksIG5ldyBWZWN0b3IzKC0xMCwgMCwgMjApLCBuZXcgVmVjdG9yMygxMCwgMCwgLTIwKSwgbmV3IFZlY3RvcjMoLTEwLCAwLCAtMjApLFxuICAgIC8vIEFkZGl0aW9uYWwgc2NhdHRlcmVkIHRyZWUgKGtlcHQgb25lIGZvciBuYXR1cmFsIGxvb2spXG4gICAgbmV3IFZlY3RvcjMoMTIsIDAsIDEyKVxuICBdO1xuICBwcml2YXRlIHJlYWRvbmx5IFRSRUVfUkFESVVTID0gMC4zOyAvLyBSb3VnaGx5IGhhbGYgdGhlIHBpbGxhciBkaWFtZXRlclxuXG4gIHByaXZhdGUgY2hlY2tQaWxsYXJDb2xsaXNpb24ocG9zaXRpb246IFZlY3RvcjMpOiB7IGhhc0NvbGxpc2lvbjogYm9vbGVhbjsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSB7XG4gICAgZm9yIChjb25zdCBwaWxsYXJQb3Mgb2YgdGhpcy5QSUxMQVJfUE9TSVRJT05TKSB7XG4gICAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKHBvc2l0aW9uLngsIDAsIHBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHBpbGxhclBvcy54LCAwLCBwaWxsYXJQb3Mueik7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGhvcml6b250YWxQb3MuZGlzdGFuY2VUbyhwaWxsYXJIb3Jpem9udGFsKTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5QSUxMQVJfUkFESVVTKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBub3JtYWwgdmVjdG9yIHBvaW50aW5nIGF3YXkgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGhvcml6b250YWxQb3MuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHBsYXllciBpcyBleGFjdGx5IGF0IHBpbGxhciBjZW50ZXJcbiAgICAgICAgaWYgKG5vcm1hbC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIG5vcm1hbC5zZXQoMSwgMCwgMCk7IC8vIERlZmF1bHQgZGlyZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNDb2xsaXNpb246IHRydWUsXG4gICAgICAgICAgbm9ybWFsOiBub3JtYWwsXG4gICAgICAgICAgcGlsbGFyQ2VudGVyOiBwaWxsYXJQb3MuY2xvbmUoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVHJlZUNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHRyZWVDZW50ZXI6IFZlY3RvcjMgfSB7XG4gICAgZm9yIChjb25zdCB0cmVlUG9zIG9mIHRoaXMuVFJFRV9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCB0cmVlSG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHRyZWVQb3MueCwgMCwgdHJlZVBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHRyZWVIb3Jpem9udGFsKTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5UUkVFX1JBRElVUykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbm9ybWFsIHZlY3RvciBwb2ludGluZyBhd2F5IGZyb20gdHJlZSBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1Yih0cmVlSG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHBsYXllciBpcyBleGFjdGx5IGF0IHRyZWUgY2VudGVyXG4gICAgICAgIGlmIChub3JtYWwubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICBub3JtYWwuc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzQ29sbGlzaW9uOiB0cnVlLFxuICAgICAgICAgIG5vcm1hbDogbm9ybWFsLFxuICAgICAgICAgIHRyZWVDZW50ZXI6IHRyZWVQb3MuY2xvbmUoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgdHJlZUNlbnRlcjogbmV3IFZlY3RvcjMoKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVQaWxsYXJTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMywgZGVsdGFQb3NpdGlvbjogVmVjdG9yMywgY29sbGlzaW9uOiB7IG5vcm1hbDogVmVjdG9yMzsgcGlsbGFyQ2VudGVyOiBWZWN0b3IzIH0pOiBWZWN0b3IzIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIG5vcm1hbCBpbiBYWiBwbGFuZSlcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLWNvbGxpc2lvbi5ub3JtYWwueiwgMCwgY29sbGlzaW9uLm5vcm1hbC54KTtcblxuICAgIC8vIFByb2plY3QgdGhlIG1vdmVtZW50IHZlY3RvciBvbnRvIHRoZSB0YW5nZW50IGZvciBzbGlkaW5nXG4gICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gZGVsdGFQb3NpdGlvbi5jbG9uZSgpLnByb2plY3RPblZlY3Rvcih0YW5nZW50KTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBvc2l0aW9uIHdpdGggc2xpZGluZyBtb3ZlbWVudFxuICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24uY2xvbmUoKS5hZGQodGFuZ2VudE1vdmVtZW50KTtcblxuICAgIC8vIEVuc3VyZSB3ZSBtYWludGFpbiBtaW5pbXVtIGRpc3RhbmNlIGZyb20gcGlsbGFyIGNlbnRlclxuICAgIGNvbnN0IHBpbGxhckhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhjb2xsaXNpb24ucGlsbGFyQ2VudGVyLngsIDAsIGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueik7XG4gICAgY29uc3Qgc2xpZGVIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMoc2xpZGVQb3NpdGlvbi54LCAwLCBzbGlkZVBvc2l0aW9uLnopO1xuICAgIGNvbnN0IGRpc3RhbmNlQWZ0ZXJTbGlkZSA9IHNsaWRlSG9yaXpvbnRhbC5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuXG4gICAgaWYgKGRpc3RhbmNlQWZ0ZXJTbGlkZSA8IHRoaXMuUElMTEFSX1JBRElVUykge1xuICAgICAgLy8gUHVzaCB0aGUgcG9zaXRpb24gdG8gbWFpbnRhaW4gbWluaW11bSBkaXN0YW5jZVxuICAgICAgY29uc3QgcHVzaERpcmVjdGlvbiA9IHNsaWRlSG9yaXpvbnRhbC5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChwdXNoRGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHB1c2hEaXJlY3Rpb24uc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgfVxuICAgICAgY29uc3QgY29ycmVjdGVkSG9yaXpvbnRhbCA9IHBpbGxhckhvcml6b250YWwuY2xvbmUoKS5hZGQocHVzaERpcmVjdGlvbi5tdWx0aXBseVNjYWxhcih0aGlzLlBJTExBUl9SQURJVVMpKTtcbiAgICAgIHNsaWRlUG9zaXRpb24ueCA9IGNvcnJlY3RlZEhvcml6b250YWwueDtcbiAgICAgIHNsaWRlUG9zaXRpb24ueiA9IGNvcnJlY3RlZEhvcml6b250YWwuejtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGVQb3NpdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlVHJlZVNsaWRpbmcoY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBkZWx0YVBvc2l0aW9uOiBWZWN0b3IzLCBjb2xsaXNpb246IHsgbm9ybWFsOiBWZWN0b3IzOyB0cmVlQ2VudGVyOiBWZWN0b3IzIH0pOiBWZWN0b3IzIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIG5vcm1hbCBpbiBYWiBwbGFuZSlcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLWNvbGxpc2lvbi5ub3JtYWwueiwgMCwgY29sbGlzaW9uLm5vcm1hbC54KTtcblxuICAgIC8vIFByb2plY3QgdGhlIG1vdmVtZW50IHZlY3RvciBvbnRvIHRoZSB0YW5nZW50IGZvciBzbGlkaW5nXG4gICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gZGVsdGFQb3NpdGlvbi5jbG9uZSgpLnByb2plY3RPblZlY3Rvcih0YW5nZW50KTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBvc2l0aW9uIHdpdGggc2xpZGluZyBtb3ZlbWVudFxuICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24uY2xvbmUoKS5hZGQodGFuZ2VudE1vdmVtZW50KTtcblxuICAgIC8vIEVuc3VyZSB3ZSBtYWludGFpbiBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdHJlZSBjZW50ZXJcbiAgICBjb25zdCB0cmVlSG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKGNvbGxpc2lvbi50cmVlQ2VudGVyLngsIDAsIGNvbGxpc2lvbi50cmVlQ2VudGVyLnopO1xuICAgIGNvbnN0IHNsaWRlSG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHNsaWRlUG9zaXRpb24ueCwgMCwgc2xpZGVQb3NpdGlvbi56KTtcbiAgICBjb25zdCBkaXN0YW5jZUFmdGVyU2xpZGUgPSBzbGlkZUhvcml6b250YWwuZGlzdGFuY2VUbyh0cmVlSG9yaXpvbnRhbCk7XG5cbiAgICBpZiAoZGlzdGFuY2VBZnRlclNsaWRlIDwgdGhpcy5UUkVFX1JBRElVUykge1xuICAgICAgLy8gUHVzaCB0aGUgcG9zaXRpb24gdG8gbWFpbnRhaW4gbWluaW11bSBkaXN0YW5jZVxuICAgICAgY29uc3QgcHVzaERpcmVjdGlvbiA9IHNsaWRlSG9yaXpvbnRhbC5jbG9uZSgpLnN1Yih0cmVlSG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICBpZiAocHVzaERpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICBwdXNoRGlyZWN0aW9uLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcnJlY3RlZEhvcml6b250YWwgPSB0cmVlSG9yaXpvbnRhbC5jbG9uZSgpLmFkZChwdXNoRGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMuVFJFRV9SQURJVVMpKTtcbiAgICAgIHNsaWRlUG9zaXRpb24ueCA9IGNvcnJlY3RlZEhvcml6b250YWwueDtcbiAgICAgIHNsaWRlUG9zaXRpb24ueiA9IGNvcnJlY3RlZEhvcml6b250YWwuejtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGVQb3NpdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlQaHlzaWNzKHRyYW5zZm9ybTogVHJhbnNmb3JtLCBtb3ZlbWVudDogTW92ZW1lbnQsIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQXBwbHkgZ3Jhdml0eSAob25seSBhZmZlY3RzIFkgdmVsb2NpdHkpXG4gICAgbW92ZW1lbnQuYXBwbHlHcmF2aXR5KGRlbHRhVGltZSk7XG5cbiAgICAvLyBIYW5kbGUgaG9yaXpvbnRhbCBtb3ZlbWVudCBkaXJlY3RseSBmb3IgaW1tZWRpYXRlIHJlc3BvbnNlXG4gICAgaWYgKG1vdmVtZW50LmlucHV0U3RyZW5ndGggPiAwKSB7XG4gICAgICAvLyBVc2UgZWZmZWN0aXZlIG1heCBzcGVlZCB3aGljaCBhY2NvdW50cyBmb3IgZnJvemVuL3Nsb3dlZCBzdGF0ZXNcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZU1heFNwZWVkID0gbW92ZW1lbnQuZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTtcbiAgICAgIFxuICAgICAgLy8gRGlyZWN0IHZlbG9jaXR5IHNldHRpbmcgZm9yIHJlc3BvbnNpdmUgbW92ZW1lbnRcbiAgICAgIGNvbnN0IHRhcmdldFZlbG9jaXR5ID0gbW92ZW1lbnQubW92ZURpcmVjdGlvbi5jbG9uZSgpO1xuICAgICAgdGFyZ2V0VmVsb2NpdHkubXVsdGlwbHlTY2FsYXIoZWZmZWN0aXZlTWF4U3BlZWQgKiBtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGhvcml6b250YWwgdmVsb2NpdHkgZGlyZWN0bHkgKHByZXNlcnZlIFkgdmVsb2NpdHkgZm9yIGdyYXZpdHkvanVtcGluZylcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnggPSB0YXJnZXRWZWxvY2l0eS54O1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueiA9IHRhcmdldFZlbG9jaXR5Lno7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGlucHV0IC0gc3RvcCBob3Jpem9udGFsIG1vdmVtZW50IGltbWVkaWF0ZWx5IGZvciByZXNwb25zaXZlIGNvbnRyb2xzXG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS54ID0gMDtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnogPSAwO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGFueSBhZGRpdGlvbmFsIGZvcmNlcyAobGlrZSBrbm9ja2JhY2ssIHdpbmQsIGV0Yy4pXG4gICAgbW92ZW1lbnQudmVsb2NpdHkuYWRkKG1vdmVtZW50LmFjY2VsZXJhdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSkpO1xuXG4gICAgLy8gUmVzZXQgYWNjZWxlcmF0aW9uIGZvciBuZXh0IGZyYW1lXG4gICAgbW92ZW1lbnQuYWNjZWxlcmF0aW9uLnNldCgwLCAwLCAwKTtcblxuICAgIC8vIFNpbXBsZSBncm91bmQgY2hlY2sgKFkgPSAwIGlzIGdyb3VuZCBsZXZlbCwgYWNjb3VudCBmb3Igc3BoZXJlIHJhZGl1cylcbiAgICBjb25zdCBzcGhlcmVSYWRpdXMgPSAwLjU7IC8vIFBsYXllciBzcGhlcmUgcmFkaXVzXG4gICAgY29uc3QgZ3JvdW5kTGV2ZWwgPSBzcGhlcmVSYWRpdXM7IC8vIFNwaGVyZSBjZW50ZXIgc2hvdWxkIGJlIGF0IHJhZGl1cyBoZWlnaHQgYWJvdmUgZ3JvdW5kXG4gICAgXG4gICAgaWYgKHRyYW5zZm9ybS5wb3NpdGlvbi55IDw9IGdyb3VuZExldmVsICYmIG1vdmVtZW50LnZlbG9jaXR5LnkgPD0gMCkge1xuICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSBncm91bmRMZXZlbDtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnkgPSAwO1xuICAgICAgbW92ZW1lbnQuaXNHcm91bmRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVtZW50LmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiUGh5c2ljc1N5c3RlbSIsIkJhc2VQaHlzaWNzU3lzdGVtIiwiVHJhbnNmb3JtIiwiTW92ZW1lbnQiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsIm1vdmVtZW50IiwiZW5hYmxlZCIsImNhbk1vdmUiLCJ1cGRhdGVEZWJ1ZmZzIiwidXBkYXRlTW92ZW1lbnQiLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwiYXBwbHlQaHlzaWNzIiwiZGVsdGFQb3NpdGlvbiIsInZlbG9jaXR5IiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwicG90ZW50aWFsUG9zaXRpb24iLCJhZGQiLCJNQVBfUkFESVVTIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwieCIsInoiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJsZW5ndGgiLCJwaWxsYXJDb2xsaXNpb24iLCJjaGVja1BpbGxhckNvbGxpc2lvbiIsInRyZWVDb2xsaXNpb24iLCJjaGVja1RyZWVDb2xsaXNpb24iLCJjdXJyZW50SG9yaXpvbnRhbFBvcyIsInRvQ2VudGVyIiwibm9ybWFsaXplIiwidGFuZ2VudCIsImhvcml6b250YWxNb3ZlbWVudCIsInRhbmdlbnRNb3ZlbWVudCIsImRvdCIsIm5ld0hvcml6b250YWxQb3NpdGlvbiIsInNldFBvc2l0aW9uIiwieSIsImhhc0NvbGxpc2lvbiIsInNsaWRlUG9zaXRpb24iLCJjYWxjdWxhdGVQaWxsYXJTbGlkaW5nIiwidmVsb2NpdHlOb3JtYWxDb21wb25lbnQiLCJwcm9qZWN0T25WZWN0b3IiLCJub3JtYWwiLCJzdWIiLCJjYWxjdWxhdGVUcmVlU2xpZGluZyIsInRyYW5zbGF0ZSIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiUElMTEFSX1JBRElVUyIsInNldCIsInBpbGxhckNlbnRlciIsInRyZWVQb3MiLCJUUkVFX1BPU0lUSU9OUyIsInRyZWVIb3Jpem9udGFsIiwiVFJFRV9SQURJVVMiLCJ0cmVlQ2VudGVyIiwiY29sbGlzaW9uIiwic2xpZGVIb3Jpem9udGFsIiwiZGlzdGFuY2VBZnRlclNsaWRlIiwicHVzaERpcmVjdGlvbiIsImNvcnJlY3RlZEhvcml6b250YWwiLCJhcHBseUdyYXZpdHkiLCJpbnB1dFN0cmVuZ3RoIiwiZWZmZWN0aXZlTWF4U3BlZWQiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsInRhcmdldFZlbG9jaXR5IiwibW92ZURpcmVjdGlvbiIsImFjY2VsZXJhdGlvbiIsInNwaGVyZVJhZGl1cyIsImdyb3VuZExldmVsIiwiaXNHcm91bmRlZCIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Update homing direction if projectile is homing\n            this.updateHomingDirection(entity, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    updateHomingDirection(projectileEntity, projectile, deltaTime) {\n        // Skip if not homing\n        if (!projectile.targetEntityId || projectile.homingStrength <= 0) {\n            return;\n        }\n        // Get target entity\n        const targetEntity = this.world.getEntity(projectile.targetEntityId);\n        if (!targetEntity) {\n            // Target no longer exists, disable homing\n            projectile.disableHoming();\n            return;\n        }\n        // Get target position\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            projectile.disableHoming();\n            return;\n        }\n        // Get projectile position\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!projectileTransform) {\n            return;\n        }\n        // Check if this is a tower projectile for special handling\n        const isTowerProjectile = projectileEntity.isTowerProjectile === true;\n        // Calculate direction to target\n        const currentPosition = projectileTransform.position;\n        const targetPosition = targetTransform.position;\n        this.tempVector.copy(targetPosition).sub(currentPosition);\n        const distanceToTarget = this.tempVector.length();\n        // For tower projectiles, use more aggressive homing even at close range\n        const minDistanceThreshold = isTowerProjectile ? 0.05 : 0.1; // Closer threshold for towers\n        // If very close to target and not a tower projectile, maintain current direction\n        if (distanceToTarget < minDistanceThreshold && !isTowerProjectile) {\n            return;\n        }\n        // Normalize target direction\n        this.tempVector.normalize();\n        // Get current velocity direction\n        const currentDirection = projectile.velocity.clone().normalize();\n        // For tower projectiles, use more direct approach when very close\n        if (isTowerProjectile && distanceToTarget < 0.3) {\n            // Direct approach: immediately adjust towards target\n            const desiredDirection = this.tempVector.clone();\n            const angle = currentDirection.angleTo(desiredDirection);\n            // For tower projectiles, allow much more aggressive turning when close\n            const maxTurnThisFrame = projectile.maxTurnRate * deltaTime * 2; // Double the turn rate when close\n            const turnAngle = Math.min(angle, maxTurnThisFrame);\n            if (turnAngle > 0.001) {\n                const rotationAxis = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                rotationAxis.crossVectors(currentDirection, desiredDirection).normalize();\n                const newDirection = currentDirection.clone();\n                newDirection.applyAxisAngle(rotationAxis, turnAngle);\n                projectile.velocity.copy(newDirection).multiplyScalar(projectile.speed);\n            }\n        } else {\n            // Standard homing logic with enhanced strength for tower projectiles\n            const homingStrength = isTowerProjectile ? Math.min(projectile.homingStrength + 0.1, 1.0) : projectile.homingStrength;\n            // Calculate desired direction (interpolate between current and target direction)\n            const desiredDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            desiredDirection.lerpVectors(currentDirection, this.tempVector, homingStrength);\n            // Calculate angle between current and desired direction\n            const angle = currentDirection.angleTo(desiredDirection);\n            // Limit turn rate (more aggressive for tower projectiles)\n            const maxTurnThisFrame = projectile.maxTurnRate * deltaTime;\n            const turnAngle = Math.min(angle, maxTurnThisFrame);\n            // If we need to turn\n            if (turnAngle > 0.001) {\n                // Calculate rotation axis\n                const rotationAxis = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                rotationAxis.crossVectors(currentDirection, desiredDirection).normalize();\n                // Create rotation quaternion\n                const cosHalfAngle = Math.cos(turnAngle / 2);\n                const sinHalfAngle = Math.sin(turnAngle / 2);\n                // Apply rotation to current direction\n                const newDirection = currentDirection.clone();\n                newDirection.applyAxisAngle(rotationAxis, turnAngle);\n                // Update velocity while maintaining speed\n                projectile.velocity.copy(newDirection).multiplyScalar(projectile.speed);\n            }\n        }\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n        const projectilePos = transform.position;\n        // Skip barrage and viper sting projectiles in PVP mode - they should only be handled by specialized PVP managers\n        const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        if ((renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isBarrageArrow) || (renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.projectileType) === \"viper_sting\") {\n            // In PVP mode, these projectiles are handled by the specialized PVP managers\n            // Skip ECS collision detection to prevent duplicate damage and self-targeting\n            return;\n        }\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                // console.log(` Projectile ${projectileEntity.id} skipping owner ${projectile.owner} (target ${target.id})`);\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                continue;\n            }\n            // CRITICAL PVP FIX: Prevent Viper Sting projectiles from hitting the local player\n            // In PVP, Viper Sting projectiles from remote players should not damage the local player\n            // The local player always has CollisionLayer.PLAYER, while remote players have CollisionLayer.ENEMY\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && projectile.projectileType === \"viper_sting\") {\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn(' Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.sourcePlayerId = (config === null || config === void 0 ? void 0 : config.sourcePlayerId) || \"unknown\";\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn(' Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 2;\n        projectile.owner = ownerId;\n        projectile.sourcePlayerId = (config === null || config === void 0 ? void 0 : config.sourcePlayerId) || \"unknown\";\n        projectile.projectileType = (config === null || config === void 0 ? void 0 : config.projectileType) || \"generic\";\n        projectile.setDirection(direction);\n        projectile.setStartPosition(position);\n        // Set max distance if specified (for bow arrows)\n        if ((config === null || config === void 0 ? void 0 : config.maxDistance) !== undefined) {\n            projectile.setMaxDistance(config.maxDistance);\n        }\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling (will be overridden by TowerSystem if it's a tower projectile)\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        placeholderMesh.userData.projectileType = config === null || config === void 0 ? void 0 : config.projectileType;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n        // console.warn(' Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FO0FBQytCO0FBQzdEO0FBRWlCO0FBQ0U7QUFDUjtBQUNJO0FBQ2dCO0FBR3JCO0FBTXpDLE1BQU1hLHlCQUF5QlIsK0NBQU1BO0lBOEJuQ1MsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixhQUFhSCxPQUFPRSxZQUFZLENBQUNoQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZSxVQUFVRyxPQUFPLElBQUksQ0FBQ0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM3QztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXUixNQUFNLENBQUNFO1lBRWxCLGtDQUFrQztZQUNsQyxJQUFJTSxXQUFXRSxTQUFTLElBQUk7Z0JBQzFCLElBQUksQ0FBQ1Asb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDeEM7WUFDRjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLGNBQWMsQ0FBQ1AsV0FBV0UsWUFBWU47WUFFM0Msa0RBQWtEO1lBQ2xELElBQUksQ0FBQ1kscUJBQXFCLENBQUNULFFBQVFHLFlBQVlOO1lBRS9DLDRFQUE0RTtZQUM1RSxtREFBbUQ7WUFFbkQsbUJBQW1CO1lBQ25CLElBQUksQ0FBQ2EsZUFBZSxDQUFDVixRQUFRQyxXQUFXRTtZQUV4Qyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBQ1gsUUFBUUM7UUFDaEM7UUFFQSw4QkFBOEI7UUFD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LFlBQVk5SSxLQUFZLENBQUU7UUFDeEIsS0FBSzthQWZTK0kscUJBQXFCO1lBQUMzSyxnRUFBU0E7WUFBRUMsa0VBQVVBO1NBQUM7YUFFcERRLGVBQW9DO2FBQ3BDSSx1QkFBaUMsRUFBRTtRQU8zQyx5Q0FBeUM7YUFDakNpQixhQUFhLElBQUlwQyx5REFBT0E7YUFDeEJrTCxjQUFjLElBQUlsTCx5REFBT0E7UUFJL0IsSUFBSSxDQUFDa0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2lKLFFBQVEsR0FBRyxJQUFJLHFCQUFxQjtRQUl6QywwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDUCxXQUFXLEdBQUcsSUFBSWhLLHlEQUFVQSxDQUMvQixJQUFNLElBQUlaLHlEQUFPQSxJQUNqQixDQUFDb0wsU0FBV0EsT0FBT0MsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUM3QjtJQUVKO0FBd3FCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Qcm9qZWN0aWxlU3lzdGVtLnRzPzAwYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdGlsZSBzeXN0ZW0gZm9yIGhhbmRsaW5nIHByb2plY3RpbGUgbW92ZW1lbnQgYW5kIGNvbGxpc2lvbnNcbmltcG9ydCB7IFZlY3RvcjMsIENvbG9yLCBTcGhlcmVHZW9tZXRyeSwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIE1lc2ggfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBQcm9qZWN0aWxlIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IE9iamVjdFBvb2wgfSBmcm9tICdAL3V0aWxzL09iamVjdFBvb2wnO1xuXG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcyB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgQ3Jvc3NlbnRyb3B5Qm9sdCBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvQ3Jvc3NlbnRyb3B5Qm9sdCc7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aWxlU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFByb2plY3RpbGVdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBjb21iYXRTeXN0ZW06IENvbWJhdFN5c3RlbSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHByb2plY3RpbGVzVG9EZXN0cm95OiBudW1iZXJbXSA9IFtdO1xuICBcblxuICBcbiAgLy8gT2JqZWN0IHBvb2xzIGZvciBwZXJmb3JtYW5jZSAoa2VlcGluZyB2ZWN0b3IgcG9vbCBmb3IgY2FsY3VsYXRpb25zKVxuICBwcml2YXRlIHZlY3RvcjNQb29sOiBPYmplY3RQb29sPFZlY3RvcjM+O1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDIwOyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnRcbiAgICBcblxuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdmVjdG9yIHBvb2wgZm9yIGNhbGN1bGF0aW9uc1xuICAgIHRoaXMudmVjdG9yM1Bvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBWZWN0b3IzKCksXG4gICAgICAodmVjdG9yKSA9PiB2ZWN0b3Iuc2V0KDAsIDAsIDApLFxuICAgICAgMTAwXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb21iYXRTeXN0ZW0oY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLmNvbWJhdFN5c3RlbSA9IGNvbWJhdFN5c3RlbTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kubGVuZ3RoID0gMDtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcHJvamVjdGlsZSA9IGVudGl0eS5nZXRDb21wb25lbnQoUHJvamVjdGlsZSkhO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFwcm9qZWN0aWxlLmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBwcm9qZWN0aWxlXG4gICAgICBwcm9qZWN0aWxlLnVwZGF0ZShkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGhhcyBleHBpcmVkXG4gICAgICBpZiAocHJvamVjdGlsZS5pc0V4cGlyZWQoKSkge1xuICAgICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2goZW50aXR5LmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgcHJvamVjdGlsZVxuICAgICAgdGhpcy5tb3ZlUHJvamVjdGlsZSh0cmFuc2Zvcm0sIHByb2plY3RpbGUsIGRlbHRhVGltZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBob21pbmcgZGlyZWN0aW9uIGlmIHByb2plY3RpbGUgaXMgaG9taW5nXG4gICAgICB0aGlzLnVwZGF0ZUhvbWluZ0RpcmVjdGlvbihlbnRpdHksIHByb2plY3RpbGUsIGRlbHRhVGltZSk7XG5cbiAgICAgIC8vIEFycm93IG9yaWVudGF0aW9uIGlzIHNldCBvbmNlIGF0IGNyZWF0aW9uIC0gbm8gbmVlZCB0byB1cGRhdGUgZXZlcnkgZnJhbWVcbiAgICAgIC8vIHRoaXMudXBkYXRlQXJyb3dPcmllbnRhdGlvbihlbnRpdHksIHByb2plY3RpbGUpO1xuXG4gICAgICAvLyBDaGVjayBjb2xsaXNpb25zXG4gICAgICB0aGlzLmNoZWNrQ29sbGlzaW9ucyhlbnRpdHksIHRyYW5zZm9ybSwgcHJvamVjdGlsZSk7XG5cbiAgICAgIC8vIENoZWNrIHdvcmxkIGJvdW5kYXJpZXNcbiAgICAgIHRoaXMuY2hlY2tXb3JsZEJvdW5kcyhlbnRpdHksIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBleHBpcmVkIHByb2plY3RpbGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95KSB7XG4gICAgICB0aGlzLndvcmxkLmRlc3Ryb3lFbnRpdHkoZW50aXR5SWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbW92ZVByb2plY3RpbGUodHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHByb2plY3RpbGU6IFByb2plY3RpbGUsIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVXNlIHRlbXAgdmVjdG9yIHRvIGF2b2lkIGFsbG9jYXRpb25zXG4gICAgdGhpcy50ZW1wVmVjdG9yLmNvcHkocHJvamVjdGlsZS52ZWxvY2l0eSkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgIHRyYW5zZm9ybS50cmFuc2xhdGUodGhpcy50ZW1wVmVjdG9yLngsIHRoaXMudGVtcFZlY3Rvci55LCB0aGlzLnRlbXBWZWN0b3Iueik7XG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSG9taW5nRGlyZWN0aW9uKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTa2lwIGlmIG5vdCBob21pbmdcbiAgICBpZiAoIXByb2plY3RpbGUudGFyZ2V0RW50aXR5SWQgfHwgcHJvamVjdGlsZS5ob21pbmdTdHJlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRhcmdldCBlbnRpdHlcbiAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eShwcm9qZWN0aWxlLnRhcmdldEVudGl0eUlkKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgLy8gVGFyZ2V0IG5vIGxvbmdlciBleGlzdHMsIGRpc2FibGUgaG9taW5nXG4gICAgICBwcm9qZWN0aWxlLmRpc2FibGVIb21pbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICBwcm9qZWN0aWxlLmRpc2FibGVIb21pbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgcHJvamVjdGlsZSBwb3NpdGlvblxuICAgIGNvbnN0IHByb2plY3RpbGVUcmFuc2Zvcm0gPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghcHJvamVjdGlsZVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0b3dlciBwcm9qZWN0aWxlIGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgY29uc3QgaXNUb3dlclByb2plY3RpbGUgPSAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLmlzVG93ZXJQcm9qZWN0aWxlID09PSB0cnVlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpcmVjdGlvbiB0byB0YXJnZXRcbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSBwcm9qZWN0aWxlVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgdGhpcy50ZW1wVmVjdG9yLmNvcHkodGFyZ2V0UG9zaXRpb24pLnN1YihjdXJyZW50UG9zaXRpb24pO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9UYXJnZXQgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG5cbiAgICAvLyBGb3IgdG93ZXIgcHJvamVjdGlsZXMsIHVzZSBtb3JlIGFnZ3Jlc3NpdmUgaG9taW5nIGV2ZW4gYXQgY2xvc2UgcmFuZ2VcbiAgICBjb25zdCBtaW5EaXN0YW5jZVRocmVzaG9sZCA9IGlzVG93ZXJQcm9qZWN0aWxlID8gMC4wNSA6IDAuMTsgLy8gQ2xvc2VyIHRocmVzaG9sZCBmb3IgdG93ZXJzXG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIHRhcmdldCBhbmQgbm90IGEgdG93ZXIgcHJvamVjdGlsZSwgbWFpbnRhaW4gY3VycmVudCBkaXJlY3Rpb25cbiAgICBpZiAoZGlzdGFuY2VUb1RhcmdldCA8IG1pbkRpc3RhbmNlVGhyZXNob2xkICYmICFpc1Rvd2VyUHJvamVjdGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSB0YXJnZXQgZGlyZWN0aW9uXG4gICAgdGhpcy50ZW1wVmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gR2V0IGN1cnJlbnQgdmVsb2NpdHkgZGlyZWN0aW9uXG4gICAgY29uc3QgY3VycmVudERpcmVjdGlvbiA9IHByb2plY3RpbGUudmVsb2NpdHkuY2xvbmUoKS5ub3JtYWxpemUoKTtcblxuICAgIC8vIEZvciB0b3dlciBwcm9qZWN0aWxlcywgdXNlIG1vcmUgZGlyZWN0IGFwcHJvYWNoIHdoZW4gdmVyeSBjbG9zZVxuICAgIGlmIChpc1Rvd2VyUHJvamVjdGlsZSAmJiBkaXN0YW5jZVRvVGFyZ2V0IDwgMC4zKSB7XG4gICAgICAvLyBEaXJlY3QgYXBwcm9hY2g6IGltbWVkaWF0ZWx5IGFkanVzdCB0b3dhcmRzIHRhcmdldFxuICAgICAgY29uc3QgZGVzaXJlZERpcmVjdGlvbiA9IHRoaXMudGVtcFZlY3Rvci5jbG9uZSgpO1xuICAgICAgY29uc3QgYW5nbGUgPSBjdXJyZW50RGlyZWN0aW9uLmFuZ2xlVG8oZGVzaXJlZERpcmVjdGlvbik7XG5cbiAgICAgIC8vIEZvciB0b3dlciBwcm9qZWN0aWxlcywgYWxsb3cgbXVjaCBtb3JlIGFnZ3Jlc3NpdmUgdHVybmluZyB3aGVuIGNsb3NlXG4gICAgICBjb25zdCBtYXhUdXJuVGhpc0ZyYW1lID0gcHJvamVjdGlsZS5tYXhUdXJuUmF0ZSAqIGRlbHRhVGltZSAqIDI7IC8vIERvdWJsZSB0aGUgdHVybiByYXRlIHdoZW4gY2xvc2VcbiAgICAgIGNvbnN0IHR1cm5BbmdsZSA9IE1hdGgubWluKGFuZ2xlLCBtYXhUdXJuVGhpc0ZyYW1lKTtcblxuICAgICAgaWYgKHR1cm5BbmdsZSA+IDAuMDAxKSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uQXhpcyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHJvdGF0aW9uQXhpcy5jcm9zc1ZlY3RvcnMoY3VycmVudERpcmVjdGlvbiwgZGVzaXJlZERpcmVjdGlvbikubm9ybWFsaXplKCk7XG5cbiAgICAgICAgY29uc3QgbmV3RGlyZWN0aW9uID0gY3VycmVudERpcmVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBuZXdEaXJlY3Rpb24uYXBwbHlBeGlzQW5nbGUocm90YXRpb25BeGlzLCB0dXJuQW5nbGUpO1xuXG4gICAgICAgIHByb2plY3RpbGUudmVsb2NpdHkuY29weShuZXdEaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHByb2plY3RpbGUuc3BlZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGFuZGFyZCBob21pbmcgbG9naWMgd2l0aCBlbmhhbmNlZCBzdHJlbmd0aCBmb3IgdG93ZXIgcHJvamVjdGlsZXNcbiAgICAgIGNvbnN0IGhvbWluZ1N0cmVuZ3RoID0gaXNUb3dlclByb2plY3RpbGUgPyBNYXRoLm1pbihwcm9qZWN0aWxlLmhvbWluZ1N0cmVuZ3RoICsgMC4xLCAxLjApIDogcHJvamVjdGlsZS5ob21pbmdTdHJlbmd0aDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlc2lyZWQgZGlyZWN0aW9uIChpbnRlcnBvbGF0ZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIHRhcmdldCBkaXJlY3Rpb24pXG4gICAgICBjb25zdCBkZXNpcmVkRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGRlc2lyZWREaXJlY3Rpb24ubGVycFZlY3RvcnMoY3VycmVudERpcmVjdGlvbiwgdGhpcy50ZW1wVmVjdG9yLCBob21pbmdTdHJlbmd0aCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhbmdsZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGRlc2lyZWQgZGlyZWN0aW9uXG4gICAgICBjb25zdCBhbmdsZSA9IGN1cnJlbnREaXJlY3Rpb24uYW5nbGVUbyhkZXNpcmVkRGlyZWN0aW9uKTtcblxuICAgICAgLy8gTGltaXQgdHVybiByYXRlIChtb3JlIGFnZ3Jlc3NpdmUgZm9yIHRvd2VyIHByb2plY3RpbGVzKVxuICAgICAgY29uc3QgbWF4VHVyblRoaXNGcmFtZSA9IHByb2plY3RpbGUubWF4VHVyblJhdGUgKiBkZWx0YVRpbWU7XG4gICAgICBjb25zdCB0dXJuQW5nbGUgPSBNYXRoLm1pbihhbmdsZSwgbWF4VHVyblRoaXNGcmFtZSk7XG5cbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gdHVyblxuICAgICAgaWYgKHR1cm5BbmdsZSA+IDAuMDAxKSB7IC8vIFNtYWxsIHRocmVzaG9sZCB0byBhdm9pZCBqaXR0ZXJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIGF4aXNcbiAgICAgICAgY29uc3Qgcm90YXRpb25BeGlzID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgcm90YXRpb25BeGlzLmNyb3NzVmVjdG9ycyhjdXJyZW50RGlyZWN0aW9uLCBkZXNpcmVkRGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAvLyBDcmVhdGUgcm90YXRpb24gcXVhdGVybmlvblxuICAgICAgICBjb25zdCBjb3NIYWxmQW5nbGUgPSBNYXRoLmNvcyh0dXJuQW5nbGUgLyAyKTtcbiAgICAgICAgY29uc3Qgc2luSGFsZkFuZ2xlID0gTWF0aC5zaW4odHVybkFuZ2xlIC8gMik7XG5cbiAgICAgICAgLy8gQXBwbHkgcm90YXRpb24gdG8gY3VycmVudCBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgbmV3RGlyZWN0aW9uID0gY3VycmVudERpcmVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBuZXdEaXJlY3Rpb24uYXBwbHlBeGlzQW5nbGUocm90YXRpb25BeGlzLCB0dXJuQW5nbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSB3aGlsZSBtYWludGFpbmluZyBzcGVlZFxuICAgICAgICBwcm9qZWN0aWxlLnZlbG9jaXR5LmNvcHkobmV3RGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihwcm9qZWN0aWxlLnNwZWVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBjaGVja0NvbGxpc2lvbnMocHJvamVjdGlsZUVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSk6IHZvaWQge1xuICAgIGNvbnN0IHByb2plY3RpbGVQb3MgPSB0cmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBTa2lwIGJhcnJhZ2UgYW5kIHZpcGVyIHN0aW5nIHByb2plY3RpbGVzIGluIFBWUCBtb2RlIC0gdGhleSBzaG91bGQgb25seSBiZSBoYW5kbGVkIGJ5IHNwZWNpYWxpemVkIFBWUCBtYW5hZ2Vyc1xuICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIGlmIChyZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzQmFycmFnZUFycm93IHx8IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8ucHJvamVjdGlsZVR5cGUgPT09ICd2aXBlcl9zdGluZycpIHtcbiAgICAgIC8vIEluIFBWUCBtb2RlLCB0aGVzZSBwcm9qZWN0aWxlcyBhcmUgaGFuZGxlZCBieSB0aGUgc3BlY2lhbGl6ZWQgUFZQIG1hbmFnZXJzXG4gICAgICAvLyBTa2lwIEVDUyBjb2xsaXNpb24gZGV0ZWN0aW9uIHRvIHByZXZlbnQgZHVwbGljYXRlIGRhbWFnZSBhbmQgc2VsZi10YXJnZXRpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIHRoYXQgY291bGQgYmUgaGl0IC0gc3BlY2lmaWNhbGx5IGxvb2sgZm9yIGVuZW1pZXMgd2l0aCBjb2xsaWRlcnNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcblxuICAgIC8vIEVhcmx5IGV4aXQgaWYgbm8gdGFyZ2V0c1xuICAgIGlmIChwb3RlbnRpYWxUYXJnZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgLy8gU2tpcCBzZWxmIGFuZCBvd25lclxuICAgICAgaWYgKHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZUVudGl0eS5pZCB8fCB0YXJnZXQuaWQgPT09IHByb2plY3RpbGUub3duZXIpIHtcbiAgICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3Igb3duZXIgY29sbGlzaW9uIHByZXZlbnRpb25cbiAgICAgICAgaWYgKHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5qrIFByb2plY3RpbGUgJHtwcm9qZWN0aWxlRW50aXR5LmlkfSBza2lwcGluZyBvd25lciAke3Byb2plY3RpbGUub3duZXJ9ICh0YXJnZXQgJHt0YXJnZXQuaWR9KWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGlmIGFscmVhZHkgaGl0IGFuZCBub3QgcGllcmNpbmdcbiAgICAgIGlmICghcHJvamVjdGlsZS5jYW5IaXRUYXJnZXQodGFyZ2V0LmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKSE7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBpZiB0YXJnZXQgaXMgZGVhZFxuICAgICAgaWYgKHRhcmdldEhlYWx0aC5pc0RlYWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb2plY3RpbGUgY2FuIGhpdCB0aGlzIHRhcmdldCAobGF5ZXItYmFzZWQgY29sbGlzaW9uKVxuICAgICAgLy8gSW4gUFZQIG1vZGUsIHByb2plY3RpbGVzIGNhbiBoaXQgYm90aCBFTkVNWSAocmVtb3RlIHBsYXllcnMpIGFuZCBQTEFZRVIgKGxvY2FsIHBsYXllcikgbGF5ZXJzXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLkVORU1ZICYmIHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5QTEFZRVIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrOiBwcmV2ZW50IHByb2plY3RpbGVzIGZyb20gaGl0dGluZyB0aGVpciBvd25lciBpbiBQVlAgbW9kZVxuICAgICAgLy8gVGhpcyBpcyBhIGJhY2t1cCBjaGVjayBpbiBjYXNlIHRoZSBvd25lciBjb21wYXJpc29uIGFib3ZlIGZhaWxzXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLlBMQVlFUiAmJiB0YXJnZXQuaWQgPT09IHByb2plY3RpbGUub3duZXIpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+aqyBFeHRyYSBzYWZldHk6IFByb2plY3RpbGUgJHtwcm9qZWN0aWxlRW50aXR5LmlkfSBwcmV2ZW50ZWQgZnJvbSBoaXR0aW5nIG93bmVyICR7cHJvamVjdGlsZS5vd25lcn0gKFBWUCBtb2RlKWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ1JJVElDQUwgUFZQIEZJWDogUHJldmVudCBWaXBlciBTdGluZyBwcm9qZWN0aWxlcyBmcm9tIGhpdHRpbmcgdGhlIGxvY2FsIHBsYXllclxuICAgICAgLy8gSW4gUFZQLCBWaXBlciBTdGluZyBwcm9qZWN0aWxlcyBmcm9tIHJlbW90ZSBwbGF5ZXJzIHNob3VsZCBub3QgZGFtYWdlIHRoZSBsb2NhbCBwbGF5ZXJcbiAgICAgIC8vIFRoZSBsb2NhbCBwbGF5ZXIgYWx3YXlzIGhhcyBDb2xsaXNpb25MYXllci5QTEFZRVIsIHdoaWxlIHJlbW90ZSBwbGF5ZXJzIGhhdmUgQ29sbGlzaW9uTGF5ZXIuRU5FTVlcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSICYmIHByb2plY3RpbGUucHJvamVjdGlsZVR5cGUgPT09ICd2aXBlcl9zdGluZycpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIFZpcGVyIFN0aW5nIHByb2plY3RpbGUgaGl0dGluZyB0aGUgbG9jYWwgcGxheWVyIC0gc2tpcCBpdFxuICAgICAgICAvLyBUaGUgT3B0aW1pemVkUFZQVmlwZXJTdGluZ01hbmFnZXIgd2lsbCBoYW5kbGUgUFZQIGRhbWFnZSBzZXBhcmF0ZWx5XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRQb3MgPSB0YXJnZXRUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuXG4gICAgICAvLyBVc2UgY29sbGlkZXIgcmFkaXVzIGZvciBtb3JlIGFjY3VyYXRlIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgIGNvbnN0IHByb2plY3RpbGVSYWRpdXMgPSAwLjI7IC8vIEluY3JlYXNlZCBmcm9tIDAuMSBmb3IgbW9yZSBmb3JnaXZpbmcgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgY29uc3QgdGFyZ2V0UmFkaXVzID0gdGFyZ2V0Q29sbGlkZXIucmFkaXVzO1xuXG4gICAgICAvLyBVc2Ugc3F1YXJlZCBkaXN0YW5jZSBmb3IgcGVyZm9ybWFuY2UgKGF2b2lkIHNxcnQpXG4gICAgICBjb25zdCBkaXN0YW5jZVNxdWFyZWQgPSBwcm9qZWN0aWxlUG9zLmRpc3RhbmNlVG9TcXVhcmVkKHRhcmdldFBvcyk7XG4gICAgICBjb25zdCBjb2xsaXNpb25SYWRpdXNTcXVhcmVkID0gKHByb2plY3RpbGVSYWRpdXMgKyB0YXJnZXRSYWRpdXMpICoqIDI7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZVNxdWFyZWQgPD0gY29sbGlzaW9uUmFkaXVzU3F1YXJlZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUhpdChwcm9qZWN0aWxlRW50aXR5LCB0YXJnZXQsIHByb2plY3RpbGUsIHRhcmdldEhlYWx0aCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBub3QgcGllcmNpbmcsIGRlc3Ryb3kgcHJvamVjdGlsZVxuICAgICAgICBpZiAoIXByb2plY3RpbGUucGllcmNpbmcpIHtcbiAgICAgICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2gocHJvamVjdGlsZUVudGl0eS5pZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUhpdChcbiAgICBwcm9qZWN0aWxlRW50aXR5OiBFbnRpdHksIFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBcbiAgICB0YXJnZXRIZWFsdGg6IEhlYWx0aFxuICApOiB2b2lkIHtcbiAgICAvLyBNYXJrIHRhcmdldCBhcyBoaXRcbiAgICBwcm9qZWN0aWxlLmFkZEhpdFRhcmdldCh0YXJnZXQuaWQpO1xuXG4gICAgLy8gRGVhbCBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGRpcmVjdGx5XG4gICAgaWYgKHRoaXMuY29tYmF0U3lzdGVtKSB7XG4gICAgICAvLyBDaGVjayBwcm9qZWN0aWxlIHR5cGUgZm9yIHNwZWNpYWwgZGFtYWdlIGhhbmRsaW5nXG4gICAgICBjb25zdCByZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICAgIGNvbnN0IGlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNDcm9zc2VudHJvcHlCb2x0O1xuICAgICAgY29uc3QgaXNFbnRyb3BpY0JvbHQgPSByZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzRW50cm9waWNCb2x0O1xuICAgICAgXG4gICAgICBsZXQgZGFtYWdlVHlwZSA9ICdwcm9qZWN0aWxlJztcbiAgICAgIGlmIChpc0Nyb3NzZW50cm9weUJvbHQpIHtcbiAgICAgICAgZGFtYWdlVHlwZSA9ICdjcm9zc2VudHJvcHknO1xuICAgICAgfSBlbHNlIGlmIChpc0VudHJvcGljQm9sdCkge1xuICAgICAgICBkYW1hZ2VUeXBlID0gJ2VudHJvcGljJztcbiAgICAgIH1cbiAgICAgIFxuXG4gICAgICBcbiAgICAgIHRoaXMuY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgcHJvamVjdGlsZS5kYW1hZ2UsIHByb2plY3RpbGVFbnRpdHksIGRhbWFnZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgZGFtYWdlIChwYXNzIGVudGl0eSBmb3Igc2hpZWxkIGFic29ycHRpb24pXG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgY29uc3QgZGFtYWdlRGVhbHQgPSB0YXJnZXRIZWFsdGgudGFrZURhbWFnZShwcm9qZWN0aWxlLmRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICBcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZXhwbG9zaW9uIGlmIGV4cGxvc2l2ZVxuICAgIGlmIChwcm9qZWN0aWxlLmV4cGxvc2lvblJhZGl1cyA+IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhwbG9zaW9uKHByb2plY3RpbGVFbnRpdHksIHByb2plY3RpbGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRXhwbG9zaW9uKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSk6IHZvaWQge1xuICAgIGNvbnN0IHByb2plY3RpbGVUcmFuc2Zvcm0gPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICBjb25zdCBleHBsb3Npb25DZW50ZXIgPSBwcm9qZWN0aWxlVHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgLy8gRW1pdCBleHBsb3Npb24gZXZlbnQgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgdGhpcy53b3JsZC5lbWl0RXZlbnQoJ2V4cGxvc2lvbicsIHtcbiAgICAgIHBvc2l0aW9uOiBleHBsb3Npb25DZW50ZXIuY2xvbmUoKSxcbiAgICAgIGNvbG9yOiBuZXcgQ29sb3IoJyMwMGZmNDQnKSxcbiAgICAgIHNpemU6IHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzLFxuICAgICAgZHVyYXRpb246IDAuNVxuICAgIH0pO1xuXG4gICAgLy8gRmluZCBhbGwgZW50aXRpZXMgd2l0aGluIGV4cGxvc2lvbiByYWRpdXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aF0pO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgaWYgKHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikgY29udGludWU7IC8vIERvbid0IGRhbWFnZSBvd25lclxuXG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gZXhwbG9zaW9uQ2VudGVyLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDw9IHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkYW1hZ2UgZmFsbG9mZiBiYXNlZCBvbiBkaXN0YW5jZVxuICAgICAgICBjb25zdCBkYW1hZ2VGYWxsb2ZmID0gMSAtIChkaXN0YW5jZSAvIHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICAgICAgY29uc3QgZXhwbG9zaW9uRGFtYWdlID0gTWF0aC5mbG9vcihwcm9qZWN0aWxlLmRhbWFnZSAqIGRhbWFnZUZhbGxvZmYpO1xuXG4gICAgICAgIGlmIChleHBsb3Npb25EYW1hZ2UgPiAwKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICB0YXJnZXRIZWFsdGgudGFrZURhbWFnZShleHBsb3Npb25EYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1dvcmxkQm91bmRzKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IHBvcyA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBtYXhEaXN0YW5jZSA9IDQwOyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luXG4gICAgY29uc3QgbWF4RGlzdGFuY2VTcXVhcmVkID0gbWF4RGlzdGFuY2UgKiBtYXhEaXN0YW5jZTtcblxuICAgIC8vIENoZWNrIGlmIHByb2plY3RpbGUgaXMgdG9vIGZhciBmcm9tIG9yaWdpbiAodXNpbmcgc3F1YXJlZCBkaXN0YW5jZSlcbiAgICBpZiAocG9zLmxlbmd0aFNxKCkgPiBtYXhEaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgICAgcmV0dXJuOyAvLyBFYXJseSBleGl0XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyBiZWxvdyBncm91bmQgKHNpbXBsZSBncm91bmQgY2hlY2spXG4gICAgaWYgKHBvcy55IDwgLTEwKSB7XG4gICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2goZW50aXR5LmlkKTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYSBDaGFyZ2VkQXJyb3cgcHJvamVjdGlsZSBmb3IgZnVsbHkgY2hhcmdlZCBib3dcbiAgcHVibGljIGNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggY2hhcmdlZCBhcnJvdy1zcGVjaWZpYyBzZXR0aW5nc1xuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMzU7IC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCAyNTsgLy8gSGlnaGVyIGRhbWFnZSB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgNTsgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgQ2hhcmdlZEFycm93XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA4LCA4KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZTogJyNmZmFhMDAnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDMsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuMSAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgQ2hhcmdlZEFycm93IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ2hhcmdlZEFycm93ID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnN1YmNsYXNzID0gY29uZmlnPy5zdWJjbGFzcztcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEubGV2ZWwgPSBjb25maWc/LmxldmVsO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5vcGFjaXR5ID0gY29uZmlnPy5vcGFjaXR5IHx8IDEuMDtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIC8vIEFkZCBDb2xsaWRlciBjb21wb25lbnRcbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIucmFkaXVzID0gMC4xNTtcbiAgICBjb2xsaWRlci5sYXllciA9IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuXG4gICAgcmV0dXJuIHByb2plY3RpbGVFbnRpdHk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYSBDcm9zc2VudHJvcHlCb2x0IHByb2plY3RpbGUgZm9yIHNjeXRoZVxuICBwdWJsaWMgY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggc2N5dGhlLXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gU2xvd2VyIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCAzMDsgLy8gSGlnaGVyIGRhbWFnZSB0aGFuIGFycm93c1xuICAgIHByb2plY3RpbGUubWF4TGlmZXRpbWUgPSBjb25maWc/LmxpZmV0aW1lIHx8IDEuNzU7IC8vIExvbmdlciBsaWZldGltZVxuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgXG4gICAgaWYgKGNvbmZpZz8ucGllcmNpbmcpIHByb2plY3RpbGUuc2V0UGllcmNpbmcodHJ1ZSk7XG4gICAgaWYgKGNvbmZpZz8uZXhwbG9zaXZlICYmIGNvbmZpZz8uZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldEV4cGxvc2l2ZShjb25maWcuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocHJvamVjdGlsZSk7XG5cbiAgICAvLyBBZGQgUmVuZGVyZXIgY29tcG9uZW50IC0gd2UnbGwgdXNlIGEgc3BlY2lhbCBtYXJrZXIgZm9yIENyb3NzZW50cm9weUJvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMjgsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMCxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMCAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgQ3Jvc3NlbnRyb3B5Qm9sdCBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc0Nyb3NzZW50cm9weUJvbHQgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlRW50aXR5ID0gcHJvamVjdGlsZUVudGl0eTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIFxuICAgIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgdGhlIGVudGl0eSBpcyByZWFkeVxuICAgIHRoaXMud29ybGQubm90aWZ5RW50aXR5QWRkZWQocHJvamVjdGlsZUVudGl0eSk7XG4gICAgXG4gICAgcmV0dXJuIHByb2plY3RpbGVFbnRpdHk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYW4gRW50cm9waWNCb2x0IHByb2plY3RpbGUgZm9yIHNjeXRoZSBsZWZ0IGNsaWNrXG4gIHB1YmxpYyBjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKFxuICAgIHdvcmxkOiBXb3JsZCxcbiAgICBwb3NpdGlvbjogVmVjdG9yMyxcbiAgICBkaXJlY3Rpb246IFZlY3RvcjMsXG4gICAgb3duZXJJZDogbnVtYmVyLFxuICAgIGNvbmZpZz86IHtcbiAgICAgIHNwZWVkPzogbnVtYmVyO1xuICAgICAgZGFtYWdlPzogbnVtYmVyO1xuICAgICAgbGlmZXRpbWU/OiBudW1iZXI7XG4gICAgICBwaWVyY2luZz86IGJvb2xlYW47XG4gICAgICBleHBsb3NpdmU/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaW9uUmFkaXVzPzogbnVtYmVyO1xuICAgICAgc3ViY2xhc3M/OiBXZWFwb25TdWJjbGFzcztcbiAgICAgIGxldmVsPzogbnVtYmVyO1xuICAgICAgb3BhY2l0eT86IG51bWJlcjtcbiAgICAgIHNvdXJjZVBsYXllcklkPzogc3RyaW5nO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggRW50cm9waWNCb2x0LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgMjA7IC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fDEuNzU7IC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNvdXJjZVBsYXllcklkID0gY29uZmlnPy5zb3VyY2VQbGF5ZXJJZCB8fCAndW5rbm93bic7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgRW50cm9waWNCb2x0XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA2LCA2KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZTogJyMwMGZmNDQnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDAsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAgLy8gVmVyeSBsb3cgb3BhY2l0eSBzaW5jZSBSZWFjdCBjb21wb25lbnQgd2lsbCBoYW5kbGUgdmlzdWFsc1xuICAgIH0pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWVzaCA9IG5ldyBNZXNoKHBsYWNlaG9sZGVyR2VvbWV0cnksIHBsYWNlaG9sZGVyTWF0ZXJpYWwpO1xuICAgIFxuICAgIC8vIE1hcmsgdGhpcyBhcyBhbiBFbnRyb3BpY0JvbHQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNFbnRyb3BpY0JvbHQgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlRW50aXR5ID0gcHJvamVjdGlsZUVudGl0eTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIHByb2plY3RpbGVcbiAgcHVibGljIGNyZWF0ZVByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgICAgbWF4RGlzdGFuY2U/OiBudW1iZXI7XG4gICAgICBwcm9qZWN0aWxlVHlwZT86IHN0cmluZzsgLy8gQWRkIHByb2plY3RpbGUgdHlwZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgc291cmNlUGxheWVySWQ/OiBzdHJpbmc7IC8vIEFkZCBzb3VyY2UgcGxheWVyIElEIGZvciBtdWx0aXBsYXllciB0ZWFtIHZhbGlkYXRpb25cbiAgICB9XG4gICk6IEVudGl0eSB7XG4gICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHdvcmxkLmNyZWF0ZUVudGl0eSgpO1xuXG4gICAgLy8gQWRkIFRyYW5zZm9ybSBjb21wb25lbnRcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBQcm9qZWN0aWxlIGNvbXBvbmVudFxuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMjA7XG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCA1OyAvLyBTZXQgZGVmYXVsdCBkYW1hZ2UgdG8gNSBhcyByZXF1ZXN0ZWRcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCAyO1xuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc291cmNlUGxheWVySWQgPSBjb25maWc/LnNvdXJjZVBsYXllcklkIHx8ICd1bmtub3duJztcbiAgICBwcm9qZWN0aWxlLnByb2plY3RpbGVUeXBlID0gY29uZmlnPy5wcm9qZWN0aWxlVHlwZSB8fCAnZ2VuZXJpYyc7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBwcm9qZWN0aWxlLnNldFN0YXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIFxuICAgIC8vIFNldCBtYXggZGlzdGFuY2UgaWYgc3BlY2lmaWVkIChmb3IgYm93IGFycm93cylcbiAgICBpZiAoY29uZmlnPy5tYXhEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldE1heERpc3RhbmNlKGNvbmZpZy5tYXhEaXN0YW5jZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBSZWd1bGFyQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBSZWd1bGFyQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmcgKHdpbGwgYmUgb3ZlcnJpZGRlbiBieSBUb3dlclN5c3RlbSBpZiBpdCdzIGEgdG93ZXIgcHJvamVjdGlsZSlcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNSZWd1bGFyQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlVHlwZSA9IGNvbmZpZz8ucHJvamVjdGlsZVR5cGU7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpOyAvLyBQcm9qZWN0aWxlcyBkb24ndCBuZWVkIHRvIGNhc3Qgc2hhZG93c1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIC8vIEFkZCBDb2xsaWRlciBjb21wb25lbnRcbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIucmFkaXVzID0gMC4xNTtcbiAgICBjb2xsaWRlci5sYXllciA9IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuICAgIFxuICAgIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgdGhlIGVudGl0eSBpcyByZWFkeSAodGhpcyB3aWxsIHRyaWdnZXIgUmVuZGVyU3lzdGVtLm9uRW50aXR5QWRkZWQpXG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG5cblxuICAvLyBHZXQgcG9vbCBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldFBvb2xTdGF0cygpOiB7IFxuICAgIHZlY3RvcjM6IG51bWJlcjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlY3RvcjM6IHRoaXMudmVjdG9yM1Bvb2wuZ2V0UG9vbFNpemUoKVxuICAgIH07XG4gIH1cblxuICAvLyBEaXNwb3NlIG9mIGFsbCBwb29scyB3aGVuIHN5c3RlbSBpcyBkZXN0cm95ZWRcbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLnZlY3RvcjNQb29sLmNsZWFyKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJTcGhlcmVHZW9tZXRyeSIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiTWVzaCIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIlByb2plY3RpbGUiLCJIZWFsdGgiLCJSZW5kZXJlciIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJPYmplY3RQb29sIiwiUHJvamVjdGlsZVN5c3RlbSIsInNldENvbWJhdFN5c3RlbSIsImNvbWJhdFN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicHJvamVjdGlsZXNUb0Rlc3Ryb3kiLCJsZW5ndGgiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJwcm9qZWN0aWxlIiwiZW5hYmxlZCIsImlzRXhwaXJlZCIsInB1c2giLCJpZCIsIm1vdmVQcm9qZWN0aWxlIiwidXBkYXRlSG9taW5nRGlyZWN0aW9uIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tXb3JsZEJvdW5kcyIsImVudGl0eUlkIiwid29ybGQiLCJkZXN0cm95RW50aXR5IiwidGVtcFZlY3RvciIsImNvcHkiLCJ2ZWxvY2l0eSIsIm11bHRpcGx5U2NhbGFyIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwibWF0cml4TmVlZHNVcGRhdGUiLCJwcm9qZWN0aWxlRW50aXR5IiwidGFyZ2V0RW50aXR5SWQiLCJob21pbmdTdHJlbmd0aCIsInRhcmdldEVudGl0eSIsImdldEVudGl0eSIsImRpc2FibGVIb21pbmciLCJ0YXJnZXRUcmFuc2Zvcm0iLCJwcm9qZWN0aWxlVHJhbnNmb3JtIiwiaXNUb3dlclByb2plY3RpbGUiLCJjdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwic3ViIiwiZGlzdGFuY2VUb1RhcmdldCIsIm1pbkRpc3RhbmNlVGhyZXNob2xkIiwibm9ybWFsaXplIiwiY3VycmVudERpcmVjdGlvbiIsImNsb25lIiwiZGVzaXJlZERpcmVjdGlvbiIsImFuZ2xlIiwiYW5nbGVUbyIsIm1heFR1cm5UaGlzRnJhbWUiLCJtYXhUdXJuUmF0ZSIsInR1cm5BbmdsZSIsIk1hdGgiLCJtaW4iLCJyb3RhdGlvbkF4aXMiLCJjcm9zc1ZlY3RvcnMiLCJuZXdEaXJlY3Rpb24iLCJhcHBseUF4aXNBbmdsZSIsInNwZWVkIiwibGVycFZlY3RvcnMiLCJjb3NIYWxmQW5nbGUiLCJjb3MiLCJzaW5IYWxmQW5nbGUiLCJzaW4iLCJyZW5kZXJlciIsInByb2plY3RpbGVQb3MiLCJtZXNoIiwidXNlckRhdGEiLCJpc0JhcnJhZ2VBcnJvdyIsInByb2plY3RpbGVUeXBlIiwicG90ZW50aWFsVGFyZ2V0cyIsInF1ZXJ5RW50aXRpZXMiLCJ0YXJnZXQiLCJvd25lciIsImNhbkhpdFRhcmdldCIsInRhcmdldEhlYWx0aCIsInRhcmdldENvbGxpZGVyIiwiaXNEZWFkIiwibGF5ZXIiLCJFTkVNWSIsIlBMQVlFUiIsInRhcmdldFBvcyIsImdldFdvcmxkUG9zaXRpb24iLCJwcm9qZWN0aWxlUmFkaXVzIiwidGFyZ2V0UmFkaXVzIiwicmFkaXVzIiwiZGlzdGFuY2VTcXVhcmVkIiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJjb2xsaXNpb25SYWRpdXNTcXVhcmVkIiwiaGFuZGxlSGl0IiwicGllcmNpbmciLCJhZGRIaXRUYXJnZXQiLCJpc0Nyb3NzZW50cm9weUJvbHQiLCJpc0VudHJvcGljQm9sdCIsImRhbWFnZVR5cGUiLCJxdWV1ZURhbWFnZSIsImRhbWFnZSIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsImV4cGxvc2lvblJhZGl1cyIsImhhbmRsZUV4cGxvc2lvbiIsImV4cGxvc2lvbkNlbnRlciIsImVtaXRFdmVudCIsImNvbG9yIiwic2l6ZSIsImR1cmF0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZGFtYWdlRmFsbG9mZiIsImV4cGxvc2lvbkRhbWFnZSIsImZsb29yIiwicG9zIiwibWF4RGlzdGFuY2UiLCJtYXhEaXN0YW5jZVNxdWFyZWQiLCJsZW5ndGhTcSIsImNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUiLCJkaXJlY3Rpb24iLCJvd25lcklkIiwiY29uZmlnIiwiY3JlYXRlRW50aXR5IiwiY3JlYXRlQ29tcG9uZW50IiwiYWRkQ29tcG9uZW50IiwibWF4TGlmZXRpbWUiLCJsaWZldGltZSIsInNldERpcmVjdGlvbiIsInNldFBpZXJjaW5nIiwiZXhwbG9zaXZlIiwic2V0RXhwbG9zaXZlIiwicGxhY2Vob2xkZXJHZW9tZXRyeSIsInBsYWNlaG9sZGVyTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwicGxhY2Vob2xkZXJNZXNoIiwiaXNDaGFyZ2VkQXJyb3ciLCJzdWJjbGFzcyIsImxldmVsIiwiY29sbGlkZXIiLCJQUk9KRUNUSUxFIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJzZXRDYXN0U2hhZG93Iiwibm90aWZ5RW50aXR5QWRkZWQiLCJjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlIiwic291cmNlUGxheWVySWQiLCJjcmVhdGVQcm9qZWN0aWxlIiwic2V0U3RhcnRQb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldE1heERpc3RhbmNlIiwiaXNSZWd1bGFyQXJyb3ciLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n            // console.warn(' Renderer component missing updateAnimations method:', rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n            // console.warn(' Renderer component missing updateMesh method:', rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            // console.log(` RenderSystem: Adding entity ${entity.id} to scene`);\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                // console.log(` Adding pre-built mesh/group for entity ${entity.id}`);\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                // console.log(` Creating mesh from geometry + material for entity ${entity.id}`);\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n            // console.log(` Entity ${entity.id} has Renderer but no geometry/material - skipping mesh creation`);\n            }\n        } else {\n        // console.log(` RenderSystem: Entity ${entity.id} has no Renderer component`);\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87WUFDTCw2RkFBNkY7WUFDL0Y7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ04sUUFBUUMsV0FBV0U7UUFDM0M7SUFDRjtJQUVPSSxPQUFPVCxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDBDQUEwQztRQUMxQyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLElBQUksQ0FBQ0kscUJBQXFCLENBQUNSLFFBQVFDLFdBQVdFO1FBQ2hEO1FBRUEsbUJBQW1CO1FBQ25CLElBQUksQ0FBQ00sUUFBUSxDQUFDRixNQUFNLENBQUMsSUFBSSxDQUFD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Q0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUMrRCxRQUFRLEdBQUcsTUFBTSxpQ0FBaUM7SUFDekQ7QUFxTUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUmVuZGVyU3lzdGVtLnRzP2IzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVuZGVyIHN5c3RlbSBmb3IgM0QgcmVuZGVyaW5nIHdpdGggVGhyZWUuanNcbmltcG9ydCB7IFNjZW5lLCBDYW1lcmEsIFdlYkdMUmVuZGVyZXIsIE1lc2gsIEdyb3VwLCBMaWdodCwgT2JqZWN0M0QsIENvbG9yLCBUZXh0dXJlLCBQQ0ZTb2Z0U2hhZG93TWFwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgRm9nLCBGb2dFeHAyLCBDdWJlVGV4dHVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gYXMgQmFzZVJlbmRlclN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcblxuZXhwb3J0IGNsYXNzIFJlbmRlclN5c3RlbSBleHRlbmRzIEJhc2VSZW5kZXJTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgUmVuZGVyZXJdO1xuICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcbiAgcHJpdmF0ZSBjYW1lcmE6IENhbWVyYTtcbiAgcHJpdmF0ZSByZW5kZXJlcjogV2ViR0xSZW5kZXJlcjtcbiAgcHJpdmF0ZSBtZXNoTWFwID0gbmV3IE1hcDxudW1iZXIsIE1lc2ggfCBHcm91cD4oKTsgLy8gRW50aXR5IElEIC0+IE1lc2gvR3JvdXAgbWFwcGluZ1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEsIHJlbmRlcmVyOiBXZWJHTFJlbmRlcmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxMDAwOyAvLyBSZW5kZXIgc3lzdGVtcyBzaG91bGQgcnVuIGxhc3RcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIGFuZCByZW5kZXJlciBjb21wb25lbnRzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbnMgd2l0aCBzYWZldHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZW5kZXJlckNvbXBvbmVudC51cGRhdGVBbmltYXRpb25zKGRlbHRhVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVBbmltYXRpb25zIG1ldGhvZDonLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBtZXNoIGlmIG5lZWRlZFxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlNZXNoKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGFsbCBlbnRpdHkgdHJhbnNmb3JtcyBhbmQgbWVzaGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlUcmFuc2Zvcm0oZW50aXR5LCB0cmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVFbnRpdHlNZXNoKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgZXhpc3RpbmdNZXNoID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuXG4gICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cylcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChyZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbWVzaCBpZiBpdCBkb2Vzbid0IGV4aXN0IG9yIG5lZWRzIHVwZGF0ZSAodHJhZGl0aW9uYWwgZ2VvbWV0cnkgKyBtYXRlcmlhbClcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgIGlmIChtZXNoKSB7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ01lc2gpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBtZXNoIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlTWVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlTWVzaCBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgbWVzaE9yR3JvdXAgPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKCFtZXNoT3JHcm91cCkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICB0cmFuc2Zvcm0udXBkYXRlTWF0cml4KCk7XG5cbiAgICAvLyBBcHBseSB0cmFuc2Zvcm0gdG8gbWVzaCBvciBncm91cFxuICAgIG1lc2hPckdyb3VwLnBvc2l0aW9uLmNvcHkodHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICBtZXNoT3JHcm91cC5xdWF0ZXJuaW9uLmNvcHkodHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuICAgIG1lc2hPckdyb3VwLnNjYWxlLmNvcHkodHJhbnNmb3JtLnNjYWxlKTtcblxuICAgIC8vIEhhbmRsZSBpbnN0YW5jZWQgcmVuZGVyaW5nIChvbmx5IGZvciBtZXNoZXMpXG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50LmlzSW5zdGFuY2VkICYmIG1lc2hPckdyb3VwIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlSW5zdGFuY2VNYXRyaXgodHJhbnNmb3JtLm1hdHJpeCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5QWRkZWQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYPCfjqggUmVuZGVyU3lzdGVtOiBBZGRpbmcgZW50aXR5ICR7ZW50aXR5LmlkfSB0byBzY2VuZWApO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcHJlLWJ1aWx0IG1lc2gvZ3JvdXAgKGxpa2UgYXJyb3dzIGFuZCBlbGl0ZSBlbmVtaWVzKVxuICAgICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYPCfj7kgQWRkaW5nIHByZS1idWlsdCBtZXNoL2dyb3VwIGZvciBlbnRpdHkgJHtlbnRpdHkuaWR9YCk7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCByZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWxcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+UtyBDcmVhdGluZyBtZXNoIGZyb20gZ2VvbWV0cnkgKyBtYXRlcmlhbCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICBjb25zdCBtZXNoID0gcmVuZGVyZXJDb21wb25lbnQuY3JlYXRlTWVzaCgpO1xuICAgICAgICBpZiAobWVzaCkge1xuICAgICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgICB0aGlzLnNjZW5lLmFkZChtZXNoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYOKaqiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBSZW5kZXJlciBidXQgbm8gZ2VvbWV0cnkvbWF0ZXJpYWwgLSBza2lwcGluZyBtZXNoIGNyZWF0aW9uYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDimqDvuI8gUmVuZGVyU3lzdGVtOiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBubyBSZW5kZXJlciBjb21wb25lbnRgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25FbnRpdHlSZW1vdmVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcbiAgICBpZiAobWVzaCkge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUobWVzaCk7XG4gICAgICB0aGlzLm1lc2hNYXAuZGVsZXRlKGVudGl0eS5pZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQgJiYgdHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0TWVzaChlbnRpdHlJZDogbnVtYmVyKTogTWVzaCB8IEdyb3VwIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tZXNoTWFwLmdldChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2NlbmUoKTogU2NlbmUge1xuICAgIHJldHVybiB0aGlzLnNjZW5lO1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYSgpOiBDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZW5kZXJlcigpOiBXZWJHTFJlbmRlcmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgbWFuYWdpbmcgdGhlIHNjZW5lXG4gIHB1YmxpYyBhZGRMaWdodChsaWdodDogTGlnaHQpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5yZW1vdmUobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIGFkZE9iamVjdChvYmplY3Q6IE9iamVjdDNEKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0KTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgc2V0Rm9nKGZvZzogRm9nIHwgRm9nRXhwMiB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmZvZyA9IGZvZztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCYWNrZ3JvdW5kKGJhY2tncm91bmQ6IENvbG9yIHwgVGV4dHVyZSB8IEN1YmVUZXh0dXJlIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gIH1cblxuICBwdWJsaWMgZW5hYmxlU2hhZG93cyhlbmFibGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGVuYWJsZTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gUENGU29mdFNoYWRvd01hcDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQaXhlbFJhdGlvKHJhdGlvPzogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHJhdGlvIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIGlmICh0aGlzLmNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBhbGwgbWVzaGVzXG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIG1lc2hdIG9mIEFycmF5LmZyb20odGhpcy5tZXNoTWFwLmVudHJpZXMoKSkpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgIH1cbiAgICB0aGlzLm1lc2hNYXAuY2xlYXIoKTtcblxuICAgIC8vIERpc3Bvc2UgcmVuZGVyZXJcbiAgICB0aGlzLnJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJSZW5kZXJTeXN0ZW0iLCJCYXNlUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiUmVuZGVyZXIiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInJlbmRlcmVyQ29tcG9uZW50IiwiZW5hYmxlZCIsInVwZGF0ZUFuaW1hdGlvbnMiLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.Collider\n        ]);\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.CollisionLayer.ENEMY) {\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            return false;\n        }\n        // Check if this is a summoned unit\n        const summonedUnit = target.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n        if (summonedUnit) {\n            // Don't target dead or inactive summoned units\n            if (summonedUnit.isDead || !summonedUnit.isActive) {\n                return false;\n            }\n            // Only target enemy summoned units (different owner)\n            return summonedUnit.ownerId !== tower.ownerId;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                // If this is the local player and they are invisible (stealthed), don't target them\n                if (shouldTarget && this.localSocketId) {\n                    var _window_controlSystemRef;\n                    // Check if local player is invisible through a global reference\n                    const controlSystem = (_window_controlSystemRef = window.controlSystemRef) === null || _window_controlSystemRef === void 0 ? void 0 : _window_controlSystemRef.current;\n                    if (controlSystem && controlSystem.isPlayerInvisible && controlSystem.isPlayerInvisible()) {\n                        return false; // Don't target invisible local player\n                    }\n                }\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_8__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    // Check if the target player is invisible (stealthed)\n                    if (shouldTarget && this.playerStealthStates.get(targetPlayerId)) {\n                        return false; // Don't target invisible remote players\n                    }\n                    return shouldTarget;\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        // Double-check target validity before attacking\n        if (!this.isValidTarget(targetEntity, towerTransform, tower)) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Calculate direction from spawn position to target (not tower base)\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(this.tempVector2);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Special handling for very close targets - ensure we can always hit them\n        if (distance < 0.5) {\n            // For extremely close targets, create a more predictable trajectory\n            // Aim slightly above the target to account for gravity and ensure hit\n            this.tempVector.copy(targetTransform.position);\n            this.tempVector.y += 0.3; // Aim 0.3 units above target\n            this.tempVector.sub(this.tempVector2);\n            this.tempVector.normalize();\n        } else {\n            // Normalize direction for normal cases\n            this.tempVector.normalize();\n        }\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 2,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Enable extremely strong homing for tower projectiles\n            const projectile = projectileEntity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__.Projectile);\n            if (projectile && tower.currentTarget) {\n                // Check if target is a summoned unit for special handling\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                const isSummonedUnit = (targetEntity === null || targetEntity === void 0 ? void 0 : targetEntity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit)) !== undefined;\n                if (isSummonedUnit) {\n                    // Make it IMPOSSIBLE for summoned units to dodge - perfect tracking\n                    projectile.setHoming(tower.currentTarget, 1.0, 8.0);\n                } else {\n                    // For players: very difficult to dodge but not impossible\n                    projectile.setHoming(tower.currentTarget, 0.95, 6.0);\n                }\n                // Add special tower projectile properties for enhanced tracking\n                projectile.maxTurnRate = isSummonedUnit ? 12.0 : 8.0; // Even faster turns for summoned units\n            }\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_7__.Renderer);\n            if (projectileRenderer && projectileRenderer.mesh) {\n                // Add metadata to identify this as a tower projectile\n                projectileRenderer.mesh.userData.isTowerProjectile = true;\n                projectileRenderer.mesh.userData.towerOwnerId = tower.ownerId;\n                projectileRenderer.mesh.userData.isRegularArrow = false; // Override regular arrow flag\n                projectileRenderer.mesh.userData.direction = this.tempVector.clone();\n                projectileRenderer.mesh.userData.opacity = 1.0;\n            }\n            // Also mark the entity itself for ProjectileSystem detection\n            projectileEntity.isTowerProjectile = true;\n            projectileEntity.towerOwnerId = tower.ownerId;\n            // CRITICAL: Set source player ID on projectile for damage routing\n            // This ensures tower projectiles can damage enemy summoned units\n            projectileEntity.userData = projectileEntity.userData || {};\n            projectileEntity.userData.playerId = tower.ownerId;\n            // Also set it on the projectile component for combat system detection\n            const projectileComponent = projectileEntity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__.Projectile);\n            if (projectileComponent) {\n                projectileComponent.sourcePlayerId = tower.ownerId;\n            }\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    // Methods for managing player stealth states\n    updatePlayerStealthState(playerId, isInvisible) {\n        this.playerStealthStates.set(playerId, isInvisible);\n    }\n    clearPlayerStealthState(playerId) {\n        this.playerStealthStates.delete(playerId);\n    }\n    setLocalSocketId(socketId) {\n        this.localSocketId = socketId;\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Track stealth states for remote players\n        this.playerStealthStates = new Map();\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0U7QUFDbEI7QUFDVjtBQUVpQjtBQUNOO0FBQ0Y7QUFDYztBQUNKO0FBQ0o7QUFDZ0I7QUFJOUQsTUFBTVUsb0JBQW9CVCwrQ0FBTUE7SUF5QjlCVSxvQkFBb0JDLGdCQUFrQyxFQUFRO1FBQ25FLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBO0lBQzFCO0lBRU9DLHVCQUF1QkMsUUFBdUcsRUFBUTtRQUMzSSxJQUFJLENBQUNDLHFCQUFxQixHQUFHRDtJQUMvQjtJQUVPRSxpQkFBaUJDLG9CQUF5QyxFQUFFQyxhQUFxQixFQUFRO1FBQzlGLElBQUksQ0FBQ0Qsb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUN2QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsS0FBSyxNQUFNLHFCQUFxQjtRQUU1RCxLQUFLLE1BQU1DLFVBQVVMLFNBQVU7WUFDN0IsTUFBTU0sWUFBWUQsT0FBT0UsWUFBWSxDQUFDekIsZ0VBQVNBO1lBQy9DLE1BQU0wQixRQUFRSCxPQUFPRSxZQUFZLENBQUN2Qix3REFBS0E7WUFDdkMsTUFBTXlCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQ3hCLDBEQUFNQTtZQUV6QyxJQUFJLENBQUN1QixhQUFhLENBQUNFLFNBQVMsQ0FBQ0MsUUFBUTtZQUVyQyx5QkFBeUI7WUFDekIsSUFBSUEsT0FBT0MsTUFBTSxJQUFJLENBQUNGLE1BQU1FLE1BQU0sRUFBRTtnQkFDbENGLE1BQU1HLEdBQUcsQ0FBQ1Q7Z0JBQ1Y7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixJQUFJLENBQUNNLE1BQU1JLFFBQVEsSUFBSUosTUFBTUUsTUFBTSxFQUFFO1lBRXJDLGtDQUFrQztZQUNsQyxJQUFJRixNQUFNSyxtQkFBbUIsQ0FBQ1gs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QVNDLFVBQVVELE1BQU1JLFFBQVEsSUFBSSxDQUFDSixNQUFNRSxNQUFNLElBQUksQ0FBQ0QsT0FBT0MsTUFBTTtRQUM3RTtJQUNGO0lBRUEsNkNBQTZDO0lBQ3RDNEYseUJBQXlCM0MsUUFBZ0IsRUFBRTRDLFdBQW9CLEVBQVE7UUFDNUUsSUFBSSxDQUFDM0MsbUJBQW1CLENBQUM0QyxHQUFHLENBQUM3QyxVQUFVNEM7SUFDekM7SUFFT0Usd0JBQXdCOUMsUUFBZ0IsRUFBUTtRQUNyRCxJQUFJLENBQUNDLG1CQUFtQixDQUFDOEMsTUFBTSxDQUFDL0M7SUFDbEM7SUFFT2dELGlCQUFpQkMsUUFBZ0IsRUFBUTtRQUM5QyxJQUFJLENBQUM5RyxhQUFhLEdBQUc4RztJQUN2QjtJQW5WQUMsWUFBWTVGLEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBbkJTNkYscUJBQXFCO1lBQUNoSSxnRUFBU0E7WUFBRUUsd0RBQUtBO1lBQUVELDBEQUFNQTtTQUFDO2FBRXZEUyxtQkFBNEM7UUFLcEQsZ0VBQWdFO2FBQ3hESyx1QkFBNEMsSUFBSWtIO2FBQ2hEakgsZ0JBQStCO1FBRXZDLDBDQUEwQzthQUNsQzhELHNCQUE0QyxJQUFJbUQ7UUFFeEQseUNBQXlDO2FBQ2pDOUMsYUFBYSxJQUFJckYseURBQU9BO2FBQ3hCa0YsY0FBYyxJQUFJbEYseURBQU9BO1FBSS9CLElBQUksQ0FBQ3FDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMrRixRQUFRLEdBQUcsSUFBSSxxQ0FBcUM7SUFDM0Q7QUFnVkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvVG93ZXJTeXN0ZW0udHM/NmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb3dlciBzeXN0ZW0gZm9yIG1hbmFnaW5nIFBWUCB0b3dlciBBSSwgdGFyZ2V0aW5nLCBhbmQgc2hvb3RpbmdcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBUb3dlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVG93ZXInO1xuaW1wb3J0IHsgU3VtbW9uZWRVbml0IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZSc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IFByb2plY3RpbGVTeXN0ZW0gfSBmcm9tICcuL1Byb2plY3RpbGVTeXN0ZW0nO1xuXG5leHBvcnQgY2xhc3MgVG93ZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgdG93ZXIgYXR0YWNrcyBpbiBtdWx0aXBsYXllclxuICBwcml2YXRlIG9uVG93ZXJBdHRhY2tDYWxsYmFjaz86ICh0b3dlck93bmVySWQ6IHN0cmluZywgdGFyZ2V0UGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIFBsYXllciBlbnRpdHkgbWFwcGluZyBmb3IgaWRlbnRpZnlpbmcgdG93ZXIgb3duZXJzIHZzIGVuZW1pZXNcbiAgcHJpdmF0ZSBzZXJ2ZXJQbGF5ZXJFbnRpdGllczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBsb2NhbFNvY2tldElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIFRyYWNrIHN0ZWFsdGggc3RhdGVzIGZvciByZW1vdGUgcGxheWVyc1xuICBwcml2YXRlIHBsYXllclN0ZWFsdGhTdGF0ZXM6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnQgYW5kIHByb2plY3RpbGVzXG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlU3lzdGVtKHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VG93ZXJBdHRhY2tDYWxsYmFjayhjYWxsYmFjazogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFBsYXllck1hcHBpbmcoc2VydmVyUGxheWVyRW50aXRpZXM6IE1hcDxzdHJpbmcsIG51bWJlcj4sIGxvY2FsU29ja2V0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMgPSBzZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICB0aGlzLmxvY2FsU29ja2V0SWQgPSBsb2NhbFNvY2tldElkO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICF0b3dlciB8fCAhaGVhbHRoKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdG93ZXIgaXMgZGVhZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQgJiYgIXRvd2VyLmlzRGVhZCkge1xuICAgICAgICB0b3dlci5kaWUoY3VycmVudFRpbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHRvd2Vyc1xuICAgICAgaWYgKCF0b3dlci5pc0FjdGl2ZSB8fCB0b3dlci5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBTZWFyY2ggZm9yIHRhcmdldHMgcGVyaW9kaWNhbGx5XG4gICAgICBpZiAodG93ZXIuY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGb3JUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGN1cnJlbnQgdGFyZ2V0IChjaGVjayBpZiBzdGlsbCBhbGl2ZSBhbmQgaW4gcmFuZ2UpXG4gICAgICBpZiAodG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eSh0b3dlci5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYXJnZXQodGFyZ2V0RW50aXR5IHx8IG51bGwsIHRyYW5zZm9ybSwgdG93ZXIpKSB7XG4gICAgICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdHRhY2sgY3VycmVudCB0YXJnZXQgaWYgcG9zc2libGVcbiAgICAgIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0ICYmIHRvd2VyLmNhbkF0dGFjayhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHNlYXJjaEZvclRhcmdldCh0b3dlckVudGl0eTogRW50aXR5LCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0b3dlci51cGRhdGVUYXJnZXRTZWFyY2goY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIEdldCBhbGwgcG90ZW50aWFsIHRhcmdldHMgKHBsYXllcnMgdGhhdCBhcmUgbm90IHRoZSB0b3dlciBvd25lcilcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBcbiAgICBcbiAgICBsZXQgY2xvc2VzdFRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCB2YWxpZFRhcmdldENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIgJiYgdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhcmdldCh0YXJnZXQsIHRvd2VyVHJhbnNmb3JtLCB0b3dlcikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICB2YWxpZFRhcmdldENvdW50Kys7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0yID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0yKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybTIucG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdG93ZXIudGFyZ2V0U2VhcmNoUmFuZ2UgJiYgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGlmIChjbG9zZXN0VGFyZ2V0KSB7XG4gICAgICB0b3dlci5zZXRUYXJnZXQoY2xvc2VzdFRhcmdldC5pZCk7XG4gICAgfSBlbHNlIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhciB0YXJnZXQgaWYgbm8gdmFsaWQgdGFyZ2V0cyBmb3VuZFxuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgaXNWYWxpZFRhcmdldCh0YXJnZXQ6IEVudGl0eSB8IG51bGwsIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBcbiAgICAvLyBNdXN0IGhhdmUgcmVxdWlyZWQgY29tcG9uZW50cyBhbmQgYmUgYWxpdmVcbiAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8ICF0YXJnZXRDb2xsaWRlciB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIE11c3QgYmUgYSBwbGF5ZXIgKG5vdCBhbiBlbmVteSBvciBvdGhlciB0b3dlcilcbiAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUiAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdGFyZ2V0IG90aGVyIHRvd2Vyc1xuICAgIGlmICh0YXJnZXQuaGFzQ29tcG9uZW50KFRvd2VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBzdW1tb25lZCB1bml0XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gdGFyZ2V0LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXQpIHtcbiAgICAgIC8vIERvbid0IHRhcmdldCBkZWFkIG9yIGluYWN0aXZlIHN1bW1vbmVkIHVuaXRzXG4gICAgICBpZiAoc3VtbW9uZWRVbml0LmlzRGVhZCB8fCAhc3VtbW9uZWRVbml0LmlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIE9ubHkgdGFyZ2V0IGVuZW15IHN1bW1vbmVkIHVuaXRzIChkaWZmZXJlbnQgb3duZXIpXG4gICAgICByZXR1cm4gc3VtbW9uZWRVbml0Lm93bmVySWQgIT09IHRvd2VyLm93bmVySWQ7XG4gICAgfVxuXG4gICAgLy8gSW4gUFZQIG1vZGUsIGlkZW50aWZ5IGlmIHRoaXMgaXMgYW4gZW5lbXkgcGxheWVyXG4gICAgaWYgKHRoaXMubG9jYWxTb2NrZXRJZCAmJiB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzLnNpemUgPiAwKSB7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGxvY2FsIHBsYXllciAoUExBWUVSIGxheWVyKVxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkVGFyZ2V0ID0gdG93ZXIub3duZXJJZCAhPT0gdGhpcy5sb2NhbFNvY2tldElkO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbG9jYWwgcGxheWVyIGFuZCB0aGV5IGFyZSBpbnZpc2libGUgKHN0ZWFsdGhlZCksIGRvbid0IHRhcmdldCB0aGVtXG4gICAgICAgIGlmIChzaG91bGRUYXJnZXQgJiYgdGhpcy5sb2NhbFNvY2tldElkKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbG9jYWwgcGxheWVyIGlzIGludmlzaWJsZSB0aHJvdWdoIGEgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xTeXN0ZW0gPSAod2luZG93IGFzIGFueSkuY29udHJvbFN5c3RlbVJlZj8uY3VycmVudDtcbiAgICAgICAgICBpZiAoY29udHJvbFN5c3RlbSAmJiBjb250cm9sU3lzdGVtLmlzUGxheWVySW52aXNpYmxlICYmIGNvbnRyb2xTeXN0ZW0uaXNQbGF5ZXJJbnZpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCB0YXJnZXQgaW52aXNpYmxlIGxvY2FsIHBsYXllclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNob3VsZFRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbW90ZSBwbGF5ZXIgKEVORU1ZIGxheWVyKVxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWSkge1xuICAgICAgICAvLyBGaW5kIHdoaWNoIHBsYXllciB0aGlzIGVudGl0eSBiZWxvbmdzIHRvXG4gICAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMuZm9yRWFjaCgoZW50aXR5SWQsIHBsYXllcklkKSA9PiB7XG4gICAgICAgICAgaWYgKGVudGl0eUlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0YXJnZXRQbGF5ZXJJZDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IHBsYXllciBpcyBpbnZpc2libGUgKHN0ZWFsdGhlZClcbiAgICAgICAgICBpZiAoc2hvdWxkVGFyZ2V0ICYmIHRoaXMucGxheWVyU3RlYWx0aFN0YXRlcy5nZXQodGFyZ2V0UGxheWVySWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHRhcmdldCBpbnZpc2libGUgcmVtb3RlIHBsYXllcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHNob3VsZFRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBhdHRhY2tUYXJnZXQodG93ZXJFbnRpdHk6IEVudGl0eSwgdG93ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgdG93ZXI6IFRvd2VyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkodG93ZXIuY3VycmVudFRhcmdldCEpO1xuICAgIGlmICghdGFyZ2V0RW50aXR5KSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvdWJsZS1jaGVjayB0YXJnZXQgdmFsaWRpdHkgYmVmb3JlIGF0dGFja2luZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkVGFyZ2V0KHRhcmdldEVudGl0eSwgdG93ZXJUcmFuc2Zvcm0sIHRvd2VyKSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXRFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0pIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gKHNsaWdodGx5IGFib3ZlIHRvd2VyIGNlbnRlcilcbiAgICB0aGlzLnRlbXBWZWN0b3IyLmNvcHkodG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3RvcjIueSArPSAyOyAvLyBTcGF3biBwcm9qZWN0aWxlcyAyIHVuaXRzIGFib3ZlIHRvd2VyIGJhc2VcblxuICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gZnJvbSBzcGF3biBwb3NpdGlvbiB0byB0YXJnZXQgKG5vdCB0b3dlciBiYXNlKVxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgdGhpcy50ZW1wVmVjdG9yLnN1Yih0aGlzLnRlbXBWZWN0b3IyKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMudGVtcFZlY3Rvci5sZW5ndGgoKTtcblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBzdGlsbCBpbiByYW5nZVxuICAgIGlmIChkaXN0YW5jZSA+IHRvd2VyLmF0dGFja1JhbmdlKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHZlcnkgY2xvc2UgdGFyZ2V0cyAtIGVuc3VyZSB3ZSBjYW4gYWx3YXlzIGhpdCB0aGVtXG4gICAgaWYgKGRpc3RhbmNlIDwgMC41KSB7XG4gICAgICAvLyBGb3IgZXh0cmVtZWx5IGNsb3NlIHRhcmdldHMsIGNyZWF0ZSBhIG1vcmUgcHJlZGljdGFibGUgdHJhamVjdG9yeVxuICAgICAgLy8gQWltIHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXQgdG8gYWNjb3VudCBmb3IgZ3Jhdml0eSBhbmQgZW5zdXJlIGhpdFxuICAgICAgdGhpcy50ZW1wVmVjdG9yLmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMudGVtcFZlY3Rvci55ICs9IDAuMzsgLy8gQWltIDAuMyB1bml0cyBhYm92ZSB0YXJnZXRcbiAgICAgIHRoaXMudGVtcFZlY3Rvci5zdWIodGhpcy50ZW1wVmVjdG9yMik7XG4gICAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb24gZm9yIG5vcm1hbCBjYXNlc1xuICAgICAgdGhpcy50ZW1wVmVjdG9yLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLnByb2plY3RpbGVTeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiB0b3dlci5wcm9qZWN0aWxlU3BlZWQsXG4gICAgICAgIGRhbWFnZTogdG93ZXIuYXR0YWNrRGFtYWdlLFxuICAgICAgICBsaWZldGltZTogMiwgLy8gNSBzZWNvbmQgbGlmZXRpbWVcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHRoaXMudGVtcFZlY3RvcjIsIC8vIHNwYXduIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudGVtcFZlY3RvciwgIC8vIGRpcmVjdGlvblxuICAgICAgICB0b3dlckVudGl0eS5pZCwgICAvLyB0b3dlciBhcyBvd25lclxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuXG4gICAgICAvLyBFbmFibGUgZXh0cmVtZWx5IHN0cm9uZyBob21pbmcgZm9yIHRvd2VyIHByb2plY3RpbGVzXG4gICAgICBjb25zdCBwcm9qZWN0aWxlID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgICBpZiAocHJvamVjdGlsZSAmJiB0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhIHN1bW1vbmVkIHVuaXQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgdGFyZ2V0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkodG93ZXIuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzU3VtbW9uZWRVbml0ID0gdGFyZ2V0RW50aXR5Py5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChpc1N1bW1vbmVkVW5pdCkge1xuICAgICAgICAgIC8vIE1ha2UgaXQgSU1QT1NTSUJMRSBmb3Igc3VtbW9uZWQgdW5pdHMgdG8gZG9kZ2UgLSBwZXJmZWN0IHRyYWNraW5nXG4gICAgICAgICAgcHJvamVjdGlsZS5zZXRIb21pbmcodG93ZXIuY3VycmVudFRhcmdldCwgMS4wLCA4LjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvciBwbGF5ZXJzOiB2ZXJ5IGRpZmZpY3VsdCB0byBkb2RnZSBidXQgbm90IGltcG9zc2libGVcbiAgICAgICAgICBwcm9qZWN0aWxlLnNldEhvbWluZyh0b3dlci5jdXJyZW50VGFyZ2V0LCAwLjk1LCA2LjApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHNwZWNpYWwgdG93ZXIgcHJvamVjdGlsZSBwcm9wZXJ0aWVzIGZvciBlbmhhbmNlZCB0cmFja2luZ1xuICAgICAgICBwcm9qZWN0aWxlLm1heFR1cm5SYXRlID0gaXNTdW1tb25lZFVuaXQgPyAxMi4wIDogOC4wOyAvLyBFdmVuIGZhc3RlciB0dXJucyBmb3Igc3VtbW9uZWQgdW5pdHNcbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBwcm9qZWN0aWxlIGFzIHRvd2VyIHByb2plY3RpbGUgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHByb2plY3RpbGVSZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSBhcyBSZW5kZXJlcjtcbiAgICAgIGlmIChwcm9qZWN0aWxlUmVuZGVyZXIgJiYgcHJvamVjdGlsZVJlbmRlcmVyLm1lc2gpIHtcbiAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIGlkZW50aWZ5IHRoaXMgYXMgYSB0b3dlciBwcm9qZWN0aWxlXG4gICAgICAgIHByb2plY3RpbGVSZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzVG93ZXJQcm9qZWN0aWxlID0gdHJ1ZTtcbiAgICAgICAgcHJvamVjdGlsZVJlbmRlcmVyLm1lc2gudXNlckRhdGEudG93ZXJPd25lcklkID0gdG93ZXIub3duZXJJZDtcbiAgICAgICAgcHJvamVjdGlsZVJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNSZWd1bGFyQXJyb3cgPSBmYWxzZTsgLy8gT3ZlcnJpZGUgcmVndWxhciBhcnJvdyBmbGFnXG4gICAgICAgIHByb2plY3RpbGVSZW5kZXJlci5tZXNoLnVzZXJEYXRhLmRpcmVjdGlvbiA9IHRoaXMudGVtcFZlY3Rvci5jbG9uZSgpO1xuICAgICAgICBwcm9qZWN0aWxlUmVuZGVyZXIubWVzaC51c2VyRGF0YS5vcGFjaXR5ID0gMS4wO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBbHNvIG1hcmsgdGhlIGVudGl0eSBpdHNlbGYgZm9yIFByb2plY3RpbGVTeXN0ZW0gZGV0ZWN0aW9uXG4gICAgICAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLmlzVG93ZXJQcm9qZWN0aWxlID0gdHJ1ZTtcbiAgICAgIChwcm9qZWN0aWxlRW50aXR5IGFzIGFueSkudG93ZXJPd25lcklkID0gdG93ZXIub3duZXJJZDtcblxuICAgICAgLy8gQ1JJVElDQUw6IFNldCBzb3VyY2UgcGxheWVyIElEIG9uIHByb2plY3RpbGUgZm9yIGRhbWFnZSByb3V0aW5nXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdG93ZXIgcHJvamVjdGlsZXMgY2FuIGRhbWFnZSBlbmVteSBzdW1tb25lZCB1bml0c1xuICAgICAgcHJvamVjdGlsZUVudGl0eS51c2VyRGF0YSA9IHByb2plY3RpbGVFbnRpdHkudXNlckRhdGEgfHwge307XG4gICAgICBwcm9qZWN0aWxlRW50aXR5LnVzZXJEYXRhLnBsYXllcklkID0gdG93ZXIub3duZXJJZDtcbiAgICAgIFxuICAgICAgLy8gQWxzbyBzZXQgaXQgb24gdGhlIHByb2plY3RpbGUgY29tcG9uZW50IGZvciBjb21iYXQgc3lzdGVtIGRldGVjdGlvblxuICAgICAgY29uc3QgcHJvamVjdGlsZUNvbXBvbmVudCA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgICAgaWYgKHByb2plY3RpbGVDb21wb25lbnQpIHtcbiAgICAgICAgKHByb2plY3RpbGVDb21wb25lbnQgYXMgYW55KS5zb3VyY2VQbGF5ZXJJZCA9IHRvd2VyLm93bmVySWQ7XG4gICAgICB9XG5cbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IGF0dGFjayB0byBtdWx0aXBsYXllciBpZiBjYWxsYmFjayBpcyBzZXRcbiAgICBpZiAodGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFwIHRoZSB0YXJnZXQgZW50aXR5IGJhY2sgdG8gYSBwbGF5ZXIgSURcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHVzZSBhIHBsYWNlaG9sZGVyIC0gdGhpcyB3aWxsIG5lZWQgdG8gYmUgaW1wcm92ZWQgd2l0aCBwcm9wZXIgcGxheWVyIG1hcHBpbmdcbiAgICAgIGNvbnN0IHRhcmdldFBsYXllcklkID0gYHBsYXllcl8ke3Rvd2VyLmN1cnJlbnRUYXJnZXR9YDtcbiAgICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrKHRvd2VyLm93bmVySWQsIHRhcmdldFBsYXllcklkLCB0aGlzLnRlbXBWZWN0b3IyLCB0aGlzLnRlbXBWZWN0b3IpO1xuICAgIH1cbiAgICBcbiAgICB0b3dlci5wZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lKTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IGFsbCB0b3dlcnMgb3duZWQgYnkgYSBzcGVjaWZpYyBwbGF5ZXJcbiAgcHVibGljIGdldFRvd2Vyc0J5T3duZXIob3duZXJJZDogc3RyaW5nKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGFsbFRvd2VycyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXSk7XG4gICAgcmV0dXJuIGFsbFRvd2Vycy5maWx0ZXIoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICByZXR1cm4gdG93ZXIgJiYgdG93ZXIub3duZXJJZCA9PT0gb3duZXJJZDtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IHRvd2VyIGNvdW50IGZvciBhIHBsYXllclxuICBwdWJsaWMgZ2V0VG93ZXJDb3VudChvd25lcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCkubGVuZ3RoO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjaGVjayBpZiBhIHBsYXllciBoYXMgYW55IGFjdGl2ZSB0b3dlcnNcbiAgcHVibGljIGhhc0FjdGl2ZVRvd2Vycyhvd25lcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCk7XG4gICAgcmV0dXJuIHRvd2Vycy5zb21lKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgcmV0dXJuIHRvd2VyICYmIGhlYWx0aCAmJiB0b3dlci5pc0FjdGl2ZSAmJiAhdG93ZXIuaXNEZWFkICYmICFoZWFsdGguaXNEZWFkO1xuICAgIH0pO1xuICB9XG4gIFxuICAvLyBNZXRob2RzIGZvciBtYW5hZ2luZyBwbGF5ZXIgc3RlYWx0aCBzdGF0ZXNcbiAgcHVibGljIHVwZGF0ZVBsYXllclN0ZWFsdGhTdGF0ZShwbGF5ZXJJZDogc3RyaW5nLCBpc0ludmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucGxheWVyU3RlYWx0aFN0YXRlcy5zZXQocGxheWVySWQsIGlzSW52aXNpYmxlKTtcbiAgfVxuICBcbiAgcHVibGljIGNsZWFyUGxheWVyU3RlYWx0aFN0YXRlKHBsYXllcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnBsYXllclN0ZWFsdGhTdGF0ZXMuZGVsZXRlKHBsYXllcklkKTtcbiAgfVxuICBcbiAgcHVibGljIHNldExvY2FsU29ja2V0SWQoc29ja2V0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTb2NrZXRJZCA9IHNvY2tldElkO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkhlYWx0aCIsIlRvd2VyIiwiU3VtbW9uZWRVbml0IiwiUHJvamVjdGlsZSIsIlJlbmRlcmVyIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlRvd2VyU3lzdGVtIiwic2V0UHJvamVjdGlsZVN5c3RlbSIsInByb2plY3RpbGVTeXN0ZW0iLCJzZXRUb3dlckF0dGFja0NhbGxiYWNrIiwiY2FsbGJhY2siLCJvblRvd2VyQXR0YWNrQ2FsbGJhY2siLCJzZXRQbGF5ZXJNYXBwaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJsb2NhbFNvY2tldElkIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ0b3dlciIsImhlYWx0aCIsImlzRGVhZCIsImRpZSIsImlzQWN0aXZlIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsInNlYXJjaEZvclRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRFbnRpdHkiLCJ3b3JsZCIsImdldEVudGl0eSIsImlzVmFsaWRUYXJnZXQiLCJjbGVhclRhcmdldCIsImNhbkF0dGFjayIsImF0dGFja1RhcmdldCIsInRvd2VyRW50aXR5IiwidG93ZXJUcmFuc2Zvcm0iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsImNsb3Nlc3RUYXJnZXQiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInZhbGlkVGFyZ2V0Q291bnQiLCJ0YXJnZXQiLCJ0YXJnZXRDb2xsaWRlciIsInRhcmdldFRyYW5zZm9ybSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwidGFyZ2V0VHJhbnNmb3JtMiIsInRhcmdldFNlYXJjaFJhbmdlIiwic2V0VGFyZ2V0IiwiaWQiLCJ0YXJnZXRIZWFsdGgiLCJsYXllciIsIlBMQVlFUiIsIkVORU1ZIiwiaGFzQ29tcG9uZW50Iiwic3VtbW9uZWRVbml0Iiwib3duZXJJZCIsInNpemUiLCJzaG91bGRUYXJnZXQiLCJjb250cm9sU3lzdGVtIiwid2luZG93IiwiY29udHJvbFN5c3RlbVJlZiIsImN1cnJlbnQiLCJpc1BsYXllckludmlzaWJsZSIsInRhcmdldFBsYXllcklkIiwiZm9yRWFjaCIsImVudGl0eUlkIiwicGxheWVySWQiLCJwbGF5ZXJTdGVhbHRoU3RhdGVzIiwiZ2V0IiwidGVtcFZlY3RvcjIiLCJjb3B5IiwieSIsInRlbXBWZWN0b3IiLCJzdWIiLCJsZW5ndGgiLCJhdHRhY2tSYW5nZSIsIm5vcm1hbGl6ZSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsInByb2plY3RpbGVTcGVlZCIsImRhbWFnZSIsImF0dGFja0RhbWFnZSIsImxpZmV0aW1lIiwib3BhY2l0eSIsInByb2plY3RpbGVFbnRpdHkiLCJjcmVhdGVQcm9qZWN0aWxlIiwicHJvamVjdGlsZSIsImlzU3VtbW9uZWRVbml0IiwidW5kZWZpbmVkIiwic2V0SG9taW5nIiwibWF4VHVyblJhdGUiLCJwcm9qZWN0aWxlUmVuZGVyZXIiLCJtZXNoIiwidXNlckRhdGEiLCJpc1Rvd2VyUHJvamVjdGlsZSIsInRvd2VyT3duZXJJZCIsImlzUmVndWxhckFycm93IiwiZGlyZWN0aW9uIiwiY2xvbmUiLCJwcm9qZWN0aWxlQ29tcG9uZW50Iiwic291cmNlUGxheWVySWQiLCJwZXJmb3JtQXR0YWNrIiwiZ2V0VG93ZXJzQnlPd25lciIsImFsbFRvd2VycyIsImZpbHRlciIsImdldFRvd2VyQ291bnQiLCJoYXNBY3RpdmVUb3dlcnMiLCJ0b3dlcnMiLCJzb21lIiwidXBkYXRlUGxheWVyU3RlYWx0aFN0YXRlIiwiaXNJbnZpc2libGUiLCJzZXQiLCJjbGVhclBsYXllclN0ZWFsdGhTdGF0ZSIsImRlbGV0ZSIsInNldExvY2FsU29ja2V0SWQiLCJzb2NrZXRJZCIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwiTWFwIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);