"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            console.warn(\"Engine already initialized\");\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            console.warn(\"Engine already running\");\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QkMsUUFBUUMsSUFBSSxDQUFDO1lBQ2I7UUFDRjtRQUVBLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0ksWUFBWSxDQUFDTCxVQUFVLENBQUNDO1FBRTdCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0ksSUFBSSxDQUFDO0lBRVo7SUFFT0MsUUFBYztRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDTCxhQUFhLEVBQUU7WUFDdkIsTUFBTSxJQUFJTSxNQUFNO1FBQ2xCO1FBRUEsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNsQk4sUUFBUUMsSUFBSSxDQUFDO1lBQ2I7UUFDRjtRQUVBLElBQUksQ0FBQ0ssU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDSCxLQUFLO1FBQ25CLElBQUksQ0FBQ0QsSUFBSSxDQUFDO0lBR1o7SUFFT0ssT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDRixTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUk7UUFDbEIsSUFBSSxDQUFDTCxJQUFJLENBQUM7SUFHWjtJQUVPTSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDSCxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNFLEtBQUs7WUFDbkIsSUFBSSxDQUFDTixJQUFJLENBQUM7UUFDWjtJQUNGO0lBRU9PLFNBQWU7UUFDcEIsSUFBSSxJQUFJLENBQUNKLFNBQVMsRUFBRTtZQUNsQixJQUFJLENB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LGtCQUF3QjtRQUM3QixJQUFJLENBQUN0QyxZQUFZLENBQUNzQyxlQUFlO0lBQ25DO0lBRU9DLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ3hDLFlBQVksQ0FBQ3VDLFlBQVksQ0FBQ0M7SUFDeEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUMxQyxZQUFZLENBQUN5QyxvQkFBb0IsQ0FBQ0M7SUFDaEQ7SUFFT0MsZ0JBQTBDO1FBQy9DLE9BQU8sSUFBSSxDQUFDM0MsWUFBWSxDQUFDMkMsYUFBYTtJQUN4QztJQXBMQUMsWUFBWUMsU0FBdUIsQ0FBQyxDQUFDLENBQUU7UUFDckMsS0FBSzthQVhDakQsU0FBbUM7YUFDbkNDLGdCQUFnQjthQUNoQk8sWUFBWTthQUNaa0IsWUFBWTtRQUVwQix5QkFBeUI7YUFDakJMLFlBQVk7YUFDWkMsYUFBYTthQUNiQyxhQUFhO1FBS25CLElBQUksQ0FBQ1QsS0FBSyxHQUFHLElBQUlwQiw2Q0FBS0E7UUFDdEIsSUFBSSxDQUFDZSxRQUFRLEdBQUcsSUFBSWQsK0NBQVFBO1FBQzVCLElBQUksQ0FBQ1MsWUFBWSxHQUFHLElBQUlSLHVEQUFZQTtRQUNwQyxJQUFJLENBQUM4QixTQUFTLEdBQUd1QixPQUFPQyxXQUFXLElBQUk7UUFFdkMsSUFBSSxDQUFDdEIsYUFBYTtJQUNwQjtBQTRLRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9FbmdpbmUudHM/MmY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWluIGdhbWUgZW5naW5lIHdpdGggRUNTIGludGVncmF0aW9uXG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IEdhbWVMb29wIH0gZnJvbSAnLi9HYW1lTG9vcCc7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICcuL0lucHV0TWFuYWdlcic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5naW5lQ29uZmlnIHtcbiAgY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGVuYWJsZURlYnVnPzogYm9vbGVhbjtcbiAgdGFyZ2V0RlBTPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRW5naW5lIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgZ2FtZUxvb3A6IEdhbWVMb29wO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgaXNSdW5uaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgZGVidWdNb2RlID0gZmFsc2U7XG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lVGltZSA9IDA7XG4gIHByaXZhdGUgdXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgcmVuZGVyVGltZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBFbmdpbmVDb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy53b3JsZCA9IG5ldyBXb3JsZCgpO1xuICAgIHRoaXMuZ2FtZUxvb3AgPSBuZXcgR2FtZUxvb3AoKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IG5ldyBJbnB1dE1hbmFnZXIoKTtcbiAgICB0aGlzLmRlYnVnTW9kZSA9IGNvbmZpZy5lbmFibGVEZWJ1ZyB8fCBmYWxzZTtcblxuICAgIHRoaXMuc2V0dXBHYW1lTG9vcCgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignRW5naW5lIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmlucHV0TWFuYWdlci5pbml0aWFsaXplKGNhbnZhcyk7XG4gICAgXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJyk7XG4gICAgXG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5naW5lIG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHN0YXJ0aW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VuZ2luZSBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJjb25zb2xlIiwid2FybiIsImlucHV0TWFuYWdlciIsImVtaXQiLCJzdGFydCIsIkVycm9yIiwiaXNSdW5uaW5nIiwiZ2FtZUxvb3AiLCJzdG9wIiwicGF1c2UiLCJyZXN1bWUiLCJnZXRXb3JsZCIsIndvcmxkIiwiZ2V0SW5wdXRNYW5hZ2VyIiwiZ2V0Q2FudmFzIiwiaXNFbmdpbmVSdW5uaW5nIiwiZ2V0Q3VycmVudEZQUyIsImdldFBlcmZvcm1hbmNlU3RhdHMiLCJmcHMiLCJmcmFtZVRpbWUiLCJ1cGRhdGVUaW1lIiwicmVuZGVyVGltZSIsImVuYWJsZURlYnVnTW9kZSIsImVuYWJsZWQiLCJkZWJ1Z01vZGUiLCJpc0RlYnVnTW9kZSIsInNldHVwR2FtZUxvb3AiLCJvbiIsImZpeGVkRGVsdGFUaW1lIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJmaXhlZFVwZGF0ZSIsImRlbHRhVGltZSIsInVwZGF0ZSIsImludGVycG9sYXRpb24iLCJyZW5kZXIiLCJkZXN0cm95IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVxdWVzdFBvaW50ZXJMb2NrIiwiZXhpdFBvaW50ZXJMb2NrIiwiaXNLZXlQcmVzc2VkIiwia2V5IiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJidXR0b24iLCJnZXRNb3VzZURlbHRhIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJlbmFibGVEZWJ1ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        console.warn(\"Pointer lock failed\");\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJLEdBQUc7WUFBRUksU0FBUztRQUFNO1FBQzNFUCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNPLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Usa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FB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ZCxJQUFJLENBQUNZLElBQUksQ0FBQ3lFLEtBQUs7UUFDZixJQUFJLENBQUNwRSxZQUFZLENBQUNvRSxLQUFLO1FBQ3ZCLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ29ELEtBQUs7UUFDckIsSUFBSSxDQUFDSyxrQkFBa0I7SUFDekI7SUFwWEFDLGFBQWM7UUFDWixLQUFLO2FBbkJDL0UsT0FBTyxJQUFJVzthQUNYTixlQUFlLElBQUlNO2FBQ25CSixnQkFBZ0I7WUFBRU0sR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDN0JMLGFBQWE7WUFBRUksR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDMUJzRCx3QkFBd0I7WUFBRXZELEdBQUc7WUFBR0MsR0FBRztRQUFFO2FBQ3JDbUQsa0JBQWtCO2FBQ2xCaEYsU0FBbUM7UUFFM0MsdUNBQXVDO2FBQy9Cb0MsYUFBYSxJQUFJMkQ7YUFPUmxELHVCQUF1QixJQUFLLG1EQUFtRDs7UUFJOUYsSUFBSSxDQUFDa0IsbUJBQW1CO0lBQzFCO0FBa1hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cz8wZDEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbnRyYWxpemVkIGlucHV0IGhhbmRsaW5nIHN5c3RlbVxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQC91dGlscy9FdmVudEVtaXR0ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0RXZlbnRzIHtcbiAga2V5RG93bjogeyBrZXk6IHN0cmluZzsgY29kZTogc3RyaW5nIH07XG4gIGtleVVwOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAgbW91c2VEb3duOiB7IGJ1dHRvbjogbnVtYmVyOyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBtb3VzZVVwOiB7IGJ1dHRvbjogbnVtYmVyOyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBtb3VzZU1vdmU6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlciB9O1xuICB3aGVlbDogeyBkZWx0YVg6IG51bWJlcjsgZGVsdGFZOiBudW1iZXI7IGRlbHRhWjogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRTdGF0ZSB7XG4gIGtleXM6IFNldDxzdHJpbmc+O1xuICBtb3VzZToge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgZGVsdGFYOiBudW1iZXI7XG4gICAgZGVsdGFZOiBudW1iZXI7XG4gICAgYnV0dG9uczogU2V0PG51bWJlcj47XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBJbnB1dE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBtb3VzZUJ1dHRvbnMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgbW91c2VEZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuICBwcml2YXRlIHByZXZpb3VzTW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICBwcml2YXRlIGlzUG9pbnRlckxvY2tlZCA9IGZhbHNlO1xuICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAvLyBEb3VibGUtdGFwIGRldGVjdGlvbiBmb3IgZGFzaCBzeXN0ZW1cbiAgcHJpdmF0ZSBrZXlUaW1pbmdzID0gbmV3IE1hcDxzdHJpbmcsIHsgXG4gICAgZmlyc3RQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBmaXJzdFJlbGVhc2VUaW1lOiBudW1iZXI7XG4gICAgc2Vjb25kUHJlc3NUaW1lOiBudW1iZXI7XG4gICAgaXNJbkRvdWJsZVRhcFNlcXVlbmNlOiBib29sZWFuO1xuICAgIGhhc1ZhbGlkRmlyc3RUYXA6IGJvb2xlYW47XG4gIH0+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgRE9VQkxFX1RBUF9USFJFU0hPTEQgPSAyMDA7IC8vIDIwMG1zIHdpbmRvdyBmb3IgZG91YmxlLXRhcCAocmVkdWNlZCBmcm9tIDI1MG1zKVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgXG4gICAgLy8gQWRkIGNhbnZhcy1zcGVjaWZpYyBldmVudCBsaXN0ZW5lcnMgdG8gZW5zdXJlIHdlIGNhcHR1cmUgZXZlbnRzXG4gICAgLy8gdGhhdCBtaWdodCBiZSBoYW5kbGVkIGJ5IFJlYWN0IFRocmVlIEZpYmVyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICBcbiAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IHJlcXVlc3QgcG9pbnRlciBsb2NrIC0gbGV0IHN5c3RlbXMgaGFuZGxlIHRoaXNcbiAgICAvLyBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgLy8gICBpZiAoIXRoaXMuaXNQb2ludGVyTG9ja2VkKSB7XG4gICAgLy8gICAgIHRoaXMucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG4gIH1cblxuICBwdWJsaWMgcmVxdWVzdFBvaW50ZXJMb2NrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGV4aXRQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0tleVByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5rZXlzLmhhcyhrZXkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBwdWJsaWMgaXNNb3VzZUJ1dHRvblByZXNzZWQoYnV0dG9uOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZUJ1dHRvbnMuaGFzKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VQb3NpdGlvbigpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMubW91c2VQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGdldE1vdXNlRGVsdGEoKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgICByZXR1cm4geyAuLi50aGlzLm1vdXNlRGVsdGEgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dFN0YXRlKCk6IElucHV0U3RhdGUge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiBuZXcgU2V0KHRoaXMua2V5cyksXG4gICAgICBtb3VzZToge1xuICAgICAgICB4OiB0aGlzLm1vdXNlUG9zaXRpb24ueCxcbiAgICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICAgIGRlbHRhWDogdGhpcy5tb3VzZURlbHRhLngsXG4gICAgICAgIGRlbHRhWTogdGhpcy5tb3VzZURlbHRhLnksXG4gICAgICAgIGJ1dHRvbnM6IG5ldyBTZXQodGhpcy5tb3VzZUJ1dHRvbnMpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNoZWNrRG91YmxlVGFwKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qga2V5TG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB0aW1pbmcgPSB0aGlzLmtleVRpbWluZ3MuZ2V0KGtleUxvd2VyKTtcbiAgICBcbiAgICBpZiAoIXRpbWluZykgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICAvLyBPbmx5IHJldHVybiB0cnVlIGlmIHdlIGhhdmUgYSB2YWxpZCBkb3VibGUtdGFwIHNlcXVlbmNlOlxuICAgIC8vIDEuIFdlIGhhdmUgYSB2YWxpZCBmaXJzdCB0YXAgKHByZXNzICsgcmVsZWFzZSlcbiAgICAvLyAyLiBXZSdyZSBjdXJyZW50bHkgaW4gYSBkb3VibGUtdGFwIHNlcXVlbmNlXG4gICAgLy8gMy4gVGhlIHNlY29uZCBwcmVzcyBoYXBwZW5lZCB3aXRoaW4gdGhlIHRocmVzaG9sZCBhZnRlciB0aGUgZmlyc3QgcmVsZWFzZVxuICAgIGlmICh0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiBcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSAmJiBcbiAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZSA+IDApIHtcbiAgICAgIFxuICAgICAgY29uc3QgdGltZUJldHdlZW5UYXBzID0gdGltaW5nLnNlY29uZFByZXNzVGltZSAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgcmV0dXJuIHRpbWVCZXR3ZWVuVGFwcyA8PSB0aGlzLkRPVUJMRV9UQVBfVEhSRVNIT0xEO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgcmVzZXREb3VibGVUYXAoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIGlmICh0aW1pbmcpIHtcbiAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IDA7XG4gICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gMDtcbiAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAvLyBSZXNldCBtb3VzZSBkZWx0YSBlYWNoIGZyYW1lXG4gICAgdGhpcy5tb3VzZURlbHRhLnggPSAwO1xuICAgIHRoaXMubW91c2VEZWx0YS55ID0gMDtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBvbGQgdGltaW5nIGVudHJpZXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICB0aGlzLmNsZWFudXBPbGRUaW1pbmdzKCk7XG4gIH1cbiAgXG4gIHByaXZhdGUgY2xlYW51cE9sZFRpbWluZ3MoKTogdm9pZCB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBDTEVBTlVQX1RIUkVTSE9MRCA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuICAgIGNvbnN0IGtleXNUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBVc2UgZm9yRWFjaCBpbnN0ZWFkIG9mIGZvci4uLm9mIHRvIGF2b2lkIEVTMjAxNSBpdGVyYXRpb24gaXNzdWVzXG4gICAgdGhpcy5rZXlUaW1pbmdzLmZvckVhY2goKHRpbWluZywga2V5KSA9PiB7XG4gICAgICAvLyBSZW1vdmUgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiB1c2VkIGluIGEgd2hpbGVcbiAgICAgIGNvbnN0IGxhc3RBY3Rpdml0eSA9IE1hdGgubWF4KFxuICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUsIFxuICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSwgXG4gICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWVcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChsYXN0QWN0aXZpdHkgPiAwICYmIG5vdyAtIGxhc3RBY3Rpdml0eSA+IENMRUFOVVBfVEhSRVNIT0xEKSB7XG4gICAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRGVsZXRlIHRoZSBrZXlzIGFmdGVyIGl0ZXJhdGlvbiB0byBhdm9pZCBtb2RpZnlpbmcgbWFwIGR1cmluZyBpdGVyYXRpb25cbiAgICBrZXlzVG9EZWxldGUuZm9yRWFjaChrZXkgPT4gdGhpcy5rZXlUaW1pbmdzLmRlbGV0ZShrZXkpKTtcbiAgfVxuICBcbiAgLy8gRGVidWcgbWV0aG9kIHRvIGhlbHAgdHJhY2sgZG91YmxlIHRhcCBkZXRlY3Rpb25cbiAgcHVibGljIGdldERvdWJsZVRhcERlYnVnSW5mbyhrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3Qga2V5TG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB0aW1pbmcgPSB0aGlzLmtleVRpbWluZ3MuZ2V0KGtleUxvd2VyKTtcbiAgICBcbiAgICBpZiAoIXRpbWluZykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBrZXlMb3dlcixcbiAgICAgIGZpcnN0UHJlc3NUaW1lOiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUsXG4gICAgICBmaXJzdFJlbGVhc2VUaW1lOiB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSxcbiAgICAgIHNlY29uZFByZXNzVGltZTogdGltaW5nLnNlY29uZFByZXNzVGltZSxcbiAgICAgIGhhc1ZhbGlkRmlyc3RUYXA6IHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwLFxuICAgICAgaXNJbkRvdWJsZVRhcFNlcXVlbmNlOiB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlLFxuICAgICAgdGltZVNpbmNlRmlyc3RQcmVzczogdGltaW5nLmZpcnN0UHJlc3NUaW1lID4gMCA/IG5vdyAtIHRpbWluZy5maXJzdFByZXNzVGltZSA6IDAsXG4gICAgICB0aW1lU2luY2VGaXJzdFJlbGVhc2U6IHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID4gMCA/IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lIDogMCxcbiAgICAgIHRpbWVTaW5jZVNlY29uZFByZXNzOiB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID4gMCA/IG5vdyAtIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgOiAwLFxuICAgICAgdGhyZXNob2xkOiB0aGlzLkRPVUJMRV9UQVBfVEhSRVNIT0xEXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgICAvLyBLZXlib2FyZCBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBNb3VzZSBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcyksIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgICAvLyBQb2ludGVyIGxvY2sgZXZlbnRzXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxvY2tjaGFuZ2UnLCB0aGlzLm9uUG9pbnRlckxvY2tDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxvY2tlcnJvcicsIHRoaXMub25Qb2ludGVyTG9ja0Vycm9yLmJpbmQodGhpcykpO1xuXG4gICAgLy8gUHJldmVudCBjb250ZXh0IG1lbnVcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuXG4gICAgLy8gSGFuZGxlIHdpbmRvdyBmb2N1cy9ibHVyIHRvIHJlc2V0IGlucHV0IHN0YXRlXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLm9uV2luZG93Qmx1ci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLm9uV2luZG93Rm9jdXMuYmluZCh0aGlzKSk7XG4gIH1cblxuICBwcml2YXRlIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgIFxuICAgIGlmICghdGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuYWRkKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleURvd24nLCB7IGtleTogZXZlbnQua2V5LCBjb2RlOiBldmVudC5jb2RlIH0pO1xuXG4gICAgICAvLyBUcmFjayBrZXkgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCB0aW1pbmcgPSB0aGlzLmtleVRpbWluZ3MuZ2V0KGtleSk7XG4gICAgICBcbiAgICAgIGlmICghdGltaW5nKSB7XG4gICAgICAgIHRpbWluZyA9IHsgXG4gICAgICAgICAgZmlyc3RQcmVzc1RpbWU6IDAsIFxuICAgICAgICAgIGZpcnN0UmVsZWFzZVRpbWU6IDAsIFxuICAgICAgICAgIHNlY29uZFByZXNzVGltZTogMCxcbiAgICAgICAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgIGhhc1ZhbGlkRmlyc3RUYXA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMua2V5VGltaW5ncy5zZXQoa2V5LCB0aW1pbmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgZG91YmxlLXRhcCBzZXF1ZW5jZSBsb2dpY1xuICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBwcmVzc1xuICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTsgLy8gV2lsbCBiZSBzZXQgdG8gdHJ1ZSBvbiByZWxlYXNlXG4gICAgICB9IGVsc2UgaWYgKHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwICYmICF0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgdGhlIHNlY29uZCBwcmVzcyAtIGNoZWNrIGlmIGl0J3Mgd2l0aGluIHRocmVzaG9sZFxuICAgICAgICBjb25zdCB0aW1lU2luY2VGaXJzdFJlbGVhc2UgPSBub3cgLSB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZTtcbiAgICAgICAgaWYgKHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA8PSB0aGlzLkRPVUJMRV9UQVBfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgLy8gVmFsaWQgc2Vjb25kIHByZXNzXG4gICAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUb28gbGF0ZSBmb3IgZG91YmxlLXRhcCwgdHJlYXQgYXMgbmV3IGZpcnN0IHByZXNzXG4gICAgICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gMDtcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gMDtcbiAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBmb3IgZ2FtZSBrZXlzXG4gICAgaWYgKHRoaXMuaXNHYW1lS2V5KGtleSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbktleVVwKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKHRoaXMua2V5cy5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5rZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgdGhpcy5lbWl0KCdrZXlVcCcsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSByZWxlYXNlIHRpbWluZyBmb3IgZG91YmxlLXRhcCBkZXRlY3Rpb25cbiAgICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIGlmICh0aW1pbmcpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgdGltaW5nLmZpcnN0UHJlc3NUaW1lID4gMCkge1xuICAgICAgICAgIC8vIFRoaXMgY29tcGxldGVzIHRoZSBmaXJzdCB0YXBcbiAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IG5vdztcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSkge1xuICAgICAgICAgIC8vIFRoaXMgY29tcGxldGVzIHRoZSBkb3VibGUtdGFwIHNlcXVlbmNlXG4gICAgICAgICAgLy8gVGhlIGRvdWJsZS10YXAgZGV0ZWN0aW9uIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWRcbiAgICAgICAgICAvLyBSZXNldCBmb3IgbmV4dCBwb3RlbnRpYWwgc2VxdWVuY2VcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aW1pbmcpIHtcbiAgICAgICAgICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gMDtcbiAgICAgICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gMDtcbiAgICAgICAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMCk7IC8vIFNtYWxsIGRlbGF5IHRvIGFsbG93IGRhc2ggc3lzdGVtIHRvIHByb2Nlc3NcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZURvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5hZGQoZXZlbnQuYnV0dG9uKTtcbiAgICB0aGlzLmVtaXQoJ21vdXNlRG93bicsIHtcbiAgICAgIGJ1dHRvbjogZXZlbnQuYnV0dG9uLFxuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uTW91c2VVcChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmRlbGV0ZShldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VVcCcsIHtcbiAgICAgIGJ1dHRvbjogZXZlbnQuYnV0dG9uLFxuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNQb2ludGVyTG9ja2VkKSB7XG4gICAgICAvLyBVc2UgbW92ZW1lbnQgZGVsdGFzIHdoZW4gcG9pbnRlciBpcyBsb2NrZWRcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGV2ZW50Lm1vdmVtZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIGFic29sdXRlIHBvc2l0aW9uIHdoZW4gbm90IGxvY2tlZFxuICAgICAgdGhpcy5wcmV2aW91c01vdXNlUG9zaXRpb24ueCA9IHRoaXMubW91c2VQb3NpdGlvbi54O1xuICAgICAgdGhpcy5wcmV2aW91c01vdXNlUG9zaXRpb24ueSA9IHRoaXMubW91c2VQb3NpdGlvbi55O1xuICAgICAgdGhpcy5tb3VzZVBvc2l0aW9uLnggPSBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy5tb3VzZVBvc2l0aW9uLnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGVsdGEgZnJvbSBwcmV2aW91cyBwb3NpdGlvblxuICAgICAgY29uc3QgZGVsdGFYID0gdGhpcy5tb3VzZVBvc2l0aW9uLnggLSB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54O1xuICAgICAgY29uc3QgZGVsdGFZID0gdGhpcy5tb3VzZVBvc2l0aW9uLnkgLSB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55O1xuICAgICAgXG4gICAgICAvLyBBY2N1bXVsYXRlIGRlbHRhIGZvciB0aGlzIGZyYW1lXG4gICAgICB0aGlzLm1vdXNlRGVsdGEueCArPSBkZWx0YVg7XG4gICAgICB0aGlzLm1vdXNlRGVsdGEueSArPSBkZWx0YVk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdtb3VzZU1vdmUnLCB7XG4gICAgICB4OiB0aGlzLm1vdXNlUG9zaXRpb24ueCxcbiAgICAgIHk6IHRoaXMubW91c2VQb3NpdGlvbi55LFxuICAgICAgZGVsdGFYOiB0aGlzLm1vdXNlRGVsdGEueCxcbiAgICAgIGRlbHRhWTogdGhpcy5tb3VzZURlbHRhLnksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uV2hlZWwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXQoJ3doZWVsJywge1xuICAgICAgZGVsdGFYOiBldmVudC5kZWx0YVgsXG4gICAgICBkZWx0YVk6IGV2ZW50LmRlbHRhWSxcbiAgICAgIGRlbHRhWjogZXZlbnQuZGVsdGFaLFxuICAgIH0pO1xuICAgIFxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBwcml2YXRlIG9uUG9pbnRlckxvY2tDaGFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc1BvaW50ZXJMb2NrZWQgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgIT09IG51bGw7XG4gIH1cblxuICBwcml2YXRlIG9uUG9pbnRlckxvY2tFcnJvcigpOiB2b2lkIHtcbiAgICBjb25zb2xlLndhcm4oJ1BvaW50ZXIgbG9jayBmYWlsZWQnKTtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0JsdXIoKTogdm9pZCB7XG4gICAgLy8gQ2xlYXIgYWxsIGlucHV0IHN0YXRlIHdoZW4gd2luZG93IGxvc2VzIGZvY3VzXG4gICAgdGhpcy5rZXlzLmNsZWFyKCk7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmtleVRpbWluZ3MuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaW5kb3dGb2N1cygpOiB2b2lkIHtcbiAgICAvLyBSZXNldCBtb3VzZSBkZWx0YSB3aGVuIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gICAgdGhpcy5tb3VzZURlbHRhLnggPSAwO1xuICAgIHRoaXMubW91c2VEZWx0YS55ID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgaXNHYW1lS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gRGVmaW5lIHdoaWNoIGtleXMgc2hvdWxkIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBwcmV2ZW50ZWRcbiAgICBjb25zdCBnYW1lS2V5cyA9IFsndycsICdhJywgJ3MnLCAnZCcsICcgJywgJ3NoaWZ0JywgJ3RhYicsICdlc2NhcGUnXTtcbiAgICByZXR1cm4gZ2FtZUtleXMuaW5jbHVkZXMoa2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIFJlbW92ZSBkb2N1bWVudCBldmVudCBsaXN0ZW5lcnNcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLm9uV2luZG93Qmx1ci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLm9uV2luZG93Rm9jdXMuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBSZW1vdmUgY2FudmFzIGV2ZW50IGxpc3RlbmVycyBpZiBjYW52YXMgZXhpc3RzXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIHN0YXRlXG4gICAgdGhpcy5rZXlzLmNsZWFyKCk7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmtleVRpbWluZ3MuY2xlYXIoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiSW5wdXRNYW5hZ2VyIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbk1vdXNlRG93biIsImJpbmQiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTW92ZSIsIm9uV2hlZWwiLCJwYXNzaXZlIiwiZSIsInByZXZlbnREZWZhdWx0IiwicmVxdWVzdFBvaW50ZXJMb2NrIiwiZXhpdFBvaW50ZXJMb2NrIiwiZG9jdW1lbnQiLCJpc0tleVByZXNzZWQiLCJrZXkiLCJrZXlzIiwiaGFzIiwidG9Mb3dlckNhc2UiLCJpc01vdXNlQnV0dG9uUHJlc3NlZCIsImJ1dHRvbiIsIm1vdXNlQnV0dG9ucyIsImdldE1vdXNlUG9zaXRpb24iLCJtb3VzZVBvc2l0aW9uIiwiZ2V0TW91c2VEZWx0YSIsIm1vdXNlRGVsdGEiLCJnZXRJbnB1dFN0YXRlIiwiU2V0IiwibW91c2UiLCJ4IiwieSIsImRlbHRhWCIsImRlbHRhWSIsImJ1dHRvbnMiLCJjaGVja0RvdWJsZVRhcCIsImtleUxvd2VyIiwidGltaW5nIiwia2V5VGltaW5ncyIsImdldCIsIm5vdyIsIkRhdGUiLCJoYXNWYWxpZEZpcnN0VGFwIiwiaXNJbkRvdWJsZVRhcFNlcXVlbmNlIiwic2Vjb25kUHJlc3NUaW1lIiwidGltZUJldHdlZW5UYXBzIiwiZmlyc3RSZWxlYXNlVGltZSIsIkRPVUJMRV9UQVBfVEhSRVNIT0xEIiwicmVzZXREb3VibGVUYXAiLCJmaXJzdFByZXNzVGltZSIsInVwZGF0ZSIsImNsZWFudXBPbGRUaW1pbmdzIiwiQ0xFQU5VUF9USFJFU0hPTEQiLCJrZXlzVG9EZWxldGUiLCJmb3JFYWNoIiwibGFzdEFjdGl2aXR5IiwiTWF0aCIsIm1heCIsInB1c2giLCJkZWxldGUiLCJnZXREb3VibGVUYXBEZWJ1Z0luZm8iLCJ0aW1lU2luY2VGaXJzdFByZXNzIiwidGltZVNpbmNlRmlyc3RSZWxlYXNlIiwidGltZVNpbmNlU2Vjb25kUHJlc3MiLCJ0aHJlc2hvbGQiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwib25LZXlEb3duIiwib25LZXlVcCIsIm9uUG9pbnRlckxvY2tDaGFuZ2UiLCJvblBvaW50ZXJMb2NrRXJyb3IiLCJ3aW5kb3ciLCJvbldpbmRvd0JsdXIiLCJvbldpbmRvd0ZvY3VzIiwiZXZlbnQiLCJhZGQiLCJlbWl0IiwiY29kZSIsInNldCIsImlzR2FtZUtleSIsInNldFRpbWVvdXQiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzUG9pbnRlckxvY2tlZCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsInByZXZpb3VzTW91c2VQb3NpdGlvbiIsImRlbHRhWiIsInBvaW50ZXJMb2NrRWxlbWVudCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYXIiLCJnYW1lS2V5cyIsImluY2x1ZGVzIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {}\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {}\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n            // Only warn if it's not a minified single-letter class name\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {}\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        const components = Array.from(this.components.values());\n        for (const comp of components){\n            if (comp instanceof componentType) {\n                return true;\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRU9DLFdBQW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDQyxNQUFNO0lBQ3BCO0lBRU9DLFVBQVVELE1BQWUsRUFBUTtRQUN0QyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7SUFDaEI7SUFFT0UsVUFBZ0I7UUFDckIsSUFBSSxDQUFDN0IsVUFBVSxDQUFDOEIsS0FBSztRQUNyQixJQUFJLENBQUNILE1BQU0sR0FBRztJQUNoQjtJQXZHQTdCLGFBQWM7YUFITkUsYUFBYSxJQUFJK0I7YUFDakJKLFNBQVM7UUFHZixJQUFJLENBQUNLLEVBQUUsR0FBR3ZDLE9BQU93QyxNQUFNO0lBQ3pCO0FBc0dGO0FBOUdheEMsT0FDSXdDLFNBQW1CO0FBK0c3QixNQUFlQzs7YUFDYkMsVUFBVTs7QUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9FbnRpdHkudHM/NWYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEVudGl0eSBNYW5hZ2VtZW50XG5leHBvcnQgdHlwZSBFbnRpdHlJZCA9IG51bWJlcjtcblxuZXhwb3J0IGNsYXNzIEVudGl0eSB7XG4gIHByaXZhdGUgc3RhdGljIG5leHRJZDogRW50aXR5SWQgPSAxO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IEVudGl0eUlkO1xuICBwcml2YXRlIGNvbXBvbmVudHMgPSBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50PigpO1xuICBwcml2YXRlIGFjdGl2ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IEVudGl0eS5uZXh0SWQrKztcbiAgfVxuXG4gIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50OiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzLmdldChyZXF1ZXN0ZWRUeXBlKTtcbiAgICBcbiAgICAvLyBJZiBub3QgZm91bmQgd2l0aCBleHBsaWNpdCB0eXBlLCB0cnkgc2VhcmNoaW5nIGJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoIWNvbXBvbmVudCAmJiAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgY29tcG9uZW50cyB0byBmaW5kIGEgbWF0Y2ggYnkgdHlwZVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMuZW50cmllcygpKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgY29tcF0gb2YgZW50cmllcykge1xuICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgaW5zdGFuY2VvZiBmYWxsYmFjayB1c2FnZVxuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkgeyAvLyBPbmx5IGxvZyAxJSBvZiB0aGUgdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSAoY29tcG9uZW50IGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChhY3R1YWxUeXBlICE9PSByZXF1ZXN0ZWRUeXBlICYmICFjb21wb25lbnQuY29uc3RydWN0b3IubmFtZS5tYXRjaCgvXlthLXpdJC8pKSB7XG4gICAgICAgIC8vIE9ubHkgd2FybiBpZiBpdCdzIG5vdCBhIG1pbmlmaWVkIHNpbmdsZS1sZXR0ZXIgY2xhc3MgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgbWlzc2luZyBjb21wb25lbnRzXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7IC8vIE9ubHkgbG9nIDAuMSUgb2YgdGhlIHRpbWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbXBvbmVudCBhcyBUO1xuICB9XG5cbiAgcHVibGljIGhhc0NvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IGJvb2xlYW4ge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHJlcXVlc3RlZFR5cGUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIENoZWNrIHdpdGggZXhwbGljaXQgdHlwZSBmaXJzdFxuICAgIGlmICh0aGlzLmNvbXBvbmVudHMuaGFzKHJlcXVlc3RlZFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kIHdpdGggZXhwbGljaXQgdHlwZSwgdHJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlICYmIHRoaXMuY29tcG9uZW50cy5oYXMoY29tcG9uZW50VHlwZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBjb25zdCBjb21wb25lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wb25lbnRzKSB7XG4gICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzOiAobmV3ICgpID0+IENvbXBvbmVudClbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjb21wb25lbnRUeXBlcy5ldmVyeSh0eXBlID0+IHRoaXMuaGFzQ29tcG9uZW50KHR5cGUpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIGdldENvbXBvbmVudE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMua2V5cygpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gIH1cblxuICBwdWJsaWMgc2V0QWN0aXZlKGFjdGl2ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb21wb25lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbiAgcHVibGljIGVuYWJsZWQgPSB0cnVlO1xuICBcbiAgcHVibGljIGFic3RyYWN0IHJlc2V0KCk6IHZvaWQ7IC8vIEZvciBvYmplY3QgcG9vbGluZ1xufVxuIl0sIm5hbWVzIjpbIkVudGl0eSIsImFkZENvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJjb21wb25lbnRUeXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29tcG9uZW50cyIsInNldCIsInJlbW92ZUNvbXBvbmVudCIsImRlbGV0ZSIsImdldENvbXBvbmVudCIsInJlcXVlc3RlZFR5cGUiLCJnZXQiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwia2V5IiwiY29tcCIsIk1hdGgiLCJyYW5kb20iLCJhY3R1YWxUeXBlIiwibWF0Y2giLCJoYXNDb21wb25lbnQiLCJoYXMiLCJ2YWx1ZXMiLCJoYXNDb21wb25lbnRzIiwiY29tcG9uZW50VHlwZXMiLCJldmVyeSIsInR5cGUiLCJnZXRBbGxDb21wb25lbnRzIiwiZ2V0Q29tcG9uZW50TmFtZXMiLCJrZXlzIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJkZXN0cm95IiwiY2xlYXIiLCJNYXAiLCJpZCIsIm5leHRJZCIsIkNvbXBvbmVudCIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBRTtnQkFDakNEO2FBQUFBLG9CQUFBQSxPQUFPMEIsU0FBUyxjQUFoQjFCLHdDQUFBQSx1QkFBQUE7UUFDRjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUQsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQzNDLGFBQWEsQ0FBQzJDLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUMxQyxjQUFjLENBQUMwQyxNQUFNLEdBQUc7UUFFN0Isd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3JCLGNBQWMsQ0FBQ2lDLEtBQUs7UUFFekIsZUFBZTtRQUNmLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxLQUFLO0lBQ25COzthQTNOUTlFLFdBQVcsSUFBSStFO2FBQ2Z0RSxVQUFvQixFQUFFO2FBQ3RCYyxnQkFBZ0MsRUFBRTthQUNsQ0MsaUJBQWtDLEVBQUU7YUFDcENxQixpQkFBaUIsSUFBSWtDO2FBQ3JCMUUsb0JBQWdDLEVBQUU7YUFDbENxRSxTQUFTLElBQUlLOztBQXNOdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9Xb3JsZC50cz8zMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gV29ybGQgTWFuYWdlbWVudFxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlJZCwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgU3lzdGVtLCBSZW5kZXJTeXN0ZW0sIFBoeXNpY3NTeXN0ZW0gfSBmcm9tICcuL1N5c3RlbSc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuZXhwb3J0IGNsYXNzIFdvcmxkIHtcbiAgcHJpdmF0ZSBlbnRpdGllcyA9IG5ldyBNYXA8RW50aXR5SWQsIEVudGl0eT4oKTtcbiAgcHJpdmF0ZSBzeXN0ZW1zOiBTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHJlbmRlclN5c3RlbXM6IFJlbmRlclN5c3RlbVtdID0gW107XG4gIHByaXZhdGUgcGh5c2ljc1N5c3RlbXM6IFBoeXNpY3NTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudFBvb2xzID0gbmV3IE1hcDxzdHJpbmcsIE9iamVjdFBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSBlbnRpdGllc1RvRGVzdHJveTogRW50aXR5SWRbXSA9IFtdO1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcblxuICAvLyBFbnRpdHkgbWFuYWdlbWVudFxuICBwdWJsaWMgY3JlYXRlRW50aXR5KCk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSgpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lFbnRpdHkoZW50aXR5SWQ6IEVudGl0eUlkKTogdm9pZCB7XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5wdXNoKGVudGl0eUlkKTtcbiAgfVxuXG4gIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgYW4gZW50aXR5IGhhcyBiZWVuIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIGlzIHJlYWR5XG4gIHB1YmxpYyBub3RpZnlFbnRpdHlBZGRlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eUFkZGVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLm9uRW50aXR5QWRkZWQoZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IEVudGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxFbnRpdGllcygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTeXN0ZW0gbWFuYWdlbWVudFxuICBwdWJsaWMgYWRkU3lzdGVtKHN5c3RlbTogU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFJlbmRlclN5c3RlbSkge1xuICAgICAgdGhpcy5yZW5kZXJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFBoeXNpY3NTeXN0ZW0pIHtcbiAgICAgIHRoaXMucGh5c2ljc1N5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIHN5c3RlbS5vbkVuYWJsZT8uKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtPFQgZXh0ZW5kcyBTeXN0ZW0+KHN5c3RlbUNsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3lzdGVtcy5maW5kKHN5c3RlbSA9PiBzeXN0ZW0gaW5zdGFuY2VvZiBzeXN0ZW1DbGFzcykgYXMgVCB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTeXN0ZW0oc3lzdGVtVHlwZTogbmV3ICgpID0+IFN5c3RlbSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbXNbaW5kZXhdO1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gc3BlY2lhbGl6ZWQgYXJyYXlzXG4gICAgICBjb25zdCByZW5kZXJJbmRleCA9IHRoaXMucmVuZGVyU3lzdGVtcy5maW5kSW5kZXgocyA9PiBzID09PSBzeXN0ZW0pO1xuICAgICAgaWYgKHJlbmRlckluZGV4ICE9PSAtMSkgdGhpcy5yZW5kZXJTeXN0ZW1zLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG5cbiAgICAgIGNvbnN0IHBoeXNpY3NJbmRleCA9IHRoaXMucGh5c2ljc1N5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChwaHlzaWNzSW5kZXggIT09IC0xKSB0aGlzLnBoeXNpY3NTeXN0ZW1zLnNwbGljZShwaHlzaWNzSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBvbmVudCBwb29saW5nIGZvciBwZXJmb3JtYW5jZVxuICBwdWJsaWMgY3JlYXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgdHlwZU5hbWUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIERpc2FibGUgcG9vbGluZyBmb3IgY29tcG9uZW50cyB0aGF0IGhhdmUgcHJvdG90eXBlIG1ldGhvZCBpc3N1ZXMgaW4gcHJvZHVjdGlvblxuICAgIGNvbnN0IHByb2JsZW1hdGljQ29tcG9uZW50cyA9IFsnSGVhbHRoJywgJ0hlYWx0aEJhcicsICdUcmFuc2Zvcm0nLCAnTW92ZW1lbnQnLCAnQ29sbGlkZXInLCAnUmVuZGVyZXInLCAnRW5lbXknLCAnUHJvamVjdGlsZScsICdBbmltYXRpb24nXTtcbiAgICBpZiAocHJvYmxlbWF0aWNDb21wb25lbnRzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnRUeXBlKCk7XG4gICAgfVxuICAgIFxuICAgIGxldCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQodHlwZU5hbWUpO1xuICAgIFxuICAgIGlmICghcG9vbCkge1xuICAgICAgcG9vbCA9IG5ldyBPYmplY3RQb29sPFQ+KCgpID0+IG5ldyBjb21wb25lbnRUeXBlKCksIChvYmopID0+IG9iai5yZXNldCgpLCAxMDApO1xuICAgICAgdGhpcy5jb21wb25lbnRQb29scy5zZXQodHlwZU5hbWUsIHBvb2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9vbC5hY3F1aXJlKCk7XG4gIH1cblxuICBwdWJsaWMgcmV0dXJuQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmNvbXBvbmVudFBvb2xzLmdldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHBvb2wucmVsZWFzZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1haW4gdXBkYXRlIGxvb3BcbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICAgIHRoaXMuY2xlYW51cERlc3Ryb3llZEVudGl0aWVzKCk7XG5cbiAgICAvLyBVcGRhdGUgYWxsIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnVwZGF0ZShtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHBoeXNpY3MgdXBkYXRlXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5waHlzaWNzU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0uZml4ZWRVcGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB1cGRhdGVcbiAgcHVibGljIHJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucmVuZGVyU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ucmVuZGVyKG1hdGNoaW5nRW50aXRpZXMsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggYSBzeXN0ZW0ncyByZXF1aXJlbWVudHNcbiAgcHJpdmF0ZSBnZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKSB7XG4gICAgICBpZiAoc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICBwcml2YXRlIGNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgLy8gTm90aWZ5IHN5c3RlbXMgYWJvdXQgZW50aXR5IHJlbW92YWxcbiAgICAgICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eVJlbW92ZWQgJiYgc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICAgICAgc3lzdGVtLm9uRW50aXR5UmVtb3ZlZChlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGNvbXBvbmVudHMgdG8gcG9vbHNcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmdldEFsbENvbXBvbmVudHMoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gUXVlcnkgZW50aXRpZXMgYnkgY29tcG9uZW50c1xuICBwdWJsaWMgcXVlcnlFbnRpdGllcyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzKSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIEV2ZW50IHN5c3RlbVxuICBwdWJsaWMgZW1pdEV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudERhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSkhLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIHx8IFtdO1xuICB9XG5cbiAgcHVibGljIGNsZWFyRXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgW10pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGVudGl0aWVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYW4gdXAgc3lzdGVtc1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVuZGVyU3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGh5c2ljc1N5c3RlbXMubGVuZ3RoID0gMDtcblxuICAgIC8vIENsZWFyIGNvbXBvbmVudCBwb29sc1xuICAgIHRoaXMuY29tcG9uZW50UG9vbHMuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBDbGVhciBldmVudHNcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSIsIk9iamVjdFBvb2wiLCJXb3JsZCIsImNyZWF0ZUVudGl0eSIsImVudGl0eSIsImVudGl0aWVzIiwic2V0IiwiaWQiLCJkZXN0cm95RW50aXR5IiwiZW50aXR5SWQiLCJlbnRpdGllc1RvRGVzdHJveSIsInB1c2giLCJub3RpZnlFbnRpdHlBZGRlZCIsInN5c3RlbSIsInN5c3RlbXMiLCJvbkVudGl0eUFkZGVkIiwibWF0Y2hlc0VudGl0eSIsImdldEVudGl0eSIsImdldCIsImdldEFsbEVudGl0aWVzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYWRkU3lzdGVtIiwic29ydCIsImEiLCJiIiwicHJpb3JpdHkiLCJyZW5kZXJTeXN0ZW1zIiwicGh5c2ljc1N5c3RlbXMiLCJvbkVuYWJsZSIsImdldFN5c3RlbSIsInN5c3RlbUNsYXNzIiwiZmluZCIsInJlbW92ZVN5c3RlbSIsInN5c3RlbVR5cGUiLCJpbmRleCIsImZpbmRJbmRleCIsInMiLCJvbkRpc2FibGUiLCJzcGxpY2UiLCJyZW5kZXJJbmRleCIsInBoeXNpY3NJbmRleCIsImNyZWF0ZUNvbXBvbmVudCIsImNvbXBvbmVudFR5cGUiLCJ0eXBlTmFtZSIsIm5hbWUiLCJwcm9ibGVtYXRpY0NvbXBvbmVudHMiLCJpbmNsdWRlcyIsInBvb2wiLCJjb21wb25lbnRQb29scyIsIm9iaiIsInJlc2V0IiwiYWNxdWlyZSIsInJldHVybkNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsInVwZGF0ZSIsImRlbHRhVGltZSIsImNsZWFudXBEZXN0cm95ZWRFbnRpdGllcyIsImVuYWJsZWQiLCJtYXRjaGluZ0VudGl0aWVzIiwiZ2V0RW50aXRpZXNGb3JTeXN0ZW0iLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwicmVuZGVyIiwib25FbnRpdHlSZW1vdmVkIiwiZ2V0QWxsQ29tcG9uZW50cyIsImRlc3Ryb3kiLCJkZWxldGUiLCJsZW5ndGgiLCJxdWVyeUVudGl0aWVzIiwiY29tcG9uZW50VHlwZXMiLCJpc0FjdGl2ZSIsImhhc0NvbXBvbmVudHMiLCJlbWl0RXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJldmVudHMiLCJoYXMiLCJnZXRFdmVudHMiLCJjbGVhckV2ZW50cyIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        return clone;\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQWtFMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixF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SUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO0lBQzdCO0FBcVBGO0FBclRhL0MsTUFDWWlFLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBFbmVteVR5cGUgPSBFbmVteVR5cGUuRFVNTVksXG4gICAgbGV2ZWw6IG51bWJlciA9IDFcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmlzQWdncmVzc2l2ZSA9IHR5cGUgIT09IEVuZW15VHlwZS5EVU1NWTtcbiAgICB0aGlzLmFnZ3JvUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tSYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tDb29sZG93bigpO1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMuY2FsY3VsYXRlTW92ZW1lbnRTcGVlZCgpO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMucmVzcGF3blRpbWUgPSAzMDsgLy8gMzAgc2Vjb25kcyBkZWZhdWx0IHJlc3Bhd24gdGltZVxuICAgIHRoaXMuY2FuUmVzcGF3biA9IHRydWU7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBmcmVlemUgc3RhdHVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VFeHAgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogNSxcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxMCxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAyNSxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VFeHBbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhZ2dyb1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogOCxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEyXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja1JhbmdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVJhbmdlID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDIsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAzXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VEYW1hZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBkZWFsIGRhbWFnZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDE1LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogNTBcbiAgICB9O1xuICAgIHJldHVybiBiYXNlRGFtYWdlW3RoaXMudHlwZV0gKiB0aGlzLmxldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdHRhY2tDb29sZG93bigpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VDb29sZG93biA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGF0dGFja1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDIsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VDb29sZG93blt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVNwZWVkID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgbW92ZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDMsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMCwgLy8gRWxpdGUgZW5lbWllcyBhcmUgc3RhdGlvbmFyeSBsaWtlIHRyYWluaW5nIGR1bW1pZXNcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDIuNVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VTcGVlZFt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWdncmVzc2l2ZSB8fCB0aGlzLmlzRGVhZCB8fCB0aGlzLmF0dGFja0RhbWFnZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgdGFrZURhbWFnZSgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgSGVhbHRoIGNvbXBvbmVudFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGZvciBlbmVteS1zcGVjaWZpYyBkYW1hZ2UgcmVhY3Rpb25zXG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FuUmVzcGF3biB8fCAhdGhpcy5pc0RlYWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMuZGVhdGhUaW1lKSA+PSB0aGlzLnJlc3Bhd25UaW1lO1xuICB9XG5cbiAgcHVibGljIHJlc3Bhd24oKTogdm9pZCB7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgLy8gQ2xlYXIgZnJlZXplIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy51bmZyZWV6ZSgpO1xuICAgIC8vIENsZWFyIHZlbm9tIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICB9XG4gIFxuICBwdWJsaWMgZnJlZXplKGR1cmF0aW9uOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RlYWQpIHJldHVybjsgLy8gQ2FuJ3QgZnJlZXplIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIC8vIFNldCBtb3ZlbWVudCBzcGVlZCB0byAwIHdoZW4gZnJvemVuXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gMDtcbiAgfVxuICBcbiAgcHVibGljIHVuZnJlZXplKCk6IHZvaWQge1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyZWV6ZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IDA7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtb3ZlbWVudCBzcGVlZFxuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNGcm96ZW4pIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmZyZWV6ZVN0YXJ0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLmZyZWV6ZUR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgfVxuICB9XG4gIFxuICBwdWJsaWMgY2FuTW92ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNGcm96ZW4gJiYgIXRoaXMuaXNEZWFkO1xuICB9XG4gIFxuICBwdWJsaWMgYXBwbHlWZW5vbShkdXJhdGlvbjogbnVtYmVyLCBkYW1hZ2VQZXJTZWNvbmQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSB2ZW5vbSB0byBkZWFkIGVuZW1pZXNcbiAgICBcbiAgICB0aGlzLmlzVmVub21vdXMgPSB0cnVlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gZGFtYWdlUGVyU2Vjb25kO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgcmVtb3ZlVmVub20oKTogdm9pZCB7XG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVmVub21TdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHsgc2hvdWxkRGVhbERhbWFnZTogYm9vbGVhbjsgZGFtYWdlOiBudW1iZXIgfSB7XG4gICAgaWYgKCF0aGlzLmlzVmVub21vdXMpIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLnZlbm9tU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMudmVub21EdXJhdGlvbikge1xuICAgICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZGVhbCBkYW1hZ2UgKGV2ZXJ5IHNlY29uZClcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0RGFtYWdlID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3REYW1hZ2UgPj0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IHRydWUsIGRhbWFnZTogdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gIH1cblxuICBwdWJsaWMgc2V0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGV2ZWwgPSBNYXRoLm1heCgxLCBuZXdMZXZlbCk7XG4gICAgdGhpcy5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5jYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICB9XG5cbiAgcHVibGljIGdldERpc3BsYXlOYW1lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06ICdUcmFpbmluZyBEdW1teScsXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogJ0dydW50JyxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAnRWxpdGUnLFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogJ0Jvc3MnXG4gICAgfTtcbiAgICByZXR1cm4gYCR7dHlwZU5hbWVzW3RoaXMudHlwZV19IChMdi4ke3RoaXMubGV2ZWx9KWA7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy50eXBlID0gRW5lbXlUeXBlLkRVTU1ZO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuaXNBZ2dyZXNzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5hZ2dyb1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBZ2dyb1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24oKTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSB0aGlzLmNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLnJlc3Bhd25UaW1lID0gMzA7XG4gICAgdGhpcy5jYW5SZXNwYXduID0gdHJ1ZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFJlc2V0IGZyZWV6ZSBzdGF0dXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZnJlZXplRHVyYXRpb24gPSAwO1xuICAgIHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5tb3ZlbWVudFNwZWVkO1xuICAgIFxuICAgIC8vIFJlc2V0IHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBFbmVteSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5lbXkodGhpcy50eXBlLCB0aGlzLmxldmVsKTtcbiAgICBjbG9uZS5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5leHBlcmllbmNlUmV3YXJkO1xuICAgIGNsb25lLmlzQWdncmVzc2l2ZSA9IHRoaXMuaXNBZ2dyZXNzaXZlO1xuICAgIGNsb25lLmFnZ3JvUmFuZ2UgPSB0aGlzLmFnZ3JvUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5yZXNwYXduVGltZSA9IHRoaXMucmVzcGF3blRpbWU7XG4gICAgY2xvbmUuY2FuUmVzcGF3biA9IHRoaXMuY2FuUmVzcGF3bjtcbiAgICBcbiAgICAvLyBDbG9uZSBmcmVlemUgc3RhdHVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyZWV6ZVN0YXJ0VGltZSA9IHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGNsb25lLmZyZWV6ZUR1cmF0aW9uID0gdGhpcy5mcmVlemVEdXJhdGlvbjtcbiAgICBjbG9uZS5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBDbG9uZSB2ZW5vbSBzdGF0dXNcbiAgICBjbG9uZS5pc1Zlbm9tb3VzID0gdGhpcy5pc1Zlbm9tb3VzO1xuICAgIGNsb25lLnZlbm9tU3RhcnRUaW1lID0gdGhpcy52ZW5vbVN0YXJ0VGltZTtcbiAgICBjbG9uZS52ZW5vbUR1cmF0aW9uID0gdGhpcy52ZW5vbUR1cmF0aW9uO1xuICAgIGNsb25lLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZDtcbiAgICBjbG9uZS5sYXN0VmVub21EYW1hZ2VUaW1lID0gdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lO1xuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkVuZW15VHlwZSIsIkVuZW15IiwiY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCIsImJhc2VFeHAiLCJ0eXBlIiwibGV2ZWwiLCJjYWxjdWxhdGVBZ2dyb1JhbmdlIiwiYmFzZVJhbmdlIiwiY2FsY3VsYXRlQXR0YWNrUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tEYW1hZ2UiLCJiYXNlRGFtYWdlIiwiY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24iLCJiYXNlQ29vbGRvd24iLCJjYWxjdWxhdGVNb3ZlbWVudFNwZWVkIiwiYmFzZVNwZWVkIiwiY2FuQXR0YWNrIiwiY3VycmVudFRpbWUiLCJpc0FnZ3Jlc3NpdmUiLCJpc0RlYWQiLCJhdHRhY2tEYW1hZ2UiLCJsYXN0QXR0YWNrVGltZSIsImF0dGFja0Nvb2xkb3duIiwicGVyZm9ybUF0dGFjayIsInRha2VEYW1hZ2UiLCJkaWUiLCJkZWF0aFRpbWUiLCJjYW5SZXNwYXduTm93IiwiY2FuUmVzcGF3biIsInJlc3Bhd25UaW1lIiwicmVzcGF3biIsInVuZnJlZXplIiwicmVtb3ZlVmVub20iLCJmcmVlemUiLCJkdXJhdGlvbiIsImlzRnJvemVuIiwiZnJlZXplU3RhcnRUaW1lIiwiZnJlZXplRHVyYXRpb24iLCJtb3ZlbWVudFNwZWVkIiwib3JpZ2luYWxNb3ZlbWVudFNwZWVkIiwidXBkYXRlRnJlZXplU3RhdHVzIiwiZWxhcHNlZCIsImNhbk1vdmUiLCJhcHBseVZlbm9tIiwiZGFtYWdlUGVyU2Vjb25kIiwiaXNWZW5vbW91cyIsInZlbm9tU3RhcnRUaW1lIiwidmVub21EdXJhdGlvbiIsInZlbm9tRGFtYWdlUGVyU2Vjb25kIiwibGFzdFZlbm9tRGFtYWdlVGltZSIsInVwZGF0ZVZlbm9tU3RhdHVzIiwic2hvdWxkRGVhbERhbWFnZSIsImRhbWFnZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJzZXRMZXZlbCIsIm5ld0xldmVsIiwiTWF0aCIsIm1heCIsImV4cGVyaWVuY2VSZXdhcmQiLCJnZXREaXNwbGF5TmFtZSIsInR5cGVOYW1lcyIsInJlc2V0IiwiYWdncm9SYW5nZSIsImF0dGFja1JhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0, bypassInvulnerability = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        if (this.isDead || !bypassInvulnerability && this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQTBHO1lBQXhHQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQyx1REFBY0Msd0JBQUFBLGlFQUFpQztRQUN4SCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFLLENBQUNELHlCQUF5QixJQUFJLENBQUNFLGNBQWMsSUFBS1AsVUFBVSxHQUFHO1lBQ2pGLE9BQU87UUFDVDtRQUVBLElBQUlRLGNBQWNSO1FBRWxCLDRFQUE0RTtRQUM1RSxJQUFJSSxRQUFRO1lBQ1YsTUFBTUssU0FBU0wsT0FBT00sWUFBWSxDQUFDYiwyQ0FBTUE7WUFDekMsSUFBSVksUUFBUTtnQkFDVkQsY0FBY0MsT0FBT0UsWUFBWSxDQUFDWDtZQUNwQztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlRLGNBQWMsR0FBRztZQUNuQixJQUFJLENBQUNJLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixhQUFhLEdBQUdKO1lBQ3RELElBQUksQ0FBQ08sY0FBYyxHQUFHZDtZQUV0QiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDTSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRyxJQUFJLENBQUNDLHVCQUF1QjtZQUV4RCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNMLGFBQWEsSUFBSSxHQUFHO2dCQUMzQixJQUFJLENBQUNOLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRU9ZLEtBQUtsQixNQUFjLEVBQVc7UUFDbkMsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSU4sVUFBVSxHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUVBLE1BQU1tQixZQUFZLElBQUksQ0FBQ1As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LENBQUNELG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDK0IsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0MsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxHQUFHLGtEQUFrRDtRQUM5RSxJQUFJLENBQUN4QixjQUFjLEdBQUc7SUFDeEI7QUFpSkY7QUE1S2FqQixPQUNZc0QsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHM/NWY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggY29tcG9uZW50IGZvciBkYW1hZ2UgYW5kIGhlYWxpbmdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICcuL1NoaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGggZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0hlYWx0aCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIGN1cnJlbnRIZWFsdGg6IG51bWJlcjtcbiAgcHVibGljIG1heEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW47XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaW52dWxuZXJhYmlsaXR5VGltZXI6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGNhblJlZ2VuZXJhdGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZWdlbmVyYXRpb25SYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWdlbmVyYXRpb25EZWxheTogbnVtYmVyO1xuICBwdWJsaWMgbGFzdERhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhIZWFsdGg6IG51bWJlciA9IDEwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tYXhIZWFsdGggPSBtYXhIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gbWF4SGVhbHRoOyAvLyBBbHdheXMgc3RhcnQgd2l0aCBmdWxsIGhlYWx0aFxuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gMC41OyAvLyAwLjUgc2Vjb25kcyBvZiBpbnZ1bG5lcmFiaWxpdHkgYWZ0ZXIgZGFtYWdlXG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1OyAvLyBIZWFsdGggcGVyIHNlY29uZFxuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzOyAvLyBTZWNvbmRzIGFmdGVyIGRhbWFnZSBiZWZvcmUgcmVnZW5lcmF0aW9uIHN0YXJ0c1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHRha2VEYW1hZ2UoYW1vdW50OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpIC8gMTAwMCwgZW50aXR5PzogYW55LCBieXBhc3NJbnZ1bG5lcmFiaWxpdHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzRGVhZCB8fCAoIWJ5cGFzc0ludnVsbmVyYWJpbGl0eSAmJiB0aGlzLmlzSW52dWxuZXJhYmxlKSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICB0aGlzLm1heEhlYWx0aCA9IE1hdGgubWF4KDEsIG5ld01heEhlYWx0aCk7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aCAqIGhlYWx0aFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhSYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1heEhlYWx0aCA+IDAgPyB0aGlzLmN1cnJlbnRIZWFsdGggLyB0aGlzLm1heEhlYWx0aCA6IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0SGVhbHRoUGVyY2VudGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgKiAxMDA7XG4gIH1cblxuICBwdWJsaWMgaXNGdWxsSGVhbHRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggPj0gdGhpcy5tYXhIZWFsdGg7XG4gIH1cblxuICBwdWJsaWMgaXNMb3dIZWFsdGgodGhyZXNob2xkOiBudW1iZXIgPSAwLjI1KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgaXNDcml0aWNhbEhlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgPD0gdGhyZXNob2xkO1xuICB9XG5cbiAgcHVibGljIHJldml2ZShoZWFsdGhBbW91bnQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IGhlYWx0aEFtb3VudCAhPT0gdW5kZWZpbmVkID8gXG4gICAgICBNYXRoLm1pbih0aGlzLm1heEhlYWx0aCwgaGVhbHRoQW1vdW50KSA6IFxuICAgICAgdGhpcy5tYXhIZWFsdGg7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGludnVsbmVyYWJpbGl0eSB0aW1lclxuICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XG4gICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIGlmICh0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVnZW5lcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FuUmVnZW5lcmF0ZSAmJiAhdGhpcy5pc0RlYWQgJiYgIXRoaXMuaXNGdWxsSGVhbHRoKCkpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5KSB7XG4gICAgICAgIHRoaXMuaGVhbCh0aGlzLnJlZ2VuZXJhdGlvblJhdGUgKiBkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnZ1bG5lcmFibGUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJbnZ1bG5lcmFiaWxpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVJlZ2VuZXJhdGlvbihyYXRlOiBudW1iZXIgPSA1LCBkZWxheTogbnVtYmVyID0gMyk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25SYXRlID0gcmF0ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBwdWJsaWMgZGlzYWJsZVJlZ2VuZXJhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1O1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogSGVhbHRoIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBIZWFsdGgodGhpcy5tYXhIZWFsdGgpO1xuICAgIGNsb25lLmN1cnJlbnRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgY2xvbmUuaXNJbnZ1bG5lcmFibGUgPSB0aGlzLmlzSW52dWxuZXJhYmxlO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjtcbiAgICBjbG9uZS5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXI7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuY2FuUmVnZW5lcmF0ZSA9IHRoaXMuY2FuUmVnZW5lcmF0ZTtcbiAgICBjbG9uZS5yZWdlbmVyYXRpb25SYXRlID0gdGhpcy5yZWdlbmVyYXRpb25SYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvbkRlbGF5ID0gdGhpcy5yZWdlbmVyYXRpb25EZWxheTtcbiAgICBjbG9uZS5sYXN0RGFtYWdlVGltZSA9IHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiSGVhbHRoIiwidGFrZURhbWFnZSIsImFtb3VudCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsImJ5cGFzc0ludnVsbmVyYWJpbGl0eSIsImlzRGVhZCIsImlzSW52dWxuZXJhYmxlIiwiZmluYWxEYW1hZ2UiLCJzaGllbGQiLCJnZXRDb21wb25lbnQiLCJhYnNvcmJEYW1hZ2UiLCJjdXJyZW50SGVhbHRoIiwiTWF0aCIsIm1heCIsImxhc3REYW1hZ2VUaW1lIiwiaW52dWxuZXJhYmlsaXR5VGltZXIiLCJpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbiIsImhlYWwiLCJvbGRIZWFsdGgiLCJtaW4iLCJtYXhIZWFsdGgiLCJzZXRNYXhIZWFsdGgiLCJuZXdNYXhIZWFsdGgiLCJoZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiZmxvb3IiLCJnZXRIZWFsdGhQZXJjZW50YWdlIiwiaXNGdWxsSGVhbHRoIiwiaXNMb3dIZWFsdGgiLCJ0aHJlc2hvbGQiLCJpc0NyaXRpY2FsSGVhbHRoIiwicmV2aXZlIiwiaGVhbHRoQW1vdW50IiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2FuUmVnZW5lcmF0ZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJyZWdlbmVyYXRpb25EZWxheSIsInJlZ2VuZXJhdGlvblJhdGUiLCJzZXRJbnZ1bG5lcmFibGUiLCJkdXJhdGlvbiIsInJlbW92ZUludnVsbmVyYWJpbGl0eSIsImVuYWJsZVJlZ2VuZXJhdGlvbiIsInJhdGUiLCJkZWxheSIsImRpc2FibGVSZWdlbmVyYXRpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n        console.log(\"\\uD83E\\uDDCA Player frozen for \".concat(duration, \"ms until \").concat(this.frozenUntil, \" (current: \").concat(currentTime, \")\"));\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n        console.log(\"\\uD83D\\uDC0C Player slowed to \".concat(speedMultiplier * 100, \"% speed for \").concat(duration, \"ms until \").concat(this.slowedUntil));\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n            console.log(\"\\uD83E\\uDDCA Player unfrozen\");\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n            console.log(\"\\uD83D\\uDC0C Player no longer slowed\");\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        return this.maxSpeed * this.movementSpeedMultiplier;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.65, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBd0c5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtRQUNqQ00sUUFBUUMsR0FBRyxDQUFDLGtDQUE0QyxPQUFwQlAsVUFBUyxhQUF5Q0MsT0FBOUIsSUFBSSxDQUFDSSxXQUFXLEVBQUMsZUFBeUIsT0FBWkosYUFBWTtJQUNwRztJQUVPTyxLQUFLUixRQUFnQixFQUF1QztZQUFyQ1Msa0JBQUFBLGlFQUEwQjtRQUN0RCxNQUFNUixj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Q0gsbUJBQW1CLEdBQUcsSUFBSTNGLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztJQUMvQztBQXVXRjtBQTdjYUUsU0FDWWdILGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQudHM/MThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb3ZlbWVudCBjb21wb25lbnQgZm9yIHZlbG9jaXR5IGFuZCBtb3ZlbWVudCBwcm9wZXJ0aWVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBNb3ZlbWVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgYWNjZWxlcmF0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgbWF4U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGZyaWN0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBpc0dyb3VuZGVkOiBib29sZWFuO1xuICBwdWJsaWMganVtcEZvcmNlOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgZmxhZ3NcbiAgcHVibGljIGNhbk1vdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBjYW5KdW1wOiBib29sZWFuO1xuICBwdWJsaWMgY2FuRmx5OiBib29sZWFuO1xuXG4gIC8vIERlYnVmZiBzdGF0ZXMgZm9yIFBWUFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcm96ZW5VbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgaXNTbG93ZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyBzbG93ZWRVbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgbW92ZW1lbnRTcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblxuICAvLyBJbnB1dC1iYXNlZCBtb3ZlbWVudFxuICBwdWJsaWMgbW92ZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGlucHV0U3RyZW5ndGg6IG51bWJlcjtcblxuICAvLyBEYXNoL1ZhdWx0IHN5c3RlbVxuICBwdWJsaWMgaXNEYXNoaW5nOiBib29sZWFuO1xuICBwdWJsaWMgZGFzaERpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGRhc2hTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGRhc2hEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgZGFzaERpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoU3RhcnRQb3NpdGlvbjogVmVjdG9yMztcbiAgXG4gIC8vIE11bHRpcGxlIGRhc2ggY2hhcmdlcyBzeXN0ZW1cbiAgcHVibGljIGRhc2hDaGFyZ2VzOiBBcnJheTx7XG4gICAgaXNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgY29vbGRvd25TdGFydFRpbWU6IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICBwdWJsaWMgbWF4RGFzaENoYXJnZXM6IG51bWJlcjtcblxuICAvLyBTd29yZCBDaGFyZ2UgYWJpbGl0eSBzeXN0ZW0gKHNlcGFyYXRlIGZyb20gZGFzaGVzKVxuICBwdWJsaWMgaXNDaGFyZ2luZzogYm9vbGVhbjtcbiAgcHVibGljIGNoYXJnZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGNoYXJnZVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZURpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VTdGFydFBvc2l0aW9uOiBWZWN0b3IzO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1heFNwZWVkOiBudW1iZXIgPSAzLjY1LFxuICAgIGZyaWN0aW9uOiBudW1iZXIgPSAwLjgsXG4gICAganVtcEZvcmNlOiBudW1iZXIgPSAyMC4wLFxuICAgIGdyYXZpdHk6IG51bWJlciA9IC0xMi41XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5tYXhTcGVlZCA9IG1heFNwZWVkO1xuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBGb3JjZSA9IGp1bXBGb3JjZTtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICAgIFxuICAgIHRoaXMuY2FuTW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5KdW1wID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkZseSA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgIFxuICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG5cbiAgICAvLyBJbml0aWFsaXplIGRhc2ggcHJvcGVydGllc1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRhc2hEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGRhc2ggZHVyYXRpb24gKHNhbWUgYXMgb2xkIGltcGxlbWVudGF0aW9uKVxuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDsgLy8gSW5jcmVhc2VkIGZyb20gMy4xMjUgZm9yIG1vcmUgbm90aWNlYWJsZSBkYXNoXG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgbXVsdGlwbGUgZGFzaCBjaGFyZ2VzICgzIGNoYXJnZXMsIGVhY2ggd2l0aCA2cyBjb29sZG93bilcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIEluaXRpYWxpemUgc3dvcmQgY2hhcmdlIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTsgLy8gMzUwbXMgY2hhcmdlIGR1cmF0aW9uXG4gICAgdGhpcy5jaGFyZ2VEaXN0YW5jZSA9IDk7IC8vIFN3b3JkIGNoYXJnZSBkaXN0YW5jZVxuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGFkZEZvcmNlKGZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24uYWRkKGZvcmNlKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRJbXB1bHNlKGltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LmFkZChpbXB1bHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBqdW1wKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbkp1bXAgJiYgKHRoaXMuaXNHcm91bmRlZCB8fCB0aGlzLmNhbkZseSkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuanVtcEZvcmNlO1xuICAgICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldE1vdmVEaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzLCBzdHJlbmd0aDogbnVtYmVyID0gMS4wKTogdm9pZCB7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzdHJlbmd0aCkpO1xuICB9XG5cbiAgcHVibGljIGZyZWV6ZShkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uO1xuICAgIGNvbnNvbGUubG9nKGDwn6eKIFBsYXllciBmcm96ZW4gZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLmZyb3plblVudGlsfSAoY3VycmVudDogJHtjdXJyZW50VGltZX0pYCk7XG4gIH1cblxuICBwdWJsaWMgc2xvdyhkdXJhdGlvbjogbnVtYmVyLCBzcGVlZE11bHRpcGxpZXI6IG51bWJlciA9IDAuNSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzU2xvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gc3BlZWRNdWx0aXBsaWVyO1xuICAgIGNvbnNvbGUubG9nKGDwn5CMIFBsYXllciBzbG93ZWQgdG8gJHtzcGVlZE11bHRpcGxpZXIgKiAxMDB9JSBzcGVlZCBmb3IgJHtkdXJhdGlvbn1tcyB1bnRpbCAke3RoaXMuc2xvd2VkVW50aWx9YCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGVidWZmcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZnJvemVuIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNGcm96ZW4gJiYgY3VycmVudFRpbWUgPj0gdGhpcy5mcm96ZW5VbnRpbCkge1xuICAgICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgICBjb25zb2xlLmxvZygn8J+niiBQbGF5ZXIgdW5mcm96ZW4nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgc2xvd2VkIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNTbG93ZWQgJiYgY3VycmVudFRpbWUgPj0gdGhpcy5zbG93ZWRVbnRpbCkge1xuICAgICAgdGhpcy5pc1Nsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zbG93ZWRVbnRpbCA9IDA7XG4gICAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgICAgY29uc29sZS5sb2coJ/CfkIwgUGxheWVyIG5vIGxvbmdlciBzbG93ZWQnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgcmV0dXJuIDA7IC8vIENvbXBsZXRlbHkgZnJvemVuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1heFNwZWVkICogdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydERhc2goZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFyZ2VcbiAgICBjb25zdCBhdmFpbGFibGVDaGFyZ2VJbmRleCA9IHRoaXMuZGFzaENoYXJnZXMuZmluZEluZGV4KGNoYXJnZSA9PiBjaGFyZ2UuaXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVDaGFyZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gY2hhcmdlcyBhdmFpbGFibGVcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGFzaFxuICAgIHRoaXMuaXNEYXNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY29weShjdXJyZW50UG9zaXRpb24pO1xuXG4gICAgLy8gQ29uc3VtZSB0aGUgY2hhcmdlXG4gICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5jb29sZG93blN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IGNvb2xkb3duIHRpbWVyIGZvciB0aGlzIHNwZWNpZmljIGNoYXJnZSAoNiBzZWNvbmRzKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uY29vbGRvd25TdGFydFRpbWUgPSBudWxsO1xuICAgIH0sIDYwMDApOyAvLyA2IHNlY29uZCBjb29sZG93blxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGFzaChjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uOiBudWxsIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuZGFzaER1cmF0aW9uLCAxKTtcblxuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAvLyBEYXNoIGNvbXBsZXRlXG4gICAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHRoaXMuZGFzaERpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuZGFzaERpc3RhbmNlKSk7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiB0cnVlLCBuZXdQb3NpdGlvbjogZmluYWxQb3NpdGlvbiB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uIHVzaW5nIGVhc2luZyAoZWFzZS1vdXQgcXVhZCwgc2FtZSBhcyBvbGQgaW1wbGVtZW50YXRpb24pXG4gICAgY29uc3QgZWFzZU91dFF1YWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAyKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmRhc2hEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmRhc2hEaXN0YW5jZSAqIGVhc2VPdXRRdWFkKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKS5hZGQoZGlzcGxhY2VtZW50KTtcblxuICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGNhbmNlbERhc2goKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkubGVuZ3RoKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnZlbG9jaXR5LnggKiB0aGlzLnZlbG9jaXR5LnggKyB0aGlzLnZlbG9jaXR5LnogKiB0aGlzLnZlbG9jaXR5LnopO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldFNwZWVkKCkgPiAwLjAxO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nSG9yaXpvbnRhbGx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhvcml6b250YWxTcGVlZCgpID4gMC4wMTtcbiAgfVxuXG4gIHB1YmxpYyBpc0ZhbGxpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA8IC0wLjE7XG4gIH1cblxuICBwdWJsaWMgaXNSaXNpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA+IDAuMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdmFpbGFibGVEYXNoQ2hhcmdlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLmZpbHRlcihjaGFyZ2UgPT4gY2hhcmdlLmlzQXZhaWxhYmxlKS5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGFzaENoYXJnZVN0YXR1cygpOiBBcnJheTx7IGlzQXZhaWxhYmxlOiBib29sZWFuOyBjb29sZG93blJlbWFpbmluZzogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLm1hcChjaGFyZ2UgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiBjaGFyZ2UuaXNBdmFpbGFibGUsXG4gICAgICBjb29sZG93blJlbWFpbmluZzogY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lIFxuICAgICAgICA/IE1hdGgubWF4KDAsIDYgLSAoY3VycmVudFRpbWUgLSBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWUpKVxuICAgICAgICA6IDBcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRDaGFyZ2UoZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGNoYXJnaW5nIG9yIGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0NoYXJnaW5nIHx8IHRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGNoYXJnZVxuICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkoY3VycmVudFBvc2l0aW9uKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUNoYXJnZShjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbjogbnVsbCB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuY2hhcmdlU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuY2hhcmdlRHVyYXRpb24sIDEpO1xuXG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIC8vIENoYXJnZSBjb21wbGV0ZVxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLmFkZCh0aGlzLmNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuY2hhcmdlRGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IHRydWUsIG5ld1Bvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gdXNpbmcgZWFzaW5nIChlYXNlLW91dCBxdWFkKVxuICAgIGNvbnN0IGVhc2VPdXRRdWFkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMik7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmNoYXJnZURpc3RhbmNlICogZWFzZU91dFF1YWQpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpc3BsYWNlbWVudCk7XG5cbiAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxDaGFyZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbGFtcFZlbG9jaXR5KCk6IHZvaWQge1xuICAgIC8vIEdldCBlZmZlY3RpdmUgbWF4IHNwZWVkIChjb25zaWRlcmluZyBkZWJ1ZmZzKVxuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFNwZWVkID0gdGhpcy5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgIFxuICAgIC8vIENsYW1wIGhvcml6b250YWwgdmVsb2NpdHkgdG8gZWZmZWN0aXZlIG1heCBzcGVlZFxuICAgIGNvbnN0IGhvcml6b250YWxWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKHRoaXMudmVsb2NpdHkueCwgMCwgdGhpcy52ZWxvY2l0eS56KTtcbiAgICBjb25zdCBob3Jpem9udGFsU3BlZWQgPSBob3Jpem9udGFsVmVsb2NpdHkubGVuZ3RoKCk7XG4gICAgXG4gICAgaWYgKGhvcml6b250YWxTcGVlZCA+IGVmZmVjdGl2ZU1heFNwZWVkKSB7XG4gICAgICBpZiAoZWZmZWN0aXZlTWF4U3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBmcm96ZW4gLSBzdG9wIGFsbCBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3Jpem9udGFsVmVsb2NpdHkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZWZmZWN0aXZlTWF4U3BlZWQpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSBob3Jpem9udGFsVmVsb2NpdHkueDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gaG9yaXpvbnRhbFZlbG9jaXR5Lno7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFwcGx5RnJpY3Rpb24oZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuTW92ZSkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgZnJpY3Rpb24gdG8gaG9yaXpvbnRhbCBtb3ZlbWVudFxuICAgIGNvbnN0IGZyaWN0aW9uRm9yY2UgPSBNYXRoLnBvdyh0aGlzLmZyaWN0aW9uLCBkZWx0YVRpbWUpO1xuICAgIHRoaXMudmVsb2NpdHkueCAqPSBmcmljdGlvbkZvcmNlO1xuICAgIHRoaXMudmVsb2NpdHkueiAqPSBmcmljdGlvbkZvcmNlO1xuXG4gICAgLy8gU3RvcCB2ZXJ5IHNtYWxsIHZlbG9jaXRpZXMgdG8gcHJldmVudCBqaXR0ZXJcbiAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eS54KSA8IDAuMDEpIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueikgPCAwLjAxKSB0aGlzLnZlbG9jaXR5LnogPSAwO1xuICB9XG5cbiAgcHVibGljIGFwcGx5R3Jhdml0eShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYW5GbHkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIC8vIEVuc3VyZSBWZWN0b3IzIG9iamVjdHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXRoaXMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gMDtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgdGhpcy5jYW5GbHkgPSBmYWxzZTtcbiAgICB0aGlzLm1heFNwZWVkID0gNS4wO1xuICAgIHRoaXMuZnJpY3Rpb24gPSAwLjg7XG4gICAgdGhpcy5qdW1wRm9yY2UgPSAyMC4wO1xuICAgIHRoaXMuZ3Jhdml0eSA9IC0xMi41O1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBSZXNldCBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuXG4gICAgLy8gUmVzZXQgZGFzaCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1O1xuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDtcbiAgICB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBSZXNldCBkYXNoIGNoYXJnZXNcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIFJlc2V0IGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTtcbiAgICB0aGlzLmNoYXJnZURpc3RhbmNlID0gOTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IE1vdmVtZW50IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBNb3ZlbWVudCh0aGlzLm1heFNwZWVkLCB0aGlzLmZyaWN0aW9uLCB0aGlzLmp1bXBGb3JjZSwgdGhpcy5ncmF2aXR5KTtcbiAgICBjbG9uZS52ZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkpO1xuICAgIGNsb25lLmFjY2VsZXJhdGlvbi5jb3B5KHRoaXMuYWNjZWxlcmF0aW9uKTtcbiAgICBjbG9uZS5tb3ZlRGlyZWN0aW9uLmNvcHkodGhpcy5tb3ZlRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5pbnB1dFN0cmVuZ3RoID0gdGhpcy5pbnB1dFN0cmVuZ3RoO1xuICAgIGNsb25lLmlzR3JvdW5kZWQgPSB0aGlzLmlzR3JvdW5kZWQ7XG4gICAgY2xvbmUuY2FuTW92ZSA9IHRoaXMuY2FuTW92ZTtcbiAgICBjbG9uZS5jYW5KdW1wID0gdGhpcy5jYW5KdW1wO1xuICAgIGNsb25lLmNhbkZseSA9IHRoaXMuY2FuRmx5O1xuXG4gICAgLy8gQ2xvbmUgZGVidWZmIHN0YXRlc1xuICAgIGNsb25lLmlzRnJvemVuID0gdGhpcy5pc0Zyb3plbjtcbiAgICBjbG9uZS5mcm96ZW5VbnRpbCA9IHRoaXMuZnJvemVuVW50aWw7XG4gICAgY2xvbmUuaXNTbG93ZWQgPSB0aGlzLmlzU2xvd2VkO1xuICAgIGNsb25lLnNsb3dlZFVudGlsID0gdGhpcy5zbG93ZWRVbnRpbDtcbiAgICBjbG9uZS5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXI7XG5cbiAgICAvLyBDbG9uZSBkYXNoIHByb3BlcnRpZXNcbiAgICBjbG9uZS5pc0Rhc2hpbmcgPSB0aGlzLmlzRGFzaGluZztcbiAgICBjbG9uZS5kYXNoRGlyZWN0aW9uLmNvcHkodGhpcy5kYXNoRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5kYXNoU3RhcnRUaW1lID0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNsb25lLmRhc2hEdXJhdGlvbiA9IHRoaXMuZGFzaER1cmF0aW9uO1xuICAgIGNsb25lLmRhc2hEaXN0YW5jZSA9IHRoaXMuZGFzaERpc3RhbmNlO1xuICAgIGNsb25lLmRhc2hTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5kYXNoU3RhcnRQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQ2xvbmUgZGFzaCBjaGFyZ2VzXG4gICAgY2xvbmUubWF4RGFzaENoYXJnZXMgPSB0aGlzLm1heERhc2hDaGFyZ2VzO1xuICAgIGNsb25lLmRhc2hDaGFyZ2VzID0gdGhpcy5kYXNoQ2hhcmdlcy5tYXAoY2hhcmdlID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogY2hhcmdlLmlzQXZhaWxhYmxlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IGNoYXJnZS5jb29sZG93blN0YXJ0VGltZVxuICAgIH0pKTtcblxuICAgIC8vIENsb25lIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgY2xvbmUuaXNDaGFyZ2luZyA9IHRoaXMuaXNDaGFyZ2luZztcbiAgICBjbG9uZS5jaGFyZ2VEaXJlY3Rpb24uY29weSh0aGlzLmNoYXJnZURpcmVjdGlvbik7XG4gICAgY2xvbmUuY2hhcmdlU3RhcnRUaW1lID0gdGhpcy5jaGFyZ2VTdGFydFRpbWU7XG4gICAgY2xvbmUuY2hhcmdlRHVyYXRpb24gPSB0aGlzLmNoYXJnZUR1cmF0aW9uO1xuICAgIGNsb25lLmNoYXJnZURpc3RhbmNlID0gdGhpcy5jaGFyZ2VEaXN0YW5jZTtcbiAgICBjbG9uZS5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJNb3ZlbWVudCIsImFkZEZvcmNlIiwiZm9yY2UiLCJhY2NlbGVyYXRpb24iLCJhZGQiLCJhZGRJbXB1bHNlIiwiaW1wdWxzZSIsInZlbG9jaXR5IiwianVtcCIsImNhbkp1bXAiLCJpc0dyb3VuZGVkIiwiY2FuRmx5IiwieSIsImp1bXBGb3JjZSIsInNldE1vdmVEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJzdHJlbmd0aCIsIm1vdmVEaXJlY3Rpb24iLCJjb3B5Iiwibm9ybWFsaXplIiwiaW5wdXRTdHJlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmcmVlemUiLCJkdXJhdGlvbiIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImlzRnJvemVuIiwiZnJvemVuVW50aWwiLCJjb25zb2xlIiwibG9nIiwic2xvdyIsInNwZWVkTXVsdGlwbGllciIsImlzU2xvd2VkIiwic2xvd2VkVW50aWwiLCJtb3ZlbWVudFNwZWVkTXVsdGlwbGllciIsInVwZGF0ZURlYnVmZnMiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsIm1heFNwZWVkIiwic3RhcnREYXNoIiwiY3VycmVudFBvc2l0aW9uIiwiaXNEYXNoaW5nIiwiYXZhaWxhYmxlQ2hhcmdlSW5kZXgiLCJkYXNoQ2hhcmdlcyIsImZpbmRJbmRleCIsImNoYXJnZSIsImlzQXZhaWxhYmxlIiwiZGFzaERpcmVjdGlvbiIsImRhc2hTdGFydFRpbWUiLCJkYXNoU3RhcnRQb3NpdGlvbiIsImNvb2xkb3duU3RhcnRUaW1lIiwic2V0VGltZW91dCIsInVwZGF0ZURhc2giLCJpc0NvbXBsZXRlIiwibmV3UG9zaXRpb24iLCJlbGFwc2VkIiwicHJvZ3Jlc3MiLCJkYXNoRHVyYXRpb24iLCJmaW5hbFBvc2l0aW9uIiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImRhc2hEaXN0YW5jZSIsImVhc2VPdXRRdWFkIiwicG93IiwiZGlzcGxhY2VtZW50IiwiY2FuY2VsRGFzaCIsInNldCIsInN0b3AiLCJnZXRTcGVlZCIsImxlbmd0aCIsImdldEhvcml6b250YWxTcGVlZCIsInNxcnQiLCJ4IiwieiIsImlzTW92aW5nIiwiaXNNb3ZpbmdIb3Jpem9udGFsbHkiLCJpc0ZhbGxpbmciLCJpc1Jpc2luZyIsImdldEF2YWlsYWJsZURhc2hDaGFyZ2VzIiwiZmlsdGVyIiwiZ2V0RGFzaENoYXJnZVN0YXR1cyIsIm1hcCIsImNvb2xkb3duUmVtYWluaW5nIiwic3RhcnRDaGFyZ2UiLCJpc0NoYXJnaW5nIiwiY2hhcmdlRGlyZWN0aW9uIiwiY2hhcmdlU3RhcnRUaW1lIiwiY2hhcmdlU3RhcnRQb3NpdGlvbiIsInVwZGF0ZUNoYXJnZSIsImNoYXJnZUR1cmF0aW9uIiwiY2hhcmdlRGlzdGFuY2UiLCJjYW5jZWxDaGFyZ2UiLCJjbGFtcFZlbG9jaXR5IiwiZWZmZWN0aXZlTWF4U3BlZWQiLCJob3Jpem9udGFsVmVsb2NpdHkiLCJob3Jpem9udGFsU3BlZWQiLCJhcHBseUZyaWN0aW9uIiwiZGVsdGFUaW1lIiwiY2FuTW92ZSIsImZyaWN0aW9uRm9yY2UiLCJmcmljdGlvbiIsImFicyIsImFwcGx5R3Jhdml0eSIsImdyYXZpdHkiLCJyZXNldCIsImVuYWJsZWQiLCJtYXhEYXNoQ2hhcmdlcyIsIkFycmF5IiwiZnJvbSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    setMaxDistance(maxDistance) {\n        this.maxDistance = maxDistance;\n    }\n    setStartPosition(position) {\n        this.startPosition.copy(position);\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime || this.distanceTraveled >= this.maxDistance;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Track distance traveled\n        const distanceThisFrame = this.velocity.length() * deltaTime;\n        this.distanceTraveled += distanceThisFrame;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity;\n        this.startPosition.set(0, 0, 0);\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        clone.distanceTraveled = this.distanceTraveled;\n        clone.maxDistance = this.maxDistance;\n        clone.startPosition.copy(this.startPosition);\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity; // Default to no distance limit\n        this.startPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBNENoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGVBQWVDLFdBQW1CLEVBQVE7UUFDL0MsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3JCO0lBRU9DLGlCQUFpQkMsUUFBaUIsRUFBUTtRQUMvQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2pCLElBQUksQ0FBQ2dCO0lBQzFCO0lBRU9FLGFBQWFDLFFBQWdCLEVBQVc7UUFDN0MsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDRjtJQUM3QjtJQUVPRyxhQUFhSCxRQUFnQixFQUFRO1FBQzFDLElBQUksQ0FBQ0MsVUFBVSxDQUFDRyxHQUFHLENBQUNKO0lBQ3RCO0lBRU9LLGFBQWFMLFFBQWdCLEVBQVc7UUFDN0Msa0JBQWtCO1FBQ2xCLElBQUlBLGFBQWEsSUFBSSxDQUFDTSxLQUFLLEVBQUUsT0FBTztRQUVwQyw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNsQixRQUFRLEVBQUUsT0FBTztRQUUxQiwyQ0FBMkM7UUFD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MEQsZ0JBQWdCLGFBQWMsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzPzcwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdGlsZSBjb21wb25lbnQgZm9yIGJ1bGxldHMsIHNwZWxscywgYW5kIG90aGVyIHByb2plY3RpbGVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aWxlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Byb2plY3RpbGUnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnUHJvamVjdGlsZSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgc3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZTogbnVtYmVyO1xuICBwdWJsaWMgbGlmZXRpbWU6IG51bWJlcjtcbiAgcHVibGljIG1heExpZmV0aW1lOiBudW1iZXI7XG4gIHB1YmxpYyBwaWVyY2luZzogYm9vbGVhbjtcbiAgcHVibGljIGhpdFRhcmdldHM6IFNldDxudW1iZXI+OyAvLyBFbnRpdHkgSURzIHRoYXQgaGF2ZSBiZWVuIGhpdFxuICBwdWJsaWMgZXhwbG9zaW9uUmFkaXVzOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG4gIHB1YmxpYyBib3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBtYXhCb3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBvd25lcjogbnVtYmVyOyAvLyBFbnRpdHkgSUQgb2YgdGhlIG93bmVyXG4gIHB1YmxpYyBkaXN0YW5jZVRyYXZlbGVkOiBudW1iZXI7IC8vIFRyYWNrIGRpc3RhbmNlIHRyYXZlbGVkXG4gIHB1YmxpYyBtYXhEaXN0YW5jZTogbnVtYmVyOyAvLyBNYXhpbXVtIGRpc3RhbmNlIGJlZm9yZSBleHBpcmluZ1xuICBwdWJsaWMgc3RhcnRQb3NpdGlvbjogVmVjdG9yMzsgLy8gU3RhcnRpbmcgcG9zaXRpb24gZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3BlZWQ6IG51bWJlciA9IDIwLFxuICAgIGRhbWFnZTogbnVtYmVyID0gMTAsXG4gICAgbWF4TGlmZXRpbWU6IG51bWJlciA9IDUsXG4gICAgb3duZXI6IG51bWJlciA9IC0xXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICB0aGlzLmxpZmV0aW1lID0gMDtcbiAgICB0aGlzLm1heExpZmV0aW1lID0gbWF4TGlmZXRpbWU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV4cGxvc2lvblJhZGl1cyA9IDA7XG4gICAgdGhpcy5ncmF2aXR5ID0gMDsgLy8gTW9zdCBwcm9qZWN0aWxlcyBpZ25vcmUgZ3Jhdml0eVxuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkID0gMDtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7IC8vIERlZmF1bHQgdG8gbm8gZGlzdGFuY2UgbGltaXRcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zcGVlZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkR3Jhdml0eShncmF2aXR5OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICB9XG5cbiAgcHVibGljIHNldFBpZXJjaW5nKHBpZXJjaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5waWVyY2luZyA9IHBpZXJjaW5nO1xuICB9XG5cbiAgcHVibGljIHNldEV4cGxvc2l2ZShyYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gcmFkaXVzO1xuICB9XG5cbiAgcHVibGljIHNldEJvdW5jaW5nKG1heEJvdW5jZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IG1heEJvdW5jZXM7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF4RGlzdGFuY2UobWF4RGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICB9XG5cbiAgcHVibGljIGhhc0hpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGl0VGFyZ2V0cy5oYXMoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGFkZEhpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5oaXRUYXJnZXRzLmFkZChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgY2FuSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDYW4ndCBoaXQgb3duZXJcbiAgICBpZiAoZW50aXR5SWQgPT09IHRoaXMub3duZXIpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBJZiBwaWVyY2luZywgY2FuIGhpdCB0YXJnZXRzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKHRoaXMucGllcmNpbmcpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIC8vIE90aGVyd2lzZSwgY2FuIG9ubHkgaGl0IGVhY2ggdGFyZ2V0IG9uY2VcbiAgICByZXR1cm4gIXRoaXMuaGFzSGl0VGFyZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0V4cGlyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGlmZXRpbWUgPj0gdGhpcy5tYXhMaWZldGltZSB8fCB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPj0gdGhpcy5tYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Cb3VuY2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmNlcyA8IHRoaXMubWF4Qm91bmNlcztcbiAgfVxuXG4gIHB1YmxpYyBib3VuY2Uobm9ybWFsOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbkJvdW5jZSgpKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVmbGVjdCB2ZWxvY2l0eSBvZmYgdGhlIHN1cmZhY2Ugbm9ybWFsXG4gICAgY29uc3QgcmVmbGVjdGlvbiA9IHRoaXMudmVsb2NpdHkuY2xvbmUoKS5yZWZsZWN0KG5vcm1hbCk7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KHJlZmxlY3Rpb24pO1xuICAgIHRoaXMuYm91bmNlcysrO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGlmZXRpbWUgKz0gZGVsdGFUaW1lO1xuICAgIFxuICAgIC8vIFRyYWNrIGRpc3RhbmNlIHRyYXZlbGVkXG4gICAgY29uc3QgZGlzdGFuY2VUaGlzRnJhbWUgPSB0aGlzLnZlbG9jaXR5Lmxlbmd0aCgpICogZGVsdGFUaW1lO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCArPSBkaXN0YW5jZVRoaXNGcmFtZTtcbiAgICBcbiAgICAvLyBBcHBseSBncmF2aXR5IGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5ncmF2aXR5ICE9PSAwKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgKz0gdGhpcy5ncmF2aXR5ICogZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRQb3NpdGlvbih0cmFuc2Zvcm06IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtLmNsb25lKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0UHJlZGljdGVkUG9zaXRpb24odHJhbnNmb3JtOiBWZWN0b3IzLCBkZWx0YVRpbWU6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIGNvbnN0IHByZWRpY3RlZCA9IHRyYW5zZm9ybS5jbG9uZSgpO1xuICAgIHByZWRpY3RlZC5hZGQodGhpcy52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSkpO1xuICAgIHJldHVybiBwcmVkaWN0ZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5zcGVlZCA9IDIwO1xuICAgIHRoaXMuZGFtYWdlID0gMTA7XG4gICAgdGhpcy5saWZldGltZSA9IDA7XG4gICAgdGhpcy5tYXhMaWZldGltZSA9IDU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cy5jbGVhcigpO1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gMDtcbiAgICB0aGlzLmdyYXZpdHkgPSAwO1xuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gLTE7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkID0gMDtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IFByb2plY3RpbGUge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFByb2plY3RpbGUodGhpcy5zcGVlZCwgdGhpcy5kYW1hZ2UsIHRoaXMubWF4TGlmZXRpbWUsIHRoaXMub3duZXIpO1xuICAgIGNsb25lLnZlbG9jaXR5LmNvcHkodGhpcy52ZWxvY2l0eSk7XG4gICAgY2xvbmUubGlmZXRpbWUgPSB0aGlzLmxpZmV0aW1lO1xuICAgIGNsb25lLnBpZXJjaW5nID0gdGhpcy5waWVyY2luZztcbiAgICBjbG9uZS5oaXRUYXJnZXRzID0gbmV3IFNldCh0aGlzLmhpdFRhcmdldHMpO1xuICAgIGNsb25lLmV4cGxvc2lvblJhZGl1cyA9IHRoaXMuZXhwbG9zaW9uUmFkaXVzO1xuICAgIGNsb25lLmdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7XG4gICAgY2xvbmUuYm91bmNlcyA9IHRoaXMuYm91bmNlcztcbiAgICBjbG9uZS5tYXhCb3VuY2VzID0gdGhpcy5tYXhCb3VuY2VzO1xuICAgIGNsb25lLmRpc3RhbmNlVHJhdmVsZWQgPSB0aGlzLmRpc3RhbmNlVHJhdmVsZWQ7XG4gICAgY2xvbmUubWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlO1xuICAgIGNsb25lLnN0YXJ0UG9zaXRpb24uY29weSh0aGlzLnN0YXJ0UG9zaXRpb24pO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJQcm9qZWN0aWxlIiwic2V0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwidmVsb2NpdHkiLCJjb3B5Iiwibm9ybWFsaXplIiwibXVsdGlwbHlTY2FsYXIiLCJzcGVlZCIsImFkZEdyYXZpdHkiLCJncmF2aXR5Iiwic2V0UGllcmNpbmciLCJwaWVyY2luZyIsInNldEV4cGxvc2l2ZSIsInJhZGl1cyIsImV4cGxvc2lvblJhZGl1cyIsInNldEJvdW5jaW5nIiwibWF4Qm91bmNlcyIsInNldE1heERpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJzZXRTdGFydFBvc2l0aW9uIiwicG9zaXRpb24iLCJzdGFydFBvc2l0aW9uIiwiaGFzSGl0VGFyZ2V0IiwiZW50aXR5SWQiLCJoaXRUYXJnZXRzIiwiaGFzIiwiYWRkSGl0VGFyZ2V0IiwiYWRkIiwiY2FuSGl0VGFyZ2V0Iiwib3duZXIiLCJpc0V4cGlyZWQiLCJsaWZldGltZSIsIm1heExpZmV0aW1lIiwiZGlzdGFuY2VUcmF2ZWxlZCIsImNhbkJvdW5jZSIsImJvdW5jZXMiLCJib3VuY2UiLCJub3JtYWwiLCJyZWZsZWN0aW9uIiwiY2xvbmUiLCJyZWZsZWN0IiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiZGlzdGFuY2VUaGlzRnJhbWUiLCJsZW5ndGgiLCJ5IiwiZ2V0UG9zaXRpb24iLCJ0cmFuc2Zvcm0iLCJnZXRQcmVkaWN0ZWRQb3NpdGlvbiIsInByZWRpY3RlZCIsInJlc2V0Iiwic2V0IiwiZGFtYWdlIiwiY2xlYXIiLCJJbmZpbml0eSIsImVuYWJsZWQiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 8;\n        this.attackDamage = 10;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 10; // 10 unit attack range as specified\n        this.attackDamage = 10; // 10 damage per arrow as specified\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksb0NBQW9DO1FBQzNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksbUNBQW1DO1FBQzNELElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMDsgLy8gMTAgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxMDsgLy8gMTAgZGFtYWdlIHBlciBhcnJvdyBhcyBzcGVjaWZpZWRcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gMS41OyAvLyAxLjUgc2Vjb25kcyBiZXR3ZWVuIHNob3RzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDsgLy8gU3BlZWQgb2YgdG93ZXIgYXJyb3dzXG4gICAgXG4gICAgLy8gVGFyZ2V0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlICsgMTsgLy8gU2VhcmNoIHNsaWdodGx5IGJleW9uZCBhdHRhY2sgcmFuZ2VcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcbiAgICBcbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc0RlYWQgfHwgIXRoaXMuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuICBcbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0RW50aXR5SWQ6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgfVxuICBcbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cbiAgXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0KCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVG93ZXIgJHt0aGlzLnRvd2VySW5kZXggKyAxfSAoT3duZXI6ICR7dGhpcy5vd25lcklkfSlgO1xuICB9XG4gIFxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy50b3dlckluZGV4ID0gMDtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gODtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IDEwO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSAxLjU7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSA5O1xuICAgIHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSAwLjU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBcbiAgcHVibGljIGNsb25lKCk6IFRvd2VyIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUb3dlcih0aGlzLm93bmVySWQsIHRoaXMudG93ZXJJbmRleCk7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUucHJvamVjdGlsZVNwZWVkID0gdGhpcy5wcm9qZWN0aWxlU3BlZWQ7XG4gICAgY2xvbmUuY3VycmVudFRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldDtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hSYW5nZSA9IHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2U7XG4gICAgY2xvbmUubGFzdFRhcmdldFNlYXJjaFRpbWUgPSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lO1xuICAgIGNsb25lLnRhcmdldFNlYXJjaENvb2xkb3duID0gdGhpcy50YXJnZXRTZWFyY2hDb29sZG93bjtcbiAgICBjbG9uZS5pc0FjdGl2ZSA9IHRoaXMuaXNBY3RpdmU7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuZGVhdGhUaW1lID0gdGhpcy5kZWF0aFRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiVG93ZXIiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWN0aXZlIiwiaXNEZWFkIiwiY3VycmVudFRhcmdldCIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsImxhc3RUYXJnZXRTZWFyY2hUaW1lIiwidGFyZ2V0U2VhcmNoQ29vbGRvd24iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJ0YXJnZXRFbnRpdHlJZCIsImNsZWFyVGFyZ2V0IiwiZGllIiwiZGVhdGhUaW1lIiwiZ2V0RGlzcGxheU5hbWUiLCJ0b3dlckluZGV4Iiwib3duZXJJZCIsInJlc2V0IiwiYXR0YWNrUmFuZ2UiLCJhdHRhY2tEYW1hZ2UiLCJwcm9qZWN0aWxlU3BlZWQiLCJ0YXJnZXRTZWFyY2hSYW5nZSIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJ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QkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            console.warn(\"CameraSystem: Target position is not properly initialized, skipping snapToTarget\");\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBOEMvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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R0FBR0E7UUFDcEIsSUFBSSxDQUFDOEMsUUFBUSxHQUFHLEtBQUssMkJBQTJCO1FBRWhELElBQUl2RSxRQUFRO1lBQ1YsSUFBSSxDQUFDQSxNQUFNLEdBQUc7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07Z0JBQUUsR0FBR0EsTUFBTTtZQUFDO1FBQzVDO1FBRUEsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtRQUM1QyxJQUFJLENBQUNGLFNBQVMsQ0FBQzhCLEdBQUcsR0FBRzhCLEtBQUtDLEVBQUUsR0FBRyxHQUFHLHNCQUFzQjtRQUN4RCxJQUFJLENBQUM3RCxTQUFTLENBQUM0QixLQUFLLEdBQUc7UUFFdkIsSUFBSSxDQUFDTyxtQkFBbUI7UUFDeEIsSUFBSSxDQUFDTSxvQkFBb0I7SUFDM0I7QUFpTEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ2FtZXJhU3lzdGVtLnRzP2NkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FtZXJhIHN5c3RlbSBmb3IgdGhpcmQtcGVyc29uIGNhbWVyYSBjb250cm9sc1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJ0AvY29yZS9JbnB1dE1hbmFnZXInO1xuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnQC91dGlscy9NYXRoVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbWVyYUNvbmZpZyB7XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtb3VzZVNlbnNpdGl2aXR5OiBudW1iZXI7XG4gIHNtb290aGluZzogbnVtYmVyO1xuICBtaW5Qb2xhckFuZ2xlOiBudW1iZXI7XG4gIG1heFBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4RGlzdGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtXTtcbiAgcHJpdmF0ZSBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIHRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBDYW1lcmEgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGNvbmZpZzogQ2FtZXJhQ29uZmlnID0ge1xuICAgIGRpc3RhbmNlOiAxMCxcbiAgICBoZWlnaHQ6IDUsXG4gICAgbW91c2VTZW5zaXRpdml0eTogMC4wMDUsIC8vIEluY3JlYXNlZCBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgc21vb3RoaW5nOiAwLjEsXG4gICAgbWluUG9sYXJBbmdsZTogTWF0aC5QSSAvIDMuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBnb2luZyBhYm92ZSBob3Jpem9uXG4gICAgbWF4UG9sYXJBbmdsZTogTWF0aC5QSSAvIDIuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBsb29raW5nIHVuZGVybmVhdGggdGhlIG1hcFxuICAgIG1heERpc3RhbmNlOiAxMS41LFxuICB9O1xuXG4gIC8vIENhbWVyYSBzdGF0ZVxuICBwcml2YXRlIHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoMTAsIE1hdGguUEkgLyAzLCAwKTtcbiAgcHJpdmF0ZSB0YXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgY3VycmVudFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50TG9va0F0ID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0YXJnZXRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBcbiAgLy8gTW91c2Ugc3RhdGUgZm9yIGNhbWVyYSByb3RhdGlvblxuICBwcml2YXRlIGlzUmlnaHRNb3VzZURvd24gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3aGVlbExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhLCBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlciwgY29uZmlnPzogUGFydGlhbDxDYW1lcmFDb25maWc+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IGlucHV0TWFuYWdlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gOTAwOyAvLyBSdW4gbGF0ZSwgYWZ0ZXIgbW92ZW1lbnRcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgfVxuXG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7IC8vIFN0YXJ0IGF0IDYwIGRlZ3JlZXNcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IDA7XG5cbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldHVwSW5pdGlhbFBvc2l0aW9uKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0VGFyZ2V0KGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgdGhpcy50YXJnZXQgPSBlbnRpdHk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29uZmlnKGNvbmZpZzogUGFydGlhbDxDYW1lcmFDb25maWc+KTogdm9pZCB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHJldHVybjtcblxuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRoaXMudGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgaW5wdXQgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaGFuZGxlTW91c2VJbnB1dCgpO1xuXG4gICAgLy8gVXBkYXRlIHRhcmdldCBwb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIC8vIENhbGN1bGF0ZSBjYW1lcmEgcG9zaXRpb24gYmFzZWQgb24gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLmFkZCh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICAvLyBTbW9vdGggY2FtZXJhIG1vdmVtZW50XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24ubGVycCh0aGlzLnRhcmdldFBvc2l0aW9uLCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuICAgIHRoaXMuY3VycmVudExvb2tBdC5sZXJwKHRoaXMudGFyZ2V0TG9va0F0LCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuXG4gICAgLy8gVXBkYXRlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNb3VzZUlucHV0KCk6IHZvaWQge1xuICAgIGNvbnN0IG1vdXNlRGVsdGEgPSB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gICAgXG4gICAgLy8gT25seSByb3RhdGUgY2FtZXJhIHdoZW4gcmlnaHQgbW91c2UgYnV0dG9uIGlzIGhlbGQgZG93blxuICAgIGlmICgobW91c2VEZWx0YS54ICE9PSAwIHx8IG1vdXNlRGVsdGEueSAhPT0gMCkgJiYgdGhpcy5pc1JpZ2h0TW91c2VEb3duKSB7XG4gICAgICAvLyBVcGRhdGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSAtPSBtb3VzZURlbHRhLnggKiB0aGlzLmNvbmZpZy5tb3VzZVNlbnNpdGl2aXR5O1xuICAgICAgdGhpcy5zcGhlcmljYWwucGhpIC09IG1vdXNlRGVsdGEueSAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7IC8vIEludmVydGVkIFkgZm9yIG5hdHVyYWwgY2FtZXJhIGZlZWxcblxuICAgICAgLy8gQ2xhbXAgcGhpIHRvIHByZXZlbnQgY2FtZXJhIGZsaXBwaW5nXG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSxcbiAgICAgICAgdGhpcy5jb25maWcubWluUG9sYXJBbmdsZSxcbiAgICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICAgKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZXRhXG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZSh0aGlzLnNwaGVyaWNhbC50aGV0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIE1vdXNlIGJ1dHRvbiBldmVudHMgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZURvd24nLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZVVwJywgKHsgYnV0dG9uIH0pID0+IHtcbiAgICAgIGlmIChidXR0b24gPT09IDIpIHsgLy8gUmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICAgIHRoaXMuaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW91c2Ugd2hlZWwgZm9yIHpvb20gLSBvbmx5IGFkZCBsaXN0ZW5lciBvbmNlXG4gICAgaWYgKCF0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCkge1xuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ3doZWVsJywgKHsgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzICs9IGRlbHRhWSAqIDAuMDE7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcCh0aGlzLnNwaGVyaWNhbC5yYWRpdXMsIDIsIHRoaXMuY29uZmlnLm1heERpc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53aGVlbExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJbml0aWFsUG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LnNldCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQsIDApO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICAgIFxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBnZXRDYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FtZXJhUmlnaHQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYW1lcmFEaXJlY3Rpb24oKTtcbiAgICBjb25zdCByaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFGb3J3YXJkKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXRDYW1lcmFSaWdodCgpO1xuICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCByaWdodCk7XG4gICAgZm9yd2FyZC5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXN0YW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC5yYWRpdXM7XG4gIH1cblxuICBwdWJsaWMgc2V0RGlzdGFuY2UoZGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcChkaXN0YW5jZSwgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIGdldEhvcml6b250YWxBbmdsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC50aGV0YTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRWZXJ0aWNhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnBoaTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBbmdsZXMoaG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSBNYXRoVXRpbHMubm9ybWFsaXplQW5nbGUoaG9yaXpvbnRhbCk7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aFV0aWxzLmNsYW1wKFxuICAgICAgdmVydGljYWwsXG4gICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRDYW1lcmEoKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSAwO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzbmFwVG9UYXJnZXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgcG9zaXRpb24gaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnggPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnkgPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdDYW1lcmFTeXN0ZW06IFRhcmdldCBwb3NpdGlvbiBpcyBub3QgcHJvcGVybHkgaW5pdGlhbGl6ZWQsIHNraXBwaW5nIHNuYXBUb1RhcmdldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5hZGQodGhpcy50YXJnZXRMb29rQXQpO1xuXG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uY29weSh0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuY29weSh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5jdXJyZW50TG9va0F0KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogUGVyc3BlY3RpdmVDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlNwaGVyaWNhbCIsIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNYXRoVXRpbHMiLCJDYW1lcmFTeXN0ZW0iLCJzZXRUYXJnZXQiLCJlbnRpdHkiLCJ0YXJnZXQiLCJzZXRDb25maWciLCJjb25maWciLCJzcGhlcmljYWwiLCJyYWRpdXMiLCJkaXN0YW5jZSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidGFyZ2V0VHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwiaGFuZGxlTW91c2VJbnB1dCIsInRhcmdldExvb2tBdCIsImNvcHkiLCJwb3NpdGlvbiIsInkiLCJoZWlnaHQiLCJ0YXJnZXRQb3NpdGlvbiIsInNldEZyb21TcGhlcmljYWwiLCJhZGQiLCJjdXJyZW50UG9zaXRpb24iLCJsZXJwIiwic21vb3RoaW5nIiwiY3VycmVudExvb2tBdCIsImNhbWVyYSIsImxvb2tBdCIsIm1vdXNlRGVsdGEiLCJpbnB1dE1hbmFnZXIiLCJnZXRNb3VzZURlbHRhIiwieCIsImlzUmlnaHRNb3VzZURvd24iLCJ0aGV0YSIsIm1vdXNlU2Vuc2l0aXZpdHkiLCJwaGkiLCJjbGFtcCIsIm1pblBvbGFyQW5nbGUiLCJtYXhQb2xhckFuZ2xlIiwibm9ybWFsaXplQW5nbGUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwib24iLCJidXR0b24iLCJ3aGVlbExpc3RlbmVyQWRkZWQiLCJkZWx0YVkiLCJtYXhEaXN0YW5jZSIsInNldHVwSW5pdGlhbFBvc2l0aW9uIiwic2V0IiwiZ2V0Q2FtZXJhRGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJnZXRDYW1lcmFSaWdodCIsInJpZ2h0IiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwiZ2V0Q2FtZXJhRm9yd2FyZCIsImZvcndhcmQiLCJnZXREaXN0YW5jZSIsInNldERpc3RhbmNlIiwiZ2V0SG9yaXpvbnRhbEFuZ2xlIiwiZ2V0VmVydGljYWxBbmdsZSIsInNldEFuZ2xlcyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInJlc2V0Q2FtZXJhIiwiTWF0aCIsIlBJIiwic25hcFRvVGFyZ2V0IiwidW5kZWZpbmVkIiwieiIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0Q2FtZXJhIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {}\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {}\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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RixNQUFNLENBQUNEO1FBQy9CO0lBQ0Y7SUFFT0UsWUFBa0I7UUFDdkIsSUFBSSxDQUFDckgsV0FBVyxDQUFDc0gsS0FBSztRQUN0QixJQUFJLENBQUNyRixnQkFBZ0IsQ0FBQ3FGLEtBQUs7UUFDM0IsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxNQUFNLEdBQUc7SUFDL0I7SUF2WkFpSCxZQUFZQyxXQUFtQixDQUFDLENBQUU7UUFDaEMsS0FBSzthQVhTQyxxQkFBcUI7WUFBQzdJLGdFQUFTQTtZQUFFRSw4REFBUUE7U0FBQzthQUVsRHVCLGlCQUFrQyxFQUFFO2FBQ3BDNEIsbUJBQW1CLElBQUlGLE1BQThCLDJCQUEyQjs7UUFFeEYsdUJBQXVCO2FBQ2YyRixpQkFBaUI7YUFDakJuSCxrQkFBa0I7YUFDbEJDLG1CQUFtQjtRQUl6QixJQUFJLENBQUNtSCxRQUFRLEdBQUcsSUFBSSxzQ0FBc0M7UUFDMUQsSUFBSSxDQUFDM0gsV0FBVyxHQUFHLElBQUloQiwyREFBV0EsQ0FBQ3dJO0lBQ3JDO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cz9jOWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbGxpc2lvbiBzeXN0ZW0gZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxuaW1wb3J0IHsgVmVjdG9yMywgQm94MyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBTcGF0aWFsSGFzaCB9IGZyb20gJ0AvdXRpbHMvU3BhdGlhbEhhc2gnO1xuXG5pbnRlcmZhY2UgQ29sbGlzaW9uUGFpciB7XG4gIGVudGl0eUE6IEVudGl0eTtcbiAgZW50aXR5QjogRW50aXR5O1xuICBjb2xsaWRlckE6IENvbGxpZGVyO1xuICBjb2xsaWRlckI6IENvbGxpZGVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBDb2xsaWRlcl07XG4gIHByaXZhdGUgc3BhdGlhbEhhc2g6IFNwYXRpYWxIYXNoO1xuICBwcml2YXRlIGNvbGxpc2lvblBhaXJzOiBDb2xsaXNpb25QYWlyW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7IC8vIFRyYWNrIG9uZ29pbmcgY29sbGlzaW9uc1xuICBcbiAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgY29sbGlzaW9uQ2hlY2tzID0gMDtcbiAgcHJpdmF0ZSBhY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICBjb25zdHJ1Y3RvcihjZWxsU2l6ZTogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIG1vdmVtZW50IGJ1dCBhZnRlciBpbnB1dFxuICAgIHRoaXMuc3BhdGlhbEhhc2ggPSBuZXcgU3BhdGlhbEhhc2goY2VsbFNpemUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB0cmlnZ2VyIGRldGVjdGlvbiBhbmQgYnJvYWQgcGhhc2VcbiAgICB0aGlzLnVwZGF0ZVNwYXRpYWxIYXNoKGVudGl0aWVzKTtcbiAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoZW50aXRpZXMpO1xuICAgIHRoaXMucHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcygpO1xuICAgIC8vIEFsc28gcmVzb2x2ZSBjb2xsaXNpb25zIGluIHVwZGF0ZSgpIHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzIGNvbGxpc2lvbiByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXM6IEVudGl0eVtdKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaCB3aXRoIGN1cnJlbnQgZW50aXR5IHBvc2l0aW9uc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWNvbGxpZGVyLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xsaWRlciBib3VuZHNcbiAgICAgIGNvbGxpZGVyLnVwZGF0ZUJvdW5kcyh0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaFxuICAgICAgdGhpcy5zcGF0aWFsSGFzaC51cGRhdGUoZW50aXR5LCBjb2xsaWRlci5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb2xsaXNpb25DaGVja3MgPSAwO1xuICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucyA9IDA7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFF1ZXJ5IHNwYXRpYWwgaGFzaCBmb3IgcG90ZW50aWFsIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGNvbGxpZGVyLmJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJFbnRpdHkgPSBjYW5kaWRhdGUuZW50aXR5O1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IG90aGVyRW50aXR5LmlkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIga2V5IChzbWFsbGVyIElEIGZpcnN0KVxuICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW50aXR5LmlkIDwgb3RoZXJFbnRpdHkuaWQgPyBcbiAgICAgICAgICBgJHtlbnRpdHkuaWR9LSR7b3RoZXJFbnRpdHkuaWR9YCA6IFxuICAgICAgICAgIGAke290aGVyRW50aXR5LmlkfS0ke2VudGl0eS5pZH1gO1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBwYWlyXG4gICAgICAgIGlmIChwcm9jZXNzZWRQYWlycy5oYXMocGFpcktleSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRQYWlycy5hZGQocGFpcktleSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJUcmFuc2Zvcm0gPSBvdGhlckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgICAgaWYgKCFvdGhlclRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhb3RoZXJDb2xsaWRlcj8uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sbGlkZXJzIGNhbiBjb2xsaWRlXG4gICAgICAgIGlmICghY29sbGlkZXIuY2FuQ29sbGlkZVdpdGgob3RoZXJDb2xsaWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2hlY2tzKys7XG5cbiAgICAgICAgLy8gUHJlY2lzZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIGlmIChjb2xsaWRlci5pbnRlcnNlY3RzKG90aGVyQ29sbGlkZXIsIHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCksIG90aGVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdHVhbENvbGxpc2lvbnMrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgICAgIGlmICgoY29sbGlkZXIubGF5ZXIgPT09IDIgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgICAgICAoY29sbGlkZXIubGF5ZXIgPT09IDE2ICYmIG90aGVyQ29sbGlkZXIubGF5ZXIgPT09IDIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VwYXJhdGlvbiA9IHBvc0EuY2xvbmUoKS5zdWIocG9zQik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzZXBhcmF0aW9uLmxlbmd0aCgpO1xuXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAvLyBPYmplY3RzIGFyZSBhdCBleGFjdCBzYW1lIHBvc2l0aW9uLCBzZXBhcmF0ZSBhbG9uZyBZIGF4aXNcbiAgICAgIHNlcGFyYXRpb24uc2V0KDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzZXBhcmF0aW9uIGRpc3RhbmNlXG4gICAgbGV0IHJlcXVpcmVkU2VwYXJhdGlvbiA9IDA7XG4gICAgXG4gICAgaWYgKHBhaXIuY29sbGlkZXJBLnR5cGUgPT09ICdzcGhlcmUnICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnY3lsaW5kZXInKSB7XG4gICAgICAvLyBQbGF5ZXIgKHNwaGVyZSkgdnMgUGlsbGFyIChjeWxpbmRlcikgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnY3lsaW5kZXInICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICAvLyBQaWxsYXIgKGN5bGluZGVyKSB2cyBQbGF5ZXIgKHNwaGVyZSkgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdGhlciBzaGFwZXMsIHVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uXG4gICAgICBjb25zdCByYWRpdXNBID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQSk7XG4gICAgICBjb25zdCByYWRpdXNCID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQik7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwID0gcmVxdWlyZWRTZXBhcmF0aW9uIC0gZGlzdGFuY2U7XG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgaWYgKChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMiAmJiBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgIChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMTYgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDIpKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBzdGF0aWMgb2JqZWN0cyAobGlrZSBwaWxsYXJzKSwgYXBwbHkgc3Ryb25nZXIgc2VwYXJhdGlvbiB0byBwcmV2ZW50IHBlbmV0cmF0aW9uXG4gICAgICBsZXQgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjA7XG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgfHwgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjE7IC8vIDEwJSBleHRyYSBzZXBhcmF0aW9uIGZvciBzdGF0aWMgb2JqZWN0c1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXBhcmF0ZSBvYmplY3RzIC0gdXNlIGVuaGFuY2VkIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gc2VwYXJhdGlvbi5tdWx0aXBseVNjYWxhcihvdmVybGFwICogc2VwYXJhdGlvbk11bHRpcGxpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdGllcyBoYXZlIE1vdmVtZW50IGNvbXBvbmVudHMgZm9yIGludGVsbGlnZW50IHNlcGFyYXRpb24gZGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCBtb3ZlbWVudEEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGNvbnN0IG1vdmVtZW50QiA9IHBhaXIuZW50aXR5Qi5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgc2VwYXJhdGlvbiBkaXN0cmlidXRpb24gYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50cyBhbmQgc3RhdGljIHN0YXR1c1xuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JBID0gMC41OyAvLyBEZWZhdWx0OiBzcGxpdCBzZXBhcmF0aW9uIGVxdWFsbHlcbiAgICAgIGxldCBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgIFxuICAgICAgaWYgKHBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBBIGlzIHN0YXRpYywgQiBtb3ZlcyAtIEIgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCIGlzIHN0YXRpYywgQSBtb3ZlcyAtIEEgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAxO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiAhcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gQm90aCBub24tc3RhdGljIC0gY2hlY2sgZm9yIFBWUCBzY2VuYXJpbyAoYm90aCBwbGF5ZXJzKVxuICAgICAgICBjb25zdCBpc1BsYXllckEgPSBwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSO1xuICAgICAgICBjb25zdCBpc1BsYXllckIgPSBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHx8IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BsYXllckEgJiYgaXNQbGF5ZXJCKSB7XG4gICAgICAgICAgLy8gUFZQIGNvbGxpc2lvbjogY2hlY2sgY2FuTW92ZSBwcm9wZXJ0eSBmb3IgZmFpciBjb2xsaXNpb24gcmVzb2x1dGlvblxuICAgICAgICAgIGNvbnN0IGNhbk1vdmVBID0gbW92ZW1lbnRBID8gbW92ZW1lbnRBLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjYW5Nb3ZlQiA9IG1vdmVtZW50QiA/IG1vdmVtZW50Qi5jYW5Nb3ZlIDogZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBsYXllcnMgY2FuIG1vdmUgLSBlcXVhbCBkaXN0cmlidXRpb24gZm9yIGZhaXIgZ2FtZXBsYXlcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC41O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5Nb3ZlQSAmJiAhY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQSBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQiBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDEuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEIgY2FuIG1vdmUgKGxvY2FsIHBsYXllciksIEEgaXMgcG9zaXRpb24tc3luY2VkIChyZW1vdGUgcGxheWVyKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDEuMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVpdGhlciBjYW4gbW92ZSAtIG5vIHNlcGFyYXRpb24gKHNob3VsZG4ndCBoYXBwZW4gaW4gUFZQKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLVBWUCBjb2xsaXNpb24gLSBkaXN0cmlidXRlIGJhc2VkIG9uIE1vdmVtZW50IGNvbXBvbmVudHNcbiAgICAgICAgICBpZiAobW92ZW1lbnRBICYmICFtb3ZlbWVudEIpIHtcbiAgICAgICAgICAgIC8vIEEgaGFzIE1vdmVtZW50LCBCIGRvZXNuJ3RcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC44O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjI7XG4gICAgICAgICAgfSBlbHNlIGlmICghbW92ZW1lbnRBICYmIG1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQiBoYXMgTW92ZW1lbnQsIEEgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjI7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYm90aCBoYXZlIE1vdmVtZW50IG9yIG5laXRoZXIgaGFzIE1vdmVtZW50LCB1c2UgZXF1YWwgZGlzdHJpYnV0aW9uICgwLjUsIDAuNSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzZXBhcmF0aW9uIHdpdGggY2FsY3VsYXRlZCBmYWN0b3JzXG4gICAgICBpZiAoc2VwYXJhdGlvbkZhY3RvckEgPiAwICYmIHNlcGFyYXRpb25WZWN0b3IgJiYgc2VwYXJhdGlvblZlY3Rvci5jbG9uZSkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZXBhcmF0aW9uRmFjdG9yQSk7XG4gICAgICAgIHRyYW5zZm9ybUEudHJhbnNsYXRlKHNlcGFyYXRpb25BLngsIHNlcGFyYXRpb25BLnksIHNlcGFyYXRpb25BLnopO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBzdG9wIG1vdmVtZW50IHZlbG9jaXR5IGZvciBwbGF5ZXIgd2hlbiBoaXR0aW5nIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChtb3ZlbWVudEEgJiYgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMgJiYgbW92ZW1lbnRBLnZlbG9jaXR5ICYmIG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSAmJiBzZXBhcmF0aW9uICYmIHNlcGFyYXRpb24uY2xvbmUpIHtcbiAgICAgICAgICAvLyBQcm9qZWN0IHZlbG9jaXR5IHRvIHJlbW92ZSBjb21wb25lbnQgdG93YXJkcyB0aGUgc3RhdGljIG9iamVjdFxuICAgICAgICAgIGNvbnN0IHZlbG9jaXR5VG93YXJkc1N0YXRpYyA9IG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSgpLnByb2plY3RPblZlY3RvcihzZXBhcmF0aW9uLmNsb25lKCkubmVnYXRlKCkpO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEEudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQiA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbkIgPSBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLXNlcGFyYXRpb25GYWN0b3JCKTtcbiAgICAgICAgdHJhbnNmb3JtQi50cmFuc2xhdGUoc2VwYXJhdGlvbkIueCwgc2VwYXJhdGlvbkIueSwgc2VwYXJhdGlvbkIueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QiAmJiBwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYykge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRCLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24pO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEIudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcHByb3hpbWF0ZVJhZGl1cyhjb2xsaWRlcjogQ29sbGlkZXIpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY29sbGlkZXIudHlwZSkge1xuICAgICAgY2FzZSAnc3BoZXJlJzpcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyLnJhZGl1cztcbiAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5zaXplLngsIGNvbGxpZGVyLnNpemUueSwgY29sbGlkZXIuc2l6ZS56KSAqIDAuNTtcbiAgICAgIGNhc2UgJ2NhcHN1bGUnOlxuICAgICAgY2FzZSAnY3lsaW5kZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sbGlkZXIucmFkaXVzLCBjb2xsaWRlci5oZWlnaHQgKiAwLjUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIHN5c3RlbXNcbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzKGJvdW5kczogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUmFkaXVzKGNlbnRlcjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlSYWRpdXMoY2VudGVyLCByYWRpdXMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUG9pbnQocG9pbnQ6IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlQb2ludChwb2ludCk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sbGlkZXJzSW5MYXllcihsYXllcjogQ29sbGlzaW9uTGF5ZXIsIGJvdW5kcz86IEJveDMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGJvdW5kcyA/IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoYm91bmRzKSA6IEFycmF5LmZyb20odGhpcy5zcGF0aWFsSGFzaFsnZW50aXR5Q2VsbHMnXS5rZXlzKCkpLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShuZXcgQm94MygpLnNldEZyb21DZW50ZXJBbmRTaXplKG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKDEwMDAsIDEwMDAsIDEwMDApKSk7XG4gICAgICByZXR1cm4gZW50cmllcy5maW5kKGUgPT4gZS5lbnRpdHkuaWQgPT09IGlkKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgYW55W107XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlc1xuICAgICAgLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50cnkuZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlciAmJiBjb2xsaWRlci5sYXllciA9PT0gbGF5ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7XG4gICAgY29sbGlzaW9uQ2hlY2tzOiBudW1iZXI7XG4gICAgYWN0dWFsQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIGFjdGl2ZUNvbGxpc2lvbnM6IG51bWJlcjtcbiAgICBzcGF0aWFsSGFzaFN0YXRzOiBhbnk7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xsaXNpb25DaGVja3M6IHRoaXMuY29sbGlzaW9uQ2hlY2tzLFxuICAgICAgYWN0dWFsQ29sbGlzaW9uczogdGhpcy5hY3R1YWxDb2xsaXNpb25zLFxuICAgICAgYWN0aXZlQ29sbGlzaW9uczogdGhpcy5hY3RpdmVDb2xsaXNpb25zLnNpemUsXG4gICAgICBzcGF0aWFsSGFzaFN0YXRzOiB0aGlzLnNwYXRpYWxIYXNoLmdldFN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHNwYXRpYWwgaGFzaCB3aGVuIGVudGl0eSBpcyByZW1vdmVkXG4gICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuZm9yRWFjaCgocGFpciwga2V5KSA9PiB7XG4gICAgICBpZiAocGFpci5lbnRpdHlBLmlkID09PSBlbnRpdHkuaWQgfHwgcGFpci5lbnRpdHlCLmlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuc3BhdGlhbEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJTcGF0aWFsSGFzaCIsIkNvbGxpc2lvblN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidXBkYXRlU3BhdGlhbEhhc2giLCJkZXRlY3RDb2xsaXNpb25zIiwicHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcyIsInJlc29sdmVDb2xsaXNpb25zIiwiZml4ZWRVcGRhdGUiLCJmaXhlZERlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsImNvbGxpZGVyIiwiZW5hYmxlZCIsInNwYXRpYWxIYXNoIiwicmVtb3ZlIiwidXBkYXRlQm91bmRzIiwiZ2V0V29ybGRQb3NpdGlvbiIsImJvdW5kcyIsImNvbGxpc2lvblBhaXJzIiwibGVuZ3RoIiwiY29sbGlzaW9uQ2hlY2tzIiwiYWN0dWFsQ29sbGlzaW9ucyIsInByb2Nlc3NlZFBhaXJzIiwiU2V0IiwiY2FuZGlkYXRlcyIsInF1ZXJ5IiwiY2FuZGlkYXRlIiwib3RoZXJFbnRpdHkiLCJpZCIsInBhaXJLZXkiLCJoYXMiLCJhZGQiLCJvdGhlclRyYW5zZm9ybSIsIm90aGVyQ29sbGlkZXIiLCJjYW5Db2xsaWRlV2l0aCIsImludGVyc2VjdHMiLCJsYXllciIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsInNlcGFyYXRpb24iLCJzdWIiLCJkaXN0YW5jZSIsIm5vcm1hbGl6ZSIsInJlcXVpcmVkU2VwYXJhdGlvbiIsInR5cGUiLCJyYWRpdXMiLCJyYWRpdXNBIiwiZ2V0QXBwcm94aW1hdGVSYWRpdXMiLCJyYWRpdXNCIiwib3ZlcmxhcCIsInNlcGFyYXRpb25NdWx0aXBsaWVyIiwiaXNTdGF0aWMiLCJzZXBhcmF0aW9uVmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJtb3ZlbWVudEEiLCJtb3ZlbWVudEIiLCJzZXBhcmF0aW9uRmFjdG9yQSIsInNlcGFyYXRpb25GYWN0b3JCIiwiaXNQbGF5ZXJBIiwiUExBWUVSIiwiaXNQbGF5ZXJCIiwiRU5FTVkiLCJjYW5Nb3ZlQSIsImNhbk1vdmUiLCJjYW5Nb3ZlQiIsInNlcGFyYXRpb25BIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVRvd2FyZHNTdGF0aWMiLCJwcm9qZWN0T25WZWN0b3IiLCJuZWdhdGUiLCJzZXBhcmF0aW9uQiIsIk1hdGgiLCJtYXgiLCJzaXplIiwiaGVpZ2h0IiwicXVlcnlDb2xsaWRlcnMiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJxdWVyeUNvbGxpZGVyc1JhZGl1cyIsImNlbnRlciIsInF1ZXJ5UmFkaXVzIiwicXVlcnlDb2xsaWRlcnNQb2ludCIsInBvaW50IiwicXVlcnlQb2ludCIsImdldENvbGxpZGVyc0luTGF5ZXIiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJmaW5kIiwiZSIsImZpbHRlciIsIkJvb2xlYW4iLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwic3BhdGlhbEhhc2hTdGF0cyIsImdldFN0YXRzIiwib25FbnRpdHlSZW1vdmVkIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZGVsZXRlIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNlbGxTaXplIiwicmVxdWlyZWRDb21wb25lbnRzIiwibGFzdFVwZGF0ZVRpbWUiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Throttled logging to reduce spam\n    shouldLogDamage() {\n        const now = Date.now();\n        if (now - this.lastDamageLogTime > this.damageLogThrottle) {\n            this.lastDamageLogTime = now;\n            return true;\n        }\n        return false;\n    }\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update freeze status for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n            console.log(\" CombatSystem processing charge damage: \".concat(baseDamage, \" to \").concat(entityType, \", source: \").concat(source === null || source === void 0 ? void 0 : source.id, \", hasPlayerCallback: \").concat(!!this.onPlayerDamageCallback));\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            console.log(\"\\uD83C\\uDF10 Routing \".concat(actualDamage, \" damage to enemy \").concat(target.id, \" through multiplayer server\"));\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            // Route player damage through multiplayer server for PVP (let receiver handle shields)\n            if (this.shouldLogDamage()) {\n                console.log(\" Routing \".concat(damageResult.damage, \" PVP \").concat(damageType || \"damage\", \" to player \").concat(target.id, \" through multiplayer server\"));\n            }\n            this.onPlayerDamageCallback(target.id.toString(), damageResult.damage, damageType); // Send damage, let receiver handle shields\n            // Create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    // Add slight position offset for delayed damage (like sabres right hit) to prevent overlap\n                    if (damageType === \"sabres_right\") {\n                        position.x += 0.3; // Slight offset to the right for the right sabre\n                    }\n                    this.damageNumberManager.addDamageNumber(damageResult.damage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                    console.warn(\" Skipping PVP damage number creation - invalid position:\", position);\n                }\n            }\n            // Log for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n                const targetName = \"Player \".concat(target.id);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                console.log(\" \".concat(sourceName, \" dealt \").concat(damageResult.damage).concat(critText, \" PVP \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            }\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                    console.warn(\" Skipping damage number creation - invalid position:\", position);\n                }\n            }\n            // Log damage for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                const targetName = this.getEntityDisplayName(target);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            }\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            console.log(\"\\uD83D\\uDC9A \".concat(sourceName, \" healed \").concat(targetName, \" for \").concat(amount, \" HP (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            console.log(\"\\uD83D\\uDC80 \".concat(enemy.getDisplayName(), \" has been defeated!\"));\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        console.log(\"\\uD83D\\uDD04 \".concat(enemy.getDisplayName(), \" has respawned!\"));\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n            console.log(\"\\uD83C\\uDFAF Damage effect\".concat(critText, \" at position:\"), transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                console.log(\"\\uD83C\\uDFF9 Barrage arrow hit detected, applying slow effect to target \".concat(target.id));\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                    console.log(\"\\uD83D\\uDC0C Applied 50% slow for 5 seconds to target \".concat(target.id));\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\" Healing effect at position:\", transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83D\\uDC80 Death effect at position:\", transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83C\\uDF1F Respawn effect at position:\", transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n        // This would integrate with a progression system\n        console.log(\" Entity \".concat(entity.id, \" gained \").concat(experience, \" experience!\"));\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        // Log throttling to reduce spam\n        this.lastDamageLogTime = 0;\n        this.damageLogThrottle = 100 // Only log every 100ms\n        ;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzdCO0FBRVc7QUFDQTtBQUNGO0FBQ1E7QUFDRjtBQUNBO0FBRW1CO0FBQ047QUFpQjNELE1BQU1TLHFCQUFxQlQsK0NBQU1BO0lBOEJ0QyxtQ0FBbUM7SUFDM0JVLGtCQUEyQjtRQUNqQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLElBQUlBLE1BQU0sSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1lBQ3pELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdGO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDhEQUE4RDtJQUN2REksdUJBQXVCQyxRQUFtRCxFQUFRO1FBQ3ZGLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRUEscUVBQXFFO0lBQzlERSx3QkFBd0JGLFFBQXlFLEVBQVE7UUFDOUcsSUFBSSxDQUFDRyxzQkFBc0IsR0FBR0g7SUFDaEM7SUFFT0ksT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxNQUFNQyxjQUFjWCxLQUFLRCxHQUFHLEtBQUs7UUFFakMsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ2Esc0JBQXNCLENBQUNILFVBQVVDLFdBQVdDO1FBRWpELHVCQUF1QjtRQUN2QixJQUFJLENBQUNFLGtCQUFrQixDQUFDRjtRQUV4QixxQkFBcUI7UUFDckIsSUFBSSxDQUFDRyxnQkFBZ0IsQ0FBQ0g7UUFFdEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0kscUJBQXFCLENBQUNOLFVBQVVFO1FBRXJDLDZCQUE2QjtRQUM3QixJQUFJLENBQUNLLG1CQUFtQixDQUFDQyxPQUFPO1FBRWhDLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxN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QUs7YUF2QlNDLHFCQUFxQjtZQUFDM0gsMERBQU1BO1NBQUM7YUFFckM2QixjQUE2QixFQUFFO2FBQy9CRSxZQUF5QixFQUFFO2FBQzNCQyxlQUF5QixFQUFFO1FBR25DLG9CQUFvQjthQUNaeUMsbUJBQW1CO2FBQ25CUyxtQkFBbUI7YUFDbkJJLGdCQUFnQjtRQVF4QixnQ0FBZ0M7YUFDeEIxRSxvQkFBb0I7YUFDcEJDLG9CQUFvQixJQUFLLHVCQUF1Qjs7UUFJdEQsSUFBSSxDQUFDNkcsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQy9GLG1CQUFtQixHQUFHLElBQUlwQiwyRUFBbUJBO1FBQ2xELElBQUksQ0FBQ3FILFFBQVEsR0FBRyxJQUFJLGdDQUFnQztJQUN0RDtBQXFmRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Db21iYXRTeXN0ZW0udHM/YTYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21iYXQgc3lzdGVtIGZvciBoYW5kbGluZyBkYW1hZ2UsIGhlYWxpbmcsIGFuZCBjb21iYXQgbWVjaGFuaWNzXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFNoaWVsZCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvU2hpZWxkJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGFtYWdlLCBEYW1hZ2VSZXN1bHQgfSBmcm9tICdAL2NvcmUvRGFtYWdlQ2FsY3VsYXRvcic7XG5pbXBvcnQgeyBEYW1hZ2VOdW1iZXJNYW5hZ2VyIH0gZnJvbSAnQC91dGlscy9EYW1hZ2VOdW1iZXJNYW5hZ2VyJztcblxuaW50ZXJmYWNlIERhbWFnZUV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGRhbWFnZTogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIGRhbWFnZVR5cGU/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSGVhbEV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGFtb3VudDogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29tYmF0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtIZWFsdGhdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBkYW1hZ2VRdWV1ZTogRGFtYWdlRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGhlYWxRdWV1ZTogSGVhbEV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBkZWFkRW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gIHByaXZhdGUgZGFtYWdlTnVtYmVyTWFuYWdlcjogRGFtYWdlTnVtYmVyTWFuYWdlcjtcbiAgXG4gIC8vIENvbWJhdCBzdGF0aXN0aWNzXG4gIHByaXZhdGUgdG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gIHByaXZhdGUgdG90YWxIZWFsaW5nRG9uZSA9IDA7XG4gIHByaXZhdGUgZW5lbWllc0tpbGxlZCA9IDA7XG5cbiAgLy8gTXVsdGlwbGF5ZXIgZGFtYWdlIGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvbkVuZW15RGFtYWdlQ2FsbGJhY2s/OiAoZW5lbXlJZDogc3RyaW5nLCBkYW1hZ2U6IG51bWJlcikgPT4gdm9pZDtcbiAgXG4gIC8vIFBWUCBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvblBsYXllckRhbWFnZUNhbGxiYWNrPzogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8vIExvZyB0aHJvdHRsaW5nIHRvIHJlZHVjZSBzcGFtXG4gIHByaXZhdGUgbGFzdERhbWFnZUxvZ1RpbWUgPSAwO1xuICBwcml2YXRlIGRhbWFnZUxvZ1Rocm90dGxlID0gMTAwOyAvLyBPbmx5IGxvZyBldmVyeSAxMDBtc1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlciA9IG5ldyBEYW1hZ2VOdW1iZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgY29sbGlzaW9uIGRldGVjdGlvblxuICB9XG5cbiAgLy8gVGhyb3R0bGVkIGxvZ2dpbmcgdG8gcmVkdWNlIHNwYW1cbiAgcHJpdmF0ZSBzaG91bGRMb2dEYW1hZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RGFtYWdlTG9nVGltZSA+IHRoaXMuZGFtYWdlTG9nVGhyb3R0bGUpIHtcbiAgICAgIHRoaXMubGFzdERhbWFnZUxvZ1RpbWUgPSBub3c7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXJcbiAgcHVibGljIHNldEVuZW15RGFtYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIHBsYXllciBkYW1hZ2UgdG8gbXVsdGlwbGF5ZXIgc2VydmVyIChQVlApXG4gIHB1YmxpYyBzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnRzIChyZWdlbmVyYXRpb24sIGludnVsbmVyYWJpbGl0eSB0aW1lcnMpXG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzLCBkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIFByb2Nlc3MgZGFtYWdlIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzRGFtYWdlUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBoZWFsIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIEhhbmRsZSBkZWF0aCBhbmQgcmVzcGF3blxuICAgIHRoaXMuaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzLCBjdXJyZW50VGltZSk7XG5cbiAgICAvLyBDbGVhbnVwIG9sZCBkYW1hZ2UgbnVtYmVyc1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhbnVwKCk7XG5cbiAgICAvLyBDbGVhciBwcm9jZXNzZWQgcXVldWVzXG4gICAgdGhpcy5kYW1hZ2VRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZWFkRW50aXRpZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoQ29tcG9uZW50cyhlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBIZWFsdGggY29tcG9uZW50IGlzIG1pc3NpbmdcbiAgICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFVwZGF0ZSBoZWFsdGggY29tcG9uZW50IChoYW5kbGVzIHJlZ2VuZXJhdGlvbiBhbmQgaW52dWxuZXJhYmlsaXR5KVxuICAgICAgaGVhbHRoLnVwZGF0ZShkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gVXBkYXRlIHNoaWVsZCBjb21wb25lbnQgaWYgaXQgZXhpc3RzXG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIHNoaWVsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGZyZWV6ZSBzdGF0dXMgZm9yIGVuZW1pZXNcbiAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBpZiAoZW5lbXkpIHtcbiAgICAgICAgZW5lbXkudXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBkYW1hZ2VFdmVudCBvZiB0aGlzLmRhbWFnZVF1ZXVlKSB7XG4gICAgICB0aGlzLmFwcGx5RGFtYWdlKGRhbWFnZUV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGhlYWxFdmVudCBvZiB0aGlzLmhlYWxRdWV1ZSkge1xuICAgICAgdGhpcy5hcHBseUhlYWxpbmcoaGVhbEV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBseURhbWFnZShkYW1hZ2VFdmVudDogRGFtYWdlRXZlbnQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRhcmdldCwgZGFtYWdlOiBiYXNlRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUgfSA9IGRhbWFnZUV2ZW50O1xuICAgIFxuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERlYnVnOiBMb2cgYWxsIGRhbWFnZSBldmVudHMgZm9yIGNoYXJnZSBkYW1hZ2VcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ2NoYXJnZScpIHtcbiAgICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBjb25zdCBlbnRpdHlUeXBlID0gZW5lbXkgPyBgRW5lbXkoJHtlbmVteS5nZXREaXNwbGF5TmFtZSgpfSlgIDogYFBsYXllcigke3RhcmdldC5pZH0pYDtcbiAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gQ29tYmF0U3lzdGVtIHByb2Nlc3NpbmcgY2hhcmdlIGRhbWFnZTogJHtiYXNlRGFtYWdlfSB0byAke2VudGl0eVR5cGV9LCBzb3VyY2U6ICR7c291cmNlPy5pZH0sIGhhc1BsYXllckNhbGxiYWNrOiAkeyEhdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrfWApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbiBlbmVteSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15ICYmIHRoaXMub25FbmVteURhbWFnZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcbiAgICAgIFxuICAgICAgLy8gUm91dGUgZW5lbXkgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGluc3RlYWQgb2YgYXBwbHlpbmcgbG9jYWxseVxuICAgICAgY29uc29sZS5sb2coYPCfjJAgUm91dGluZyAke2FjdHVhbERhbWFnZX0gZGFtYWdlIHRvIGVuZW15ICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGFjdHVhbERhbWFnZSk7XG4gICAgICBcbiAgICAgIC8vIFN0aWxsIGNyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKHJvdXRlZCB0byBzZXJ2ZXIpYCk7XG4gICAgICBcbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIGVuZW1pZXNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBpZiBzbywgcm91dGUgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXJcbiAgICAvLyBBbHNvIHByZXZlbnQgc2VsZi1kYW1hZ2UgaW4gUFZQIChzb3VyY2UgaGl0dGluZyB0aGVtc2VsdmVzKVxuICAgIGlmICghZW5lbXkgJiYgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrICYmIHNvdXJjZSAmJiBzb3VyY2UuaWQgIT09IHRhcmdldC5pZCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzXG4gICAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICAgIFxuICAgICAgLy8gUm91dGUgcGxheWVyIGRhbWFnZSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlciBmb3IgUFZQIChsZXQgcmVjZWl2ZXIgaGFuZGxlIHNoaWVsZHMpXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqU77iPIFJvdXRpbmcgJHtkYW1hZ2VSZXN1bHQuZGFtYWdlfSBQVlAgJHtkYW1hZ2VUeXBlIHx8ICdkYW1hZ2UnfSB0byBwbGF5ZXIgJHt0YXJnZXQuaWR9IHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyYCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIGRhbWFnZVR5cGUpOyAvLyBTZW5kIGRhbWFnZSwgbGV0IHJlY2VpdmVyIGhhbmRsZSBzaGllbGRzXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueSArPSAxLjU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIHNsaWdodCBwb3NpdGlvbiBvZmZzZXQgZm9yIGRlbGF5ZWQgZGFtYWdlIChsaWtlIHNhYnJlcyByaWdodCBoaXQpIHRvIHByZXZlbnQgb3ZlcmxhcFxuICAgICAgICAgIGlmIChkYW1hZ2VUeXBlID09PSAnc2FicmVzX3JpZ2h0Jykge1xuICAgICAgICAgICAgcG9zaXRpb24ueCArPSAwLjM7IC8vIFNsaWdodCBvZmZzZXQgdG8gdGhlIHJpZ2h0IGZvciB0aGUgcmlnaHQgc2FicmVcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIC8vIFNob3cgdGhlIGZ1bGwgZGFtYWdlIGluIGRhbWFnZSBudW1iZXJzXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZGFtYWdlVHlwZSB8fCAncHZwJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gU2tpcHBpbmcgUFZQIGRhbWFnZSBudW1iZXIgY3JlYXRpb24gLSBpbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nRGFtYWdlKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBQbGF5ZXIgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IGBQbGF5ZXIgJHt0YXJnZXQuaWR9YDtcbiAgICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gJHtzb3VyY2VOYW1lfSBkZWFsdCAke2RhbWFnZVJlc3VsdC5kYW1hZ2V9JHtjcml0VGV4dH0gUFZQICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAocm91dGVkIHRvIHNlcnZlcilgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuOyAvLyBEb24ndCBhcHBseSBkYW1hZ2UgbG9jYWxseSBmb3IgUFZQIHBsYXllcnNcbiAgICB9XG5cbiAgICAvLyBGb3Igbm9uLWVuZW1pZXMgKGxpa2UgcGxheWVycyBpbiBub24tUFZQIG1vZGUpLCBhcHBseSBkYW1hZ2UgbG9jYWxseSBhcyBiZWZvcmVcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgLy8gQXBwbHkgZGFtYWdlIChwYXNzIGVudGl0eSBzbyBIZWFsdGggY2FuIHVzZSBTaGllbGQgY29tcG9uZW50KVxuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gT2Zmc2V0IHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXRcbiAgICAgICAgICBwb3NpdGlvbi55ICs9IDM7XG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBTa2lwcGluZyBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTG9nIGRhbWFnZSBmb3IgZGVidWdnaW5nICh0aHJvdHRsZWQgdG8gcmVkdWNlIHNwYW0pXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBjcml0VGV4dCA9IGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsID8gJyBDUklUSUNBTCcgOiAnJztcbiAgICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBkaWVkXG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUVudGl0eURlYXRoKHRhcmdldCwgc291cmNlLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZGFtYWdlIGVmZmVjdHNcbiAgICAgIHRoaXMudHJpZ2dlckRhbWFnZUVmZmVjdHModGFyZ2V0LCBhY3R1YWxEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSwgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlIZWFsaW5nKGhlYWxFdmVudDogSGVhbEV2ZW50LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB0YXJnZXQsIGFtb3VudCwgc291cmNlIH0gPSBoZWFsRXZlbnQ7XG4gICAgXG4gICAgY29uc3QgaGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgaGVhbGluZ1xuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICBcbiAgICAgIC8vIExvZyBoZWFsaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgY29uc29sZS5sb2coYPCfkpogJHtzb3VyY2VOYW1lfSBoZWFsZWQgJHt0YXJnZXROYW1lfSBmb3IgJHthbW91bnR9IEhQICgke2hlYWx0aC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuXG4gICAgICAvLyBUcmlnZ2VyIGhlYWxpbmcgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VySGVhbGluZ0VmZmVjdHModGFyZ2V0LCBhbW91bnQsIHNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFbnRpdHlEZWF0aChlbnRpdHk6IEVudGl0eSwga2lsbGVyPzogRW50aXR5LCBjdXJyZW50VGltZT86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgXG4gICAgaWYgKGVuZW15KSB7XG4gICAgICBlbmVteS5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgdGhpcy5lbmVtaWVzS2lsbGVkKys7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KAICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIGJlZW4gZGVmZWF0ZWQhYCk7XG4gICAgICBcbiAgICAgIC8vIEF3YXJkIGV4cGVyaWVuY2UgdG8ga2lsbGVyIGlmIGl0J3MgYSBwbGF5ZXJcbiAgICAgIGlmIChraWxsZXIpIHtcbiAgICAgICAgdGhpcy5hd2FyZEV4cGVyaWVuY2Uoa2lsbGVyLCBlbmVteS5leHBlcmllbmNlUmV3YXJkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5LCBraWxsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZGVhZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzOiBFbnRpdHlbXSwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgXG4gICAgICBpZiAoIWhlYWx0aCB8fCAhZW5lbXkpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBIYW5kbGUgcmVzcGF3biBmb3IgZW5lbWllc1xuICAgICAgaWYgKGVuZW15LmlzRGVhZCAmJiBlbmVteS5jYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLnJlc3Bhd25FbmVteShlbnRpdHksIGVuZW15LCBoZWFsdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzcGF3bkVuZW15KGVudGl0eTogRW50aXR5LCBlbmVteTogRW5lbXksIGhlYWx0aDogSGVhbHRoKTogdm9pZCB7XG4gICAgLy8gUmVzcGF3biB0aGUgZW5lbXlcbiAgICBlbmVteS5yZXNwYXduKCk7XG4gICAgaGVhbHRoLnJldml2ZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SEICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIHJlc3Bhd25lZCFgKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIHJlc3Bhd24gZWZmZWN0c1xuICAgIHRoaXMudHJpZ2dlclJlc3Bhd25FZmZlY3RzKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldDogRW50aXR5LCBkYW1hZ2U6IG51bWJlciwgc291cmNlPzogRW50aXR5LCBkYW1hZ2VUeXBlPzogc3RyaW5nLCBpc0NyaXRpY2FsPzogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcGFydGljbGUgZWZmZWN0cywgc2NyZWVuIHNoYWtlLCBldGMuXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBoYW5kbGUgYmFzaWMgZWZmZWN0c1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb3VsZCB0cmlnZ2VyIGRhbWFnZSBudW1iZXIgcG9wdXAsIGJsb29kIGVmZmVjdHMsIGV0Yy5cbiAgICAgIC8vIEZvciBub3csIGp1c3QgbG9nIHRoZSBwb3NpdGlvbiB3aGVyZSBkYW1hZ2Ugb2NjdXJyZWRcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gaXNDcml0aWNhbCA/ICcgKENSSVRJQ0FMKScgOiAnJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIERhbWFnZSBlZmZlY3Qke2NyaXRUZXh0fSBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWFsIHByb2plY3RpbGUgZWZmZWN0c1xuICAgIGlmIChkYW1hZ2VUeXBlID09PSAncHJvamVjdGlsZScgJiYgc291cmNlKSB7XG4gICAgICBjb25zdCBzb3VyY2VSZW5kZXJlciA9IHNvdXJjZS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgaWYgKHNvdXJjZVJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNCYXJyYWdlQXJyb3cpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfj7kgQmFycmFnZSBhcnJvdyBoaXQgZGV0ZWN0ZWQsIGFwcGx5aW5nIHNsb3cgZWZmZWN0IHRvIHRhcmdldCAke3RhcmdldC5pZH1gKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TW92ZW1lbnQgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgaWYgKHRhcmdldE1vdmVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0TW92ZW1lbnQuc2xvdyg1MDAwLCAwLjUpOyAvLyA1IHNlY29uZHMsIDUwJSBzcGVlZFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5CMIEFwcGxpZWQgNTAlIHNsb3cgZm9yIDUgc2Vjb25kcyB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgYW1vdW50OiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgaGVhbGluZyBwYXJ0aWNsZSBlZmZlY3RzXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinKggSGVhbGluZyBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5OiBFbnRpdHksIGtpbGxlcj86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgZGVhdGggYW5pbWF0aW9ucywgbG9vdCBkcm9wcywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SgCBEZWF0aCBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcmVzcGF3biBhbmltYXRpb25zLCBlZmZlY3RzLCBldGMuXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIFJlc3Bhd24gZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhd2FyZEV4cGVyaWVuY2UoZW50aXR5OiBFbnRpdHksIGV4cGVyaWVuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggYSBwcm9ncmVzc2lvbiBzeXN0ZW1cbiAgICBjb25zb2xlLmxvZyhg4q2QIEVudGl0eSAke2VudGl0eS5pZH0gZ2FpbmVkICR7ZXhwZXJpZW5jZX0gZXhwZXJpZW5jZSFgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50aXR5RGlzcGxheU5hbWUoZW50aXR5OiBFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15KSB7XG4gICAgICByZXR1cm4gZW5lbXkuZ2V0RGlzcGxheU5hbWUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ291bGQgY2hlY2sgZm9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBwcm92aWRlIG5hbWVzXG4gICAgcmV0dXJuIGBFbnRpdHkgJHtlbnRpdHkuaWR9YDtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIG90aGVyIHN5c3RlbXMgdG8gcXVldWUgZGFtYWdlIGFuZCBoZWFsaW5nXG4gIHB1YmxpYyBxdWV1ZURhbWFnZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLnB1c2goe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGFtYWdlLFxuICAgICAgc291cmNlLFxuICAgICAgZGFtYWdlVHlwZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBxdWV1ZUhlYWxpbmcoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBhbW91bnQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbW1lZGlhdGUgZGFtYWdlL2hlYWxpbmcgKGJ5cGFzc2VzIHF1ZXVlKVxuICBwdWJsaWMgZGVhbERhbWFnZUltbWVkaWF0ZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShkYW1hZ2UpO1xuICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYW1hZ2VEZWFsdDtcbiAgfVxuXG4gIHB1YmxpYyBoZWFsSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBhbW91bnQ6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWxpbmdEb25lO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBpc0VudGl0eURlYWQoZW50aXR5OiBFbnRpdHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5pc0RlYWQgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbnRpdHlIZWFsdGhSYXRpbyhlbnRpdHk6IEVudGl0eSk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSA6IDA7XG4gIH1cblxuICBwdWJsaWMgY2FuRW50aXR5VGFrZURhbWFnZShlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gKCFoZWFsdGguaXNEZWFkICYmICFoZWFsdGguaXNJbnZ1bG5lcmFibGUpIDogZmFsc2U7XG4gIH1cblxuICAvLyBTdGF0aXN0aWNzIGFuZCBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldENvbWJhdFN0YXRzKCk6IHtcbiAgICB0b3RhbERhbWFnZURlYWx0OiBudW1iZXI7XG4gICAgdG90YWxIZWFsaW5nRG9uZTogbnVtYmVyO1xuICAgIGVuZW1pZXNLaWxsZWQ6IG51bWJlcjtcbiAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IG51bWJlcjtcbiAgICBxdWV1ZWRIZWFsRXZlbnRzOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbERhbWFnZURlYWx0OiB0aGlzLnRvdGFsRGFtYWdlRGVhbHQsXG4gICAgICB0b3RhbEhlYWxpbmdEb25lOiB0aGlzLnRvdGFsSGVhbGluZ0RvbmUsXG4gICAgICBlbmVtaWVzS2lsbGVkOiB0aGlzLmVuZW1pZXNLaWxsZWQsXG4gICAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoLFxuICAgICAgcXVldWVkSGVhbEV2ZW50czogdGhpcy5oZWFsUXVldWUubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gICAgdGhpcy50b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgICB0aGlzLmVuZW1pZXNLaWxsZWQgPSAwO1xuICB9XG5cbiAgLy8gRGFtYWdlIG51bWJlcnMgbWFuYWdlbWVudFxuICBwdWJsaWMgZ2V0RGFtYWdlTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmdldERhbWFnZU51bWJlcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVEYW1hZ2VOdW1iZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5yZW1vdmVEYW1hZ2VOdW1iZXIoaWQpO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRTdGF0cygpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3lzdGVtIiwiSGVhbHRoIiwiU2hpZWxkIiwiRW5lbXkiLCJUcmFuc2Zvcm0iLCJSZW5kZXJlciIsIk1vdmVtZW50IiwiY2FsY3VsYXRlRGFtYWdlIiwiRGFtYWdlTnVtYmVyTWFuYWdlciIsIkNvbWJhdFN5c3RlbSIsInNob3VsZExvZ0RhbWFnZSIsIm5vdyIsIkRhdGUiLCJsYXN0RGFtYWdlTG9nVGltZSIsImRhbWFnZUxvZ1Rocm90dGxlIiwic2V0RW5lbXlEYW1hZ2VDYWxsYmFjayIsImNhbGxiYWNrIiwib25FbmVteURhbWFnZUNhbGxiYWNrIiwic2V0UGxheWVyRGFtYWdlQ2FsbGJhY2siLCJvblBsYXllckRhbWFnZUNhbGxiYWNrIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsInVwZGF0ZUhlYWx0aENvbXBvbmVudHMiLCJwcm9jZXNzRGFtYWdlUXVldWUiLCJwcm9jZXNzSGVhbFF1ZXVlIiwiaGFuZGxlRGVhdGhBbmRSZXNwYXduIiwiZGFtYWdlTnVtYmVyTWFuYWdlciIsImNsZWFudXAiLCJkYW1hZ2VRdWV1ZSIsImxlbmd0aCIsImhlYWxRdWV1ZSIsImRlYWRFbnRpdGllcyIsImVudGl0eSIsImhlYWx0aCIsImdldENvbXBvbmVudCIsImVuYWJsZWQiLCJzaGllbGQiLCJlbmVteSIsInVwZGF0ZUZyZWV6ZVN0YXR1cyIsImRhbWFnZUV2ZW50IiwiYXBwbHlEYW1hZ2UiLCJoZWFsRXZlbnQiLCJhcHBseUhlYWxpbmciLCJ0YXJnZXQiLCJkYW1hZ2UiLCJiYXNlRGFtYWdlIiwic291cmNlIiwiZGFtYWdlVHlwZSIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImlkIiwiY29uc29sZSIsImxvZyIsImRhbWFnZVJlc3VsdCIsImFjdHVhbERhbWFnZSIsInRvU3RyaW5nIiwidHJhbnNmb3JtIiwicG9zaXRpb24iLCJnZXRXb3JsZFBvc2l0aW9uIiwieSIsImFkZERhbWFnZU51bWJlciIsImlzQ3JpdGljYWwiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImdldEVudGl0eURpc3BsYXlOYW1lIiwiY3JpdFRleHQiLCJ4IiwidW5kZWZpbmVkIiwieiIsIndhcm4iLCJkYW1hZ2VEZWFsdCIsInRha2VEYW1hZ2UiLCJ0b3RhbERhbWFnZURlYWx0IiwiY3VycmVudEhlYWx0aCIsIm1heEhlYWx0aCIsImlzRGVhZCIsImhhbmRsZUVudGl0eURlYXRoIiwidHJpZ2dlckRhbWFnZUVmZmVjdHMiLCJhbW91bnQiLCJoZWFsaW5nRG9uZSIsImhlYWwiLCJ0b3RhbEhlYWxpbmdEb25lIiwidHJpZ2dlckhlYWxpbmdFZmZlY3RzIiwia2lsbGVyIiwiZGllIiwiZW5lbWllc0tpbGxlZCIsImF3YXJkRXhwZXJpZW5jZSIsImV4cGVyaWVuY2VSZXdhcmQiLCJ0cmlnZ2VyRGVhdGhFZmZlY3RzIiwicHVzaCIsImNhblJlc3Bhd25Ob3ciLCJyZXNwYXduRW5lbXkiLCJyZXNwYXduIiwicmV2aXZlIiwidHJpZ2dlclJlc3Bhd25FZmZlY3RzIiwic291cmNlUmVuZGVyZXIiLCJtZXNoIiwidXNlckRhdGEiLCJpc0JhcnJhZ2VBcnJvdyIsInRhcmdldE1vdmVtZW50Iiwic2xvdyIsImV4cGVyaWVuY2UiLCJxdWV1ZURhbWFnZSIsInRpbWVzdGFtcCIsInF1ZXVlSGVhbGluZyIsImRlYWxEYW1hZ2VJbW1lZGlhdGUiLCJoZWFsSW1tZWRpYXRlIiwiaXNFbnRpdHlEZWFkIiwiZ2V0RW50aXR5SGVhbHRoUmF0aW8iLCJnZXRIZWFsdGhSYXRpbyIsImNhbkVudGl0eVRha2VEYW1hZ2UiLCJpc0ludnVsbmVyYWJsZSIsImdldENvbWJhdFN0YXRzIiwicXVldWVkRGFtYWdlRXZlbnRzIiwicXVldWVkSGVhbEV2ZW50cyIsInJlc2V0U3RhdHMiLCJnZXREYW1hZ2VOdW1iZXJzIiwicmVtb3ZlRGFtYWdlTnVtYmVyIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsIndvcmxkIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        } else {\n            console.warn(\" Player Movement component missing updateDebuffs method:\", playerMovement);\n        }\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only if not dashing, charging, frozen, or skyfalling)\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen && !this.isSkyfalling) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n                console.log(\"\\uD83D\\uDDE1 Switched to Sword\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\"\\uD83C\\uDFF9 Switched to Bow\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\" Switched to Scythe\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\" Switched to Sabres\");\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            console.log(\"\\uD83C\\uDFF9 Q key pressed for Barrage!\", {\n                isBarrageCharging: this.isBarrageCharging,\n                isCharging: this.isCharging,\n                isViperStingCharging: this.isViperStingCharging\n            });\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            console.log(\"\\uD83D\\uDC0D E key pressed for Cobra Shot!\", {\n                isCharging: this.isCharging,\n                isViperStingCharging: this.isViperStingCharging,\n                isBarrageCharging: this.isBarrageCharging,\n                isCobraShotCharging: this.isCobraShotCharging,\n                currentWeapon: this.currentWeapon\n            });\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"\\uD83C\\uDFF9 Started charging bow\");\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                console.log(\"\\uD83C\\uDFF9 Cancelling regular bow shot due to ability charging\");\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\" Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            console.log(\" Stopped charging scythe (spinning)\");\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging) {\n            this.fireCrossentropyBoltAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            console.log(\"\\uD83C\\uDFF9 Firing CHARGED ARROW with full charge: \".concat(this.chargeProgress));\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            console.log(\" Firing PERFECT SHOT with charge: \".concat(this.chargeProgress));\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            console.log(\"\\uD83E\\uDDED Firing \".concat(this.currentWeapon, \" at angle: \").concat((angle * 180 / Math.PI).toFixed(1), \"\\xb0\"));\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.5 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        console.log(\" Firing EntropicBolt\".concat(spinStatus, \" - charge: \").concat(this.chargeProgress.toFixed(2), \" - rate: \").concat(this.scytheFireRate, \"s\"));\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    fireCrossentropyBoltAbility(playerTransform) {\n        // Rate limiting - use CrossentropyBolt rate (1 per second)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        this.lastCrossentropyTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        console.log(\" Firing CrossentropyBolt ability (R key) - rate: \".concat(this.crossentropyFireRate, \"s\"));\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            console.log(\"\\uD83C\\uDFF9 No valid targets found, skipping projectile creation\");\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            maxDistance: 25,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            console.log(\" No valid targets found, skipping EntropicBolt creation\");\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            console.log(\" Not enough mana to cast Entropic Bolt (requires 15 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(10);\n            console.log(\" Consumed 15 mana for Entropic Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            console.log(\" Not enough mana to cast Crossentropy Bolt (requires 40 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(40);\n            console.log(\" Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            console.log(\"\\uD83E\\uDE78 Reanimate on cooldown - please wait\");\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(20);\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"\\uD83E\\uDE78 Reanimate mana consumption - Before: \".concat(manaBefore, \", After: \").concat(manaAfter, \", Consumed: \").concat(manaBefore - manaAfter));\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        console.log(\"\\uD83C\\uDF3F Reanimate ability activated - triggering visual effects\");\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 20 HP (doubled from 10)\n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(30); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n                console.log(\"\\uD83E\\uDE78 Reanimate healed player for 20 HP. Current health: \".concat(healthComponent.currentHealth, \"/\").concat(healthComponent.maxHealth));\n            } else {\n                console.log(\"\\uD83E\\uDE78 Reanimate cast successfully but player already at full health\");\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        console.log(\"\\uD83C\\uDF3F Triggering Reanimate healing effect\");\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n        console.log(\"\\uD83C\\uDF3F Healing effect at position: \".concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2)));\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            console.log(\" Frost Nova on cooldown for \".concat((this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough mana (25 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            console.log(\" Not enough mana to cast Frost Nova (requires 25 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(50);\n            console.log(\" Consumed 25 mana for Frost Nova\");\n        }\n        this.lastFrostNovaTime = currentTime;\n        console.log(\" Frost Nova ability activated!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            console.log(\"\\uD83D\\uDC0D Cobra Shot on cooldown for \".concat((this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            console.log(\"\\uD83D\\uDC0D Not enough energy to cast Cobra Shot (requires 40 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n            console.log(\"\\uD83D\\uDC0D Consumed 40 energy for Cobra Shot\");\n        }\n        console.log(\"\\uD83D\\uDC0D Cobra Shot activated - starting charge!\");\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        console.log(\"\\uD83D\\uDC0D Firing Cobra Shot projectile!\");\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 1; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    console.log(\" Frozen enemy at distance \".concat(distance.toFixed(2), \" units\"));\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        console.log(\" Frost Nova hit player \".concat(entity.id, \" for \").concat(frostNovaDamage, \" damage at distance \").concat(distance.toFixed(2), \" units\"));\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            console.log(\" Broadcasting freeze effect to PVP player \".concat(entity.id));\n                            console.log(\"\\uD83D\\uDD0D Debug: Calling debuff callback with entityId=\".concat(entity.id, \", type=frozen, duration=3000\"));\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                            console.log(\" Debug: Debuff callback completed\");\n                        } else {\n                            console.warn(\" Debug: onDebuffCallback is not set!\");\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n            console.log(\" Frost Nova froze \".concat(frozenCount, \" enemies within \").concat(radius, \" unit radius\"));\n        }\n        if (damagedPlayers > 0) {\n            console.log(\" Frost Nova damaged \".concat(damagedPlayers, \" players within \").concat(radius, \" unit radius\"));\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 2,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n        console.log(\" Perfect shot projectile created with enhanced stats!\");\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n        console.log(\"\\uD83C\\uDFF9 Weapon subclass changed to: \".concat(subclass));\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setSkyfallCallback(callback) {\n        this.onSkyfallCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        this.onDebuffCallback = callback;\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.75; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n        console.log(\" Weapon level changed to: \".concat(level));\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    isSkyfallActive() {\n        return this.isSkyfalling;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging) {\n            this.performDeflect(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        console.log(\"\\uD83D\\uDDE1 Sword melee attack - Combo step \".concat(this.swordComboStep));\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"\\uD83D\\uDDE1 Sword swing completed - was combo step \".concat(this.swordComboStep));\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n        console.log(\"\\uD83D\\uDDE1 Next combo step will be: \".concat(this.swordComboStep));\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSkyfalling) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n        // Handle E key for Skyfall ability\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSkyfalling) {\n            console.log(\"\\uD83C\\uDF1F E key pressed for Skyfall - attempting to perform ability\");\n            this.performSkyfall(playerTransform);\n        }\n        // Update Skyfall state if active\n        if (this.isSkyfalling) {\n            this.updateSkyfallMovement(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\" Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\" Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 3.8; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19; // Damage per sabre\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n                console.log(\" Sabres hit target at distance \".concat(distanceToTarget.toFixed(2), \" for \").concat(leftSabreDamage + rightSabreDamage, \" total damage\"));\n            }\n        }\n        if (hitCount === 0) {\n            console.log(\" Sabres attack missed - no targets in range\");\n        } else {\n            console.log(\" Sabres attack hit \".concat(hitCount, \" target(s)\"));\n        }\n    }\n    // Skyfall ability implementation\n    performSkyfall(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSkyfallTime < this.skyfallCooldown) {\n            console.log(\"\\uD83C\\uDF1F Skyfall on cooldown for \".concat((this.skyfallCooldown - (currentTime - this.lastSkyfallTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSkyfall()) {\n            console.log(\"\\uD83C\\uDF1F Not enough energy for Skyfall (requires 40 energy)\");\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(40);\n        // Start Skyfall\n        this.isSkyfalling = true;\n        this.skyfallPhase = \"ascending\";\n        this.skyfallStartTime = currentTime;\n        this.lastSkyfallTime = currentTime;\n        this.skyfallStartPosition.copy(playerTransform.position);\n        // Set target height (double jump height)\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            this.skyfallOriginalGravity = playerMovement.gravity;\n            this.skyfallTargetHeight = playerTransform.position.y + playerMovement.jumpForce * 2; // Double jump height\n            console.log(\"\\uD83C\\uDF1F Skyfall Setup - Original Gravity: \".concat(this.skyfallOriginalGravity, \", Jump Force: \").concat(playerMovement.jumpForce, \", Start Y: \").concat(playerTransform.position.y.toFixed(2), \", Target Y: \").concat(this.skyfallTargetHeight.toFixed(2)));\n            // Apply upward velocity\n            playerMovement.velocity.y = playerMovement.jumpForce * 1.8; // Stronger initial velocity\n            playerMovement.gravity = 0; // Disable gravity during ascent\n            // Don't disable canMove as it prevents all physics updates including gravity\n            // Instead we'll control horizontal movement in the ControlSystem\n            console.log(\"\\uD83C\\uDF1F Applied velocity Y: \".concat(playerMovement.velocity.y.toFixed(2), \", Set gravity to: \").concat(playerMovement.gravity));\n        }\n        console.log(\"\\uD83C\\uDF1F Skyfall initiated! Ascending to height \".concat(this.skyfallTargetHeight.toFixed(2)));\n        // Trigger callback for multiplayer/visual effects\n        if (this.onSkyfallCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onSkyfallCallback(playerTransform.position, direction);\n        }\n    }\n    updateSkyfallMovement(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerMovement) return;\n        const elapsedTime = currentTime - this.skyfallStartTime;\n        // Debug logging (throttled to avoid spam)\n        if (Math.floor(elapsedTime * 4) !== Math.floor((elapsedTime - 0.25) * 4)) {\n            console.log(\"\\uD83C\\uDF1F Skyfall Update - Phase: \".concat(this.skyfallPhase, \", Y: \").concat(playerTransform.position.y.toFixed(2), \", Target: \").concat(this.skyfallTargetHeight.toFixed(2), \", Velocity Y: \").concat(playerMovement.velocity.y.toFixed(2), \", Elapsed: \").concat(elapsedTime.toFixed(2), \"s\"));\n        }\n        switch(this.skyfallPhase){\n            case \"ascending\":\n                // Check if we've reached target height or started falling\n                if (playerTransform.position.y >= this.skyfallTargetHeight || playerMovement.velocity.y <= 0) {\n                    this.skyfallPhase = \"descending\";\n                    playerMovement.velocity.y = 0; // Stop at peak\n                    playerMovement.gravity = this.skyfallOriginalGravity * 30; // Faster descent\n                    console.log(\"\\uD83C\\uDF1F Skyfall: Reached peak, beginning descent\");\n                }\n                break;\n            case \"descending\":\n                // Check if we've landed (close to original height or on ground)\n                if (playerTransform.position.y <= this.skyfallStartPosition.y + 0.5) {\n                    this.skyfallPhase = \"landing\";\n                    this.performSkyfallLanding(playerTransform);\n                }\n                break;\n            case \"landing\":\n                // Landing phase complete\n                this.completeSkyfallAbility(playerTransform);\n                break;\n        }\n        // Safety timeout (if something goes wrong, end after 5 seconds)\n        if (elapsedTime > 5.0) {\n            console.log(\"\\uD83C\\uDF1F Skyfall timeout - force completing\");\n            this.completeSkyfallAbility(playerTransform);\n        }\n    }\n    performSkyfallLanding(playerTransform) {\n        console.log(\"\\uD83C\\uDF1F Skyfall: Landing impact!\");\n        // Deal damage to enemies in landing area\n        const allEntities = this.world.getAllEntities();\n        const landingPosition = playerTransform.position;\n        const damageRadius = 4.0; // 4 unit radius\n        const skyfallDamage = 150; // 150 damage as requested\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check distance to landing position\n            const distanceToLanding = landingPosition.distanceTo(targetTransform.position);\n            if (distanceToLanding <= damageRadius) {\n                // Apply Skyfall damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem) {\n                    combatSystem.queueDamage(entity, skyfallDamage, this.playerEntity || undefined);\n                    hitCount++;\n                    console.log(\"\\uD83C\\uDF1F Skyfall hit target at distance \".concat(distanceToLanding.toFixed(2), \" for \").concat(skyfallDamage, \" damage\"));\n                }\n            }\n        }\n        if (hitCount === 0) {\n            console.log(\"\\uD83C\\uDF1F Skyfall landing missed - no targets in range\");\n        } else {\n            console.log(\"\\uD83C\\uDF1F Skyfall landing hit \".concat(hitCount, \" target(s)\"));\n        }\n    }\n    completeSkyfallAbility(playerTransform) {\n        var _this_playerEntity;\n        // Reset all Skyfall states\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        // Restore player movement\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            playerMovement.gravity = this.skyfallOriginalGravity;\n            playerMovement.velocity.y = 0; // Stop any remaining vertical movement\n        }\n        console.log(\"\\uD83C\\uDF1F Skyfall ability completed\");\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.6; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step - works for all subclasses\n        let baseDamage = 45; // Base sword damage\n        // Combo damage scaling\n        switch(this.swordComboStep){\n            case 1:\n                baseDamage = 45;\n                break;\n            case 2:\n                baseDamage = 50;\n                break;\n            case 3:\n                baseDamage = 60;\n                break; // Finisher does more damage\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            console.log(\"\\uD83C\\uDFAF PVP Sword check - Entity \".concat(entity.id, \": Player pos (\").concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2), \"), Enemy pos (\").concat(enemyPosition.x.toFixed(2), \", \").concat(enemyPosition.y.toFixed(2), \", \").concat(enemyPosition.z.toFixed(2), \"), Distance: \").concat(distance.toFixed(2), \", Range: \").concat(meleeRange));\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                console.log(\"\\uD83C\\uDFAF PVP Sword angle check - Entity \".concat(entity.id, \": Angle \").concat(angleDegrees.toFixed(1), \"\\xb0, Max angle: \").concat(maxAngleDegrees.toFixed(1), \"\\xb0\"));\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    console.log(\"\\uD83D\\uDDE1 PVP Sword hit confirmed! Entity \".concat(entity.id, \" at distance \").concat(distance.toFixed(2), \", angle \").concat(angleDegrees.toFixed(1), \"\\xb0\"));\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        console.log(\"\\uD83D\\uDCA5 Queued \".concat(baseDamage, \" melee damage to entity \").concat(entity.id, \" (combo step \").concat(this.swordComboStep, \")\"));\n                        enemiesHit++;\n                    }\n                } else {\n                    console.log(\" PVP Sword missed - Entity \".concat(entity.id, \" outside attack cone (\").concat(angleDegrees.toFixed(1), \"\\xb0 > \").concat(maxAngleDegrees.toFixed(1), \"\\xb0)\"));\n                }\n            } else {\n                console.log(\" PVP Sword missed - Entity \".concat(entity.id, \" out of range (\").concat(distance.toFixed(2), \" > \").concat(meleeRange, \")\"));\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageBefore = gameUI.getCurrentRage ? gameUI.getCurrentRage() : \"unknown\";\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n                const rageAfter = gameUI.getCurrentRage ? gameUI.getCurrentRage() : \"unknown\";\n                console.log(\"\\uD83D\\uDDE1 Gained \".concat(rageToGain, \" rage from hitting \").concat(enemiesHit, \" enemies with sword combo \").concat(this.swordComboStep, \" - Rage: \").concat(rageBefore, \"  \").concat(rageAfter));\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                console.log(\"\\uD83D\\uDD0D Double tap detected for key '\".concat(key.toUpperCase(), \"':\"), debugInfo);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    console.log(\"\\uD83C\\uDFC3 Dash started in direction: \".concat(key.toUpperCase()));\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                } else {\n                    console.warn(\" Dash failed to start for key: \".concat(key.toUpperCase()));\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                console.warn(\"Dash cancelled: would move too far from origin (\".concat(distanceFromOrigin.toFixed(2), \" > \").concat(MAX_DASH_BOUNDS, \")\"));\n                movement.cancelDash();\n            }\n        }\n        if (dashResult.isComplete) {\n            console.log(\"\\uD83C\\uDFC1 Dash completed\");\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                console.warn(\"Charge cancelled: would move too far from origin (\".concat(distanceFromOrigin.toFixed(2), \" > \").concat(MAX_CHARGE_BOUNDS, \")\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\" Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            console.log(\" Not enough rage to cast Divine Storm (requires minimum 20 rage)\");\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            console.log(\" Divine Storm on cooldown for \".concat((this.divineStormCooldown - (currentTime - this.lastDivineStormTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 40 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n            console.log(\" Consumed \".concat(currentRage, \" rage for Divine Storm\"));\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        console.log(\" Divine Storm activated! Duration: \".concat(totalDivineStormDuration / 1000, \"s (base: 4s + bonus: \").concat(bonusDuration / 1000, \"s from \").concat(currentRage, \" rage)\"));\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n            console.log(\" Divine Storm completed\");\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            console.log(\" Charge on cooldown for \".concat((this.chargeCooldown - (currentTime - this.lastChargeTime)).toFixed(1), \"s\"));\n            return;\n        }\n        console.log(\" Charge activated!\");\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n            console.log(\" Gained 20 rage from using Charge ability\");\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    console.log(\" Charge movement started with 10.5 distance\");\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                } else {\n                    console.warn(\" Charge failed to start (already charging or dashing)\");\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.75; // Charge lasts about 1.5 seconds\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            console.log(\"\\uD83D\\uDD0D Charge collision check - Total entities in world: \".concat(allEntities.length));\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            console.log(\"\\uD83D\\uDD0D Also checking \".concat(serverPlayers.size, \" server players directly for collision\"));\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                console.log(\"\\uD83D\\uDD0D Direct server player check - \".concat(playerId, \": distance=\").concat(distance.toFixed(2), \", stopDistance=\").concat(stopDistance.toFixed(2)));\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    console.log(\" Direct server collision detected with player \".concat(playerId, \"!\"));\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                console.log(\"\\uD83D\\uDD0D Checking entity \".concat(entity.id, \" (\").concat(entityType, \"): transform=\").concat(!!entityTransform, \", health=\").concat(!!entityHealth, \", collider=\").concat(!!entityCollider, \", isDead=\").concat(entityHealth === null || entityHealth === void 0 ? void 0 : entityHealth.isDead));\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                console.log(\"\\uD83D\\uDD0D Entity \".concat(entity.id, \" (\").concat(entityType, \"): playerPos=[\").concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2), \"], entityPos=[\").concat(entityPosition.x.toFixed(2), \", \").concat(entityPosition.y.toFixed(2), \", \").concat(entityPosition.z.toFixed(2), \"], distance=\").concat(distance.toFixed(2), \", stopDistance=\").concat(stopDistance.toFixed(2), \", colliderRadius=\").concat((entityCollider === null || entityCollider === void 0 ? void 0 : entityCollider.radius) || \"none\"));\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        console.log(\" Charge hit \".concat(entityType, \" for \").concat(chargeDamage, \" damage at distance \").concat(distance.toFixed(2)));\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                console.log(\" Charge stopped by collision - ending charge movement\");\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        console.log(\" Charge completed\");\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            console.log(\" Deflect on cooldown for \".concat((this.deflectCooldown - (currentTime - this.lastDeflectTime)).toFixed(1), \"s\"));\n            return;\n        }\n        console.log(\"\\uD83D\\uDEE1 Deflect activated!\");\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            console.log(\" Viper Sting on cooldown for \".concat((this.viperStingFireRate - (currentTime - this.lastViperStingTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            console.log(\"\\uD83D\\uDC0D Not enough energy to cast Viper Sting (requires 60 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n            console.log(\"\\uD83D\\uDC0D Consumed 60 energy for Viper Sting\");\n        }\n        console.log(\"\\uD83D\\uDC0D Viper Sting activated - starting charge!\");\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        console.log(\"\\uD83D\\uDC0D Firing Viper Sting projectile!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 1; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalViperSting)();\n        if (success) {\n            console.log(\"\\uD83D\\uDC0D Viper Sting visual effects successfully triggered!\");\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        console.log(\"\\uD83C\\uDFF9 performBarrage called!\");\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\" Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            console.log(\"\\uD83C\\uDFF9 Not enough energy to cast Barrage (requires 40 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n            console.log(\"\\uD83C\\uDFF9 Consumed 40 energy for Barrage\");\n        }\n        console.log(\"\\uD83C\\uDFF9 Barrage activated - starting charge!\");\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        console.log(\"\\uD83C\\uDFF9 Firing Barrage projectiles!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 1; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0), left (15, 30), right (-15, -30) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0, 15, -15, 30, -30\n        angles.forEach((angle)=>{\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                maxDistance: 25,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n            console.log(\"\\uD83C\\uDFF9 Created Barrage arrow \".concat(projectileEntity.id, \" at angle \").concat((angle * 180 / Math.PI).toFixed(1), \"\\xb0\"));\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n        console.log(\"\\uD83C\\uDFF9 Barrage successfully fired with 5 ECS projectiles!\");\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        console.log(\"\\uD83D\\uDEE1 Deflect completed\");\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: false\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            cooldowns[\"Q\"] = {\n                current: 0,\n                max: 0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.skyfallCooldown - (currentTime - this.lastSkyfallTime)),\n                max: this.skyfallCooldown,\n                isActive: this.isSkyfalling\n            };\n            cooldowns[\"R\"] = {\n                current: 0,\n                max: 0,\n                isActive: false\n            };\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.225 // Default for bow\n        ;\n        this.swordFireRate = 0.9 // Slower rate for sword attacks (800ms between attacks)\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.33 // EntropicBolt rate (0.5s cooldown)\n        ;\n        this.crossentropyFireRate = 2 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.0 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.reanimateFireRate = 1.5 // Reanimate rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.0 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 1 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 8.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 6.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        // Skyfall ability state (Sabres)\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.lastSkyfallTime = 0;\n        this.skyfallCooldown = 5.0 // 4 second cooldown\n        ;\n        this.skyfallStartTime = 0;\n        this.skyfallStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.skyfallTargetHeight = 0;\n        this.skyfallOriginalGravity = 0;\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 3 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBQ2M7QUFHbkI7QUFFaUI7QUFDRjtBQUNKO0FBQ0Y7QUFDTTtBQUNBO0FBSVA7QUFDMkI7QUFDSjtBQUNnQztBQUNsQjtBQUNFO0FBRTlFLE1BQU1pQixzQkFBc0JmLCtDQUFNQTtJQW1JaENnQixVQUFVQyxNQUFjLEVBQVE7UUFDckMsSUFBSSxDQUFDQyxZQUFZLEdBQUdEO0lBQ3RCO0lBRU9FLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQ0gsWUFBWSxFQUFFO1FBRXhCLE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLFlBQVksQ0FBQ0ssWUFBWSxDQUFDdEIsZ0VBQVNBO1FBQ2hFLE1BQU11QixpQkFBaUIsSUFBSSxDQUFDTixZQUFZLENBQUNLLFlBQVksQ0FBQ3JCLDhEQUFRQTtRQUU5RCxJQUFJLENBQUNvQixtQkFBbUIsQ0FBQ0UsZ0JBQWdCO1FBRXpDLDZCQUE2QjtRQUM3QixJQUFJLE9BQU9BLGVBQWVDLGFBQWEsS0FBSyxZQUFZO1lBQ3RERCxlQUFlQyxhQUFhO1FBQzlCLE9BQU87WUFDTEMsUUFBUUMsSUFBSSxDQUFDLDhEQUE4REg7UUFDN0U7UUFFQSwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDSSxxQkFBcUI7UUFFMUIsMERBQTBEO1FBQzFELElBQUksQ0FBQ0Msa0JBQWtCLENBQUNMLGdCQUFnQkY7UUFFeEMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ1Esb0JBQW9CLENBQUNOLGdCQUFnQkY7UUFFMUMsc0ZBQXNGO1FBQ3RGLElBQUksQ0FBQ0UsZUFBZU8sU0FBUyxJQUFJLENBQUNQLGVBQWVRLFVBQVUsSUFBSSxDQUFDUixlQUFlUyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUM3RyxJQUFJLENBQUNDLG1CQUFt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Q0FBNEM7O1FBNjRDOUUsdURBQXVEO2FBQ3RDd1MsbUJBQW1CO1lBQ2xDLElBQUl4Vyx5REFBT0EsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQixJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLE1BQU0sR0FBRztZQUN0QixJQUFJQSx5REFBT0EsQ0FBQyxNQUFNLEdBQUcsS0FBUyxlQUFlO1NBQzlDO2FBQ2dCMlcsZ0JBQWdCLElBQUssOEJBQThCOztRQXNKcEUsbUZBQW1GO2FBQzNFcUIsb0JBQW9CLElBQUlnRTthQUN4QnJHLDJCQUEyQjtRQTlwRGpDLElBQUksQ0FBQ3hTLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNQLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDa0YsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3dCLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUM2UixjQUFjLEdBQUcsSUFBSXZhLCtFQUFjQSxDQUFDa0g7UUFDekMsSUFBSSxDQUFDbVUsUUFBUSxHQUFHLEdBQUcsK0JBQStCO0lBQ3BEO0FBeXJFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Db250cm9sU3lzdGVtLnRzPzJjMjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29udHJvbCBzeXN0ZW0gZm9yIHBsYXllciBpbnB1dCBoYW5kbGluZ1xuaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5cbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJ0AvY29yZS9JbnB1dE1hbmFnZXInO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBQcm9qZWN0aWxlU3lzdGVtIH0gZnJvbSAnLi9Qcm9qZWN0aWxlU3lzdGVtJztcbmltcG9ydCB7IENvbWJhdFN5c3RlbSB9IGZyb20gJy4vQ29tYmF0U3lzdGVtJztcbmltcG9ydCB7IFdlYXBvblN1YmNsYXNzLCBXZWFwb25UeXBlIH0gZnJvbSAnQC9jb21wb25lbnRzL2RyYWdvbi93ZWFwb25zJztcbmltcG9ydCB7IERlZmxlY3RCYXJyaWVyIH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvRGVmbGVjdEJhcnJpZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbEZyb3N0Tm92YSwgYWRkR2xvYmFsRnJvemVuRW5lbXkgfSBmcm9tICdAL2NvbXBvbmVudHMvd2VhcG9ucy9Gcm9zdE5vdmFNYW5hZ2VyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxDb2JyYVNob3QgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvQ29icmFTaG90TWFuYWdlcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsVmlwZXJTdGluZyB9IGZyb20gJ0AvY29tcG9uZW50cy9wcm9qZWN0aWxlcy9WaXBlclN0aW5nTWFuYWdlcic7XG5cbmV4cG9ydCBjbGFzcyBDb250cm9sU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIE1vdmVtZW50XTtcbiAgcHJpdmF0ZSBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlcjtcbiAgcHJpdmF0ZSBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBwcm9qZWN0aWxlU3lzdGVtOiBQcm9qZWN0aWxlU3lzdGVtO1xuICBwcml2YXRlIHBsYXllckVudGl0eTogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgYm93IHJlbGVhc2UgZWZmZWN0c1xuICBwcml2YXRlIG9uQm93UmVsZWFzZUNhbGxiYWNrPzogKGZpbmFsUHJvZ3Jlc3M6IG51bWJlciwgaXNQZXJmZWN0U2hvdD86IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRGl2aW5lIFN0b3JtIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkRpdmluZVN0b3JtQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZHVyYXRpb246IG51bWJlcikgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBwcm9qZWN0aWxlIGNyZWF0aW9uXG4gIHByaXZhdGUgb25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrPzogKHByb2plY3RpbGVUeXBlOiBzdHJpbmcsIHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGNvbmZpZzogYW55KSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFZpcGVyIFN0aW5nIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvblZpcGVyU3RpbmdDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEJhcnJhZ2UgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uQmFycmFnZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgUmVhbmltYXRlIGhlYWxpbmcgZWZmZWN0XG4gIHByaXZhdGUgb25SZWFuaW1hdGVDYWxsYmFjaz86ICgpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRnJvc3QgTm92YSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25Gcm9zdE5vdmFDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIENvYnJhIFNob3QgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uQ29icmFTaG90Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBDaGFyZ2UgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uQ2hhcmdlQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBEZWZsZWN0IGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkRlZmxlY3RDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJyb2FkY2FzdGluZyBkZWJ1ZmYgZWZmZWN0cyBpbiBQVlBcbiAgcHJpdmF0ZSBvbkRlYnVmZkNhbGxiYWNrPzogKHRhcmdldEVudGl0eUlkOiBudW1iZXIsIGRlYnVmZlR5cGU6ICdmcm96ZW4nIHwgJ3Nsb3dlZCcsIGR1cmF0aW9uOiBudW1iZXIsIHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFNreWZhbGwgYWJpbGl0eVxuICBwcml2YXRlIG9uU2t5ZmFsbENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBSYXRlIGxpbWl0aW5nIGZvciBwcm9qZWN0aWxlIGZpcmluZ1xuICBwcml2YXRlIGxhc3RGaXJlVGltZSA9IDA7XG4gIHByaXZhdGUgbGFzdENyb3NzZW50cm9weVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICBwcml2YXRlIGxhc3RSZWFuaW1hdGVUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIFJlYW5pbWF0ZSBhYmlsaXR5XG4gIHByaXZhdGUgbGFzdFZpcGVyU3RpbmdUaW1lID0gMDtcbiAgcHJpdmF0ZSBsYXN0RnJvc3ROb3ZhVGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBGcm9zdCBOb3ZhIGFiaWxpdHlcbiAgcHJpdmF0ZSBsYXN0Q29icmFTaG90VGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBDb2JyYSBTaG90IGFiaWxpdHlcbiAgcHJpdmF0ZSBmaXJlUmF0ZSA9IDAuMjI1OyAvLyBEZWZhdWx0IGZvciBib3dcbiAgcHJpdmF0ZSBzd29yZEZpcmVSYXRlID0gMC45OyAvLyBTbG93ZXIgcmF0ZSBmb3Igc3dvcmQgYXR0YWNrcyAoODAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNhYnJlc0ZpcmVSYXRlID0gMC42OyAvLyBTYWJyZXMgZHVhbCBhdHRhY2sgcmF0ZSAoNjAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNjeXRoZUZpcmVSYXRlID0gMC4zMzsgLy8gRW50cm9waWNCb2x0IHJhdGUgKDAuNXMgY29vbGRvd24pXG4gIHByaXZhdGUgY3Jvc3NlbnRyb3B5RmlyZVJhdGUgPSAyOyAvLyBDcm9zc2VudHJvcHlCb2x0IHJhdGUgKDEgcGVyIHNlY29uZClcbiAgcHJpdmF0ZSB2aXBlclN0aW5nRmlyZVJhdGUgPSAyLjA7IC8vIFZpcGVyIFN0aW5nIHJhdGUgKDIgc2Vjb25kcyBjb29sZG93bilcbiAgcHJpdmF0ZSByZWFuaW1hdGVGaXJlUmF0ZSA9IDEuNTsgLy8gUmVhbmltYXRlIHJhdGUgKDIgc2Vjb25kcyBjb29sZG93bilcbiAgcHJpdmF0ZSBmcm9zdE5vdmFGaXJlUmF0ZSA9IDEyLjA7IC8vIEZyb3N0IE5vdmEgcmF0ZSAoMTIgc2Vjb25kcyBjb29sZG93bilcbiAgcHJpdmF0ZSBjb2JyYVNob3RGaXJlUmF0ZSA9IDIuMDsgLy8gQ29icmEgU2hvdCByYXRlICgyIHNlY29uZHMgY29vbGRvd24pXG4gIFxuICAvLyBDdXJyZW50IHdlYXBvbiBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgY3VycmVudFdlYXBvbjogV2VhcG9uVHlwZSA9IFdlYXBvblR5cGUuQk9XOyAvLyBEZWZhdWx0IHdlYXBvblxuICBwcml2YXRlIGN1cnJlbnRTdWJjbGFzczogV2VhcG9uU3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5FTEVNRU5UQUw7IC8vIERlZmF1bHQgZm9yIGJvd1xuICBwcml2YXRlIGN1cnJlbnRMZXZlbCA9IDE7XG4gIFxuICAvLyBXZWFwb24tc3BlY2lmaWMgc3RhdGVzXG4gIHByaXZhdGUgaXNDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGNoYXJnZVByb2dyZXNzID0gMDtcbiAgcHJpdmF0ZSBpc1N3aW5naW5nID0gZmFsc2U7XG4gIFxuICAvLyBWaXBlciBTdGluZyBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzVmlwZXJTdGluZ0NoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgdmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gMDtcbiAgXG4gIC8vIEJhcnJhZ2UgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0JhcnJhZ2VDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIHByaXZhdGUgbGFzdEJhcnJhZ2VUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYXJyYWdlRmlyZVJhdGUgPSA1LjA7IC8vIDUgc2Vjb25kIGNvb2xkb3duIChrZWVwaW5nIGFzIHJlcXVlc3RlZClcbiAgXG4gIC8vIENvYnJhIFNob3QgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0NvYnJhU2hvdENoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBcbiAgLy8gU3dvcmQtc3BlY2lmaWMgc3RhdGVzXG4gIHByaXZhdGUgc3dvcmRDb21ib1N0ZXA6IDEgfCAyIHwgMyA9IDE7XG4gIHByaXZhdGUgbGFzdFN3b3JkQXR0YWNrVGltZSA9IDA7XG4gIHByaXZhdGUgc3dvcmRDb21ib1Jlc2V0VGltZSA9IDE7IC8vIFJlc2V0IGNvbWJvIGFmdGVyIDEgc2Vjb25kc1xuICBcbiAgLy8gRGl2aW5lIFN0b3JtIGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc0RpdmluZVN0b3JtaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdERpdmluZVN0b3JtVGltZSA9IDA7XG4gIHByaXZhdGUgZGl2aW5lU3Rvcm1Db29sZG93biA9IDguMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgXG4gIC8vIENoYXJnZSBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNTd29yZENoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdENoYXJnZVRpbWUgPSAwO1xuICBwcml2YXRlIGNoYXJnZUNvb2xkb3duID0gOC4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBcbiAgLy8gRGVmbGVjdCBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdERlZmxlY3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBkZWZsZWN0Q29vbGRvd24gPSA2LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgZGVmbGVjdER1cmF0aW9uID0gMy4wOyAvLyAzIHNlY29uZCBkdXJhdGlvblxuICBwcml2YXRlIGRlZmxlY3RCYXJyaWVyOiBEZWZsZWN0QmFycmllcjtcbiAgXG4gIC8vIFNreWZhbGwgYWJpbGl0eSBzdGF0ZSAoU2FicmVzKVxuICBwcml2YXRlIGlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHNreWZhbGxQaGFzZTogJ25vbmUnIHwgJ2FzY2VuZGluZycgfCAnZGVzY2VuZGluZycgfCAnbGFuZGluZycgPSAnbm9uZSc7XG4gIHByaXZhdGUgbGFzdFNreWZhbGxUaW1lID0gMDtcbiAgcHJpdmF0ZSBza3lmYWxsQ29vbGRvd24gPSA1LjA7IC8vIDQgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgc2t5ZmFsbFN0YXJ0VGltZSA9IDA7XG4gIHByaXZhdGUgc2t5ZmFsbFN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIHNreWZhbGxUYXJnZXRIZWlnaHQgPSAwO1xuICBwcml2YXRlIHNreWZhbGxPcmlnaW5hbEdyYXZpdHkgPSAwO1xuICBjb25zdHJ1Y3RvcihcbiAgICBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhLCBcbiAgICBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlciwgXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW1cbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IGlucHV0TWFuYWdlcjtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtID0gcHJvamVjdGlsZVN5c3RlbTtcbiAgICB0aGlzLmRlZmxlY3RCYXJyaWVyID0gbmV3IERlZmxlY3RCYXJyaWVyKHdvcmxkKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gNTsgLy8gUnVuIGVhcmx5IGZvciBpbnB1dCBoYW5kbGluZ1xuICB9XG5cbiAgcHVibGljIHNldFBsYXllcihlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIHRoaXMucGxheWVyRW50aXR5ID0gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGxheWVyVHJhbnNmb3JtID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIFxuICAgIGlmICghcGxheWVyVHJhbnNmb3JtIHx8ICFwbGF5ZXJNb3ZlbWVudCkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIGRlYnVmZiBzdGF0ZXMgZmlyc3RcbiAgICBpZiAodHlwZW9mIHBsYXllck1vdmVtZW50LnVwZGF0ZURlYnVmZnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsYXllck1vdmVtZW50LnVwZGF0ZURlYnVmZnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUGxheWVyIE1vdmVtZW50IGNvbXBvbmVudCBtaXNzaW5nIHVwZGF0ZURlYnVmZnMgbWV0aG9kOicsIHBsYXllck1vdmVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2VhcG9uIHN3aXRjaGluZ1xuICAgIHRoaXMuaGFuZGxlV2VhcG9uU3dpdGNoaW5nKCk7XG5cbiAgICAvLyBIYW5kbGUgZGFzaCBtb3ZlbWVudCBmaXJzdCAob3ZlcnJpZGVzIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5oYW5kbGVEYXNoTW92ZW1lbnQocGxheWVyTW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhcmdlIG1vdmVtZW50IChvdmVycmlkZXMgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmhhbmRsZUNoYXJnZU1vdmVtZW50KHBsYXllck1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gSGFuZGxlIHBsYXllciBtb3ZlbWVudCBpbnB1dCAob25seSBpZiBub3QgZGFzaGluZywgY2hhcmdpbmcsIGZyb3plbiwgb3Igc2t5ZmFsbGluZylcbiAgICBpZiAoIXBsYXllck1vdmVtZW50LmlzRGFzaGluZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNDaGFyZ2luZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNGcm96ZW4gJiYgIXRoaXMuaXNTa3lmYWxsaW5nKSB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVtZW50SW5wdXQocGxheWVyTW92ZW1lbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgY29tYmF0IGlucHV0XG4gICAgdGhpcy5oYW5kbGVDb21iYXRJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBkZWZsZWN0IGJhcnJpZXIgcG9zaXRpb24gaWYgYWN0aXZlXG4gICAgdGhpcy51cGRhdGVEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNb3ZlbWVudElucHV0KG1vdmVtZW50OiBNb3ZlbWVudCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcblxuICAgIGNvbnN0IHBsYXllclRyYW5zZm9ybSA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghcGxheWVyVHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayBmb3IgZG91YmxlLXRhcCBkYXNoZXMgZmlyc3QgKGJlZm9yZSBwcm9jZXNzaW5nIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5jaGVja0ZvckRhc2hJbnB1dChtb3ZlbWVudCwgcGxheWVyVHJhbnNmb3JtKTtcblxuICAgIC8vIEdldCBpbnB1dCBkaXJlY3Rpb25cbiAgICBjb25zdCBpbnB1dERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIGxldCBoYXNJbnB1dCA9IGZhbHNlO1xuXG4gICAgLy8gV0FTRCBtb3ZlbWVudFxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3cnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueiAtPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdzJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnogKz0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnYScpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi54IC09IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2QnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueCArPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBkaWFnb25hbCBtb3ZlbWVudFxuICAgIGlmIChpbnB1dERpcmVjdGlvbi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW5wdXQgdG8gd29ybGQgc3BhY2UgYmFzZWQgb24gY2FtZXJhIG9yaWVudGF0aW9uXG4gICAgaWYgKGhhc0lucHV0KSB7XG4gICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbWVyYSdzIHJpZ2h0IHZlY3RvclxuICAgICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FtZXJhJ3MgZm9yd2FyZCB2ZWN0b3IgKHByb2plY3RlZCBvbiBYWiBwbGFuZSlcbiAgICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY2FtZXJhRm9yd2FyZC5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoMCwgMSwgMCksIGNhbWVyYVJpZ2h0KS5ub3JtYWxpemUoKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIGlucHV0IGRpcmVjdGlvbiB0byB3b3JsZCBzcGFjZVxuICAgICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYVJpZ2h0LCBpbnB1dERpcmVjdGlvbi54KTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFGb3J3YXJkLCAtaW5wdXREaXJlY3Rpb24ueik7XG4gICAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgICAgbW92ZW1lbnQuc2V0TW92ZURpcmVjdGlvbih3b3JsZERpcmVjdGlvbiwgMS4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnQuc2V0TW92ZURpcmVjdGlvbihuZXcgVmVjdG9yMygwLCAwLCAwKSwgMCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGp1bXBpbmdcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcgJykpIHsgLy8gU3BhY2ViYXJcbiAgICAgIG1vdmVtZW50Lmp1bXAoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxhc3RXZWFwb25Td2l0Y2hUaW1lID0gMDtcbiAgcHJpdmF0ZSB3ZWFwb25Td2l0Y2hDb29sZG93biA9IDM7IC8vIDIwMG1zIGNvb2xkb3duIHRvIHByZXZlbnQgcmFwaWQgc3dpdGNoaW5nXG5cbiAgcHJpdmF0ZSBoYW5kbGVXZWFwb25Td2l0Y2hpbmcoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBQcmV2ZW50IHJhcGlkIHdlYXBvbiBzd2l0Y2hpbmdcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lIDwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3ZWFwb24gc3dpdGNoaW5nIHdpdGggbnVtYmVyIGtleXNcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcxJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TV09SRDtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5ESVZJTklUWTsgLy8gRGVmYXVsdCBzd29yZCBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zd29yZEZpcmVSYXRlOyAvLyBVc2Ugc3dvcmQtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7IC8vIFJlc2V0IGNvbWJvIHdoZW4gc3dpdGNoaW5nIHRvIHN3b3JkXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5eh77iPIFN3aXRjaGVkIHRvIFN3b3JkJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzInKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5CT1c7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRUxFTUVOVEFMOyAvLyBEZWZhdWx0IGJvdyBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gMC4yMjU7IC8vIEJvdyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+PuSBTd2l0Y2hlZCB0byBCb3cnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnMycpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNDWVRIRTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5DSEFPUzsgLy8gRGVmYXVsdCBzY3l0aGUgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc2N5dGhlRmlyZVJhdGU7IC8vIFVzZSBzY3l0aGUgZmlyZSByYXRlICgwLjVzKVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgU3dpdGNoZWQgdG8gU2N5dGhlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzQnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TQUJSRVM7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRlJPU1Q7IC8vIERlZmF1bHQgc2FicmVzIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnNhYnJlc0ZpcmVSYXRlOyAvLyBVc2Ugc2FicmVzLXNwZWNpZmljIGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU3dpdGNoZWQgdG8gU2FicmVzJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVDb21iYXRJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICB0aGlzLmhhbmRsZUJvd0lucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICB0aGlzLmhhbmRsZVNjeXRoZUlucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3dvcmRJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgdGhpcy5oYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQm93SW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgVmlwZXIgU3RpbmcgYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQmFycmFnZSBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfj7kgUSBrZXkgcHJlc3NlZCBmb3IgQmFycmFnZSEnLCB7XG4gICAgICAgIGlzQmFycmFnZUNoYXJnaW5nOiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nLFxuICAgICAgICBpc0NoYXJnaW5nOiB0aGlzLmlzQ2hhcmdpbmcsXG4gICAgICAgIGlzVmlwZXJTdGluZ0NoYXJnaW5nOiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nXG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENvYnJhIFNob3QgYWJpbGl0eSB3aXRoICdFJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdlJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CNIEUga2V5IHByZXNzZWQgZm9yIENvYnJhIFNob3QhJywge1xuICAgICAgICBpc0NoYXJnaW5nOiB0aGlzLmlzQ2hhcmdpbmcsXG4gICAgICAgIGlzVmlwZXJTdGluZ0NoYXJnaW5nOiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nLFxuICAgICAgICBpc0JhcnJhZ2VDaGFyZ2luZzogdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyxcbiAgICAgICAgaXNDb2JyYVNob3RDaGFyZ2luZzogdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nLFxuICAgICAgICBjdXJyZW50V2VhcG9uOiB0aGlzLmN1cnJlbnRXZWFwb25cbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLnBlcmZvcm1Db2JyYVNob3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGJvdyBjaGFyZ2luZyBhbmQgZmlyaW5nXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uIGhlbGRcbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4+5IFN0YXJ0ZWQgY2hhcmdpbmcgYm93Jyk7XG4gICAgICB9XG4gICAgICAvLyBJbmNyZWFzZSBjaGFyZ2UgcHJvZ3Jlc3MgKGNvdWxkIGJlIHRpbWUtYmFzZWQpXG4gICAgICBpZiAoIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4odGhpcy5jaGFyZ2VQcm9ncmVzcyArIDAuMDEyNSwgMS4wKTsgLy8gQk9XIENIQVJHRSBTUEVFRFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAvLyBDaGVjayBpZiBhbnkgYWJpbGl0eSBpcyBjaGFyZ2luZyAtIGlmIHNvLCBjYW5jZWwgdGhlIHJlZ3VsYXIgYm93IHNob3RcbiAgICAgIGlmICh0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nIHx8IHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgfHwgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4+5IENhbmNlbGxpbmcgcmVndWxhciBib3cgc2hvdCBkdWUgdG8gYWJpbGl0eSBjaGFyZ2luZycpO1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RvcmUgY2hhcmdlIHByb2dyZXNzIGJlZm9yZSByZXNldHRpbmcgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgICBjb25zdCBmaW5hbENoYXJnZVByb2dyZXNzID0gdGhpcy5jaGFyZ2VQcm9ncmVzcztcbiAgICAgIFxuICAgICAgLy8gUmVsZWFzZSB0aGUgYm93XG4gICAgICB0aGlzLmZpcmVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIHZpc3VhbCBlZmZlY3RzIGNhbGxiYWNrIHdpdGggdGhlIHN0b3JlZCBjaGFyZ2UgcHJvZ3Jlc3NcbiAgICAgIHRoaXMudHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlU2N5dGhlSW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgc2N5dGhlIGxlZnQgY2xpY2sgZm9yIEVudHJvcGljQm9sdFxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSkgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiBoZWxkXG4gICAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBTdGFydGVkIGNoYXJnaW5nIHNjeXRoZSAoc3Bpbm5pbmcpJyk7XG4gICAgICB9XG4gICAgICAvLyBJbmNyZWFzZSBjaGFyZ2UgcHJvZ3Jlc3MgY29udGludW91c2x5IGZvciBzcGlubmluZyBhbmltYXRpb24gKG5vIGNhcClcbiAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgKz0gMC4wMzsgLy8gQ29udGludW91c2x5IGluY3JlYXNlIGZvciBzcGlubmluZ1xuICAgICAgXG4gICAgICAvLyBGaXJlIEVudHJvcGljQm9sdCBwcm9qZWN0aWxlcyBjb250aW51b3VzbHkgd2hpbGUgc3Bpbm5pbmdcbiAgICAgIHRoaXMuZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgLy8gU3RvcCBzcGlubmluZyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICBjb25zb2xlLmxvZygn4pqhIFN0b3BwZWQgY2hhcmdpbmcgc2N5dGhlIChzcGlubmluZyknKTtcbiAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBDcm9zc2VudHJvcHlCb2x0IGFiaWxpdHkgd2l0aCAnUicga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncicpICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMuZmlyZUNyb3NzZW50cm9weUJvbHRBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBSZWFuaW1hdGUgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRnJvc3QgTm92YSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaXJlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2xpY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5maXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uIChzYW1lIGFzIGNhbWVyYSBkaXJlY3Rpb24gc2luY2UgZHJhZ29uIGZhY2VzIGNhbWVyYSlcbiAgICAvLyBUaGlzIGVuc3VyZXMgYXJyb3dzIGZpcmUgb3V0d2FyZCBmcm9tIHdoZXJlIHRoZSBkcmFnb24gaXMgZmFjaW5nXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gdG8gYWNjb3VudCBmb3IgcmVzdHJpY3RlZCBjYW1lcmEgYm91bmRzXG4gICAgLy8gU2luY2UgY2FtZXJhIGNhbid0IGxvb2sgZG93biBtdWNoIGR1ZSB0byBib3VuZHMsIHdlIGFkZCBhIGZpeGVkIGRvd253YXJkIGFuZ2xlXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBcbiAgICAvLyBDcmVhdGUgYSByb3RhdGlvbiBtYXRyaXggdG8gYXBwbHkgdGhlIGRvd253YXJkIGFuZ2xlIGFyb3VuZCB0aGUgY2FtZXJhJ3MgcmlnaHQgYXhpc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIFBlcmZlY3Qgc2hvdCB0aW1pbmcgY29uc3RhbnRzXG4gICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc7IC8vIDg1JSBjaGFyZ2VcbiAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICBjb25zdCBpc1BlcmZlY3RTaG90ID0gdGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCAmJiB0aGlzLmNoYXJnZVByb2dyZXNzIDw9IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJvdyBpcyBmdWxseSBjaGFyZ2VkIGZvciBzcGVjaWFsIHByb2plY3RpbGVcbiAgICBpZiAodGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+5IEZpcmluZyBDSEFSR0VEIEFSUk9XIHdpdGggZnVsbCBjaGFyZ2U6ICR7dGhpcy5jaGFyZ2VQcm9ncmVzc31gKTtcbiAgICAgIHRoaXMuY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzUGVyZmVjdFNob3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinKggRmlyaW5nIFBFUkZFQ1QgU0hPVCB3aXRoIGNoYXJnZTogJHt0aGlzLmNoYXJnZVByb2dyZXNzfWApO1xuICAgICAgdGhpcy5jcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGZpcmluZyBhbmdsZSB0byB2ZXJpZnkgaXQncyBjaGFuZ2luZyB3aXRoIGNhbWVyYSByb3RhdGlvblxuICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XG4gICAgICBjb25zb2xlLmxvZyhg8J+nrSBGaXJpbmcgJHt0aGlzLmN1cnJlbnRXZWFwb259IGF0IGFuZ2xlOiAkeyhhbmdsZSAqIDE4MCAvIE1hdGguUEkpLnRvRml4ZWQoMSl9wrBgKTtcbiAgICAgIHRoaXMuY3JlYXRlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpcmVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHVzZSBuZXcgc2N5dGhlIHJhdGUgKDAuNSBzZWNvbmRzKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLnNjeXRoZUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb25cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiAoc2FtZSBhcyBib3cgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHNwaW5TdGF0dXMgPSB0aGlzLmlzQ2hhcmdpbmcgPyAnIChTUElOTklORyknIDogJyc7XG4gICAgY29uc29sZS5sb2coYOKaoSBGaXJpbmcgRW50cm9waWNCb2x0JHtzcGluU3RhdHVzfSAtIGNoYXJnZTogJHt0aGlzLmNoYXJnZVByb2dyZXNzLnRvRml4ZWQoMil9IC0gcmF0ZTogJHt0aGlzLnNjeXRoZUZpcmVSYXRlfXNgKTtcbiAgICBcbiAgICB0aGlzLmNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSB1c2UgQ3Jvc3NlbnRyb3B5Qm9sdCByYXRlICgxIHBlciBzZWNvbmQpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lIDwgdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb25cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGFuZ2xlIGNvbXBlbnNhdGlvbiAoc2FtZSBhcyBib3cgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDimpTvuI8gRmlyaW5nIENyb3NzZW50cm9weUJvbHQgYWJpbGl0eSAoUiBrZXkpIC0gcmF0ZTogJHt0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlfXNgKTtcbiAgICBcbiAgICB0aGlzLmNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSB2YWxpZCB0YXJnZXRzIGluIHRoZSB3b3JsZCBiZWZvcmUgY3JlYXRpbmcgcHJvamVjdGlsZXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBjb25zdCB2YWxpZFRhcmdldHMgPSBwb3RlbnRpYWxUYXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gXG4gICAgICB0YXJnZXQuaWQgIT09IHRoaXMucGxheWVyRW50aXR5IS5pZCAmJiAvLyBOb3QgdGhlIHBsYXllciBpdHNlbGZcbiAgICAgICF0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk/LmlzRGVhZCAvLyBOb3QgZGVhZFxuICAgICk7XG4gICAgXG4gICAgLy8gSW4gbXVsdGlwbGF5ZXIgbW9kZSwgb25seSBjcmVhdGUgcHJvamVjdGlsZXMgaWYgdGhlcmUgYXJlIHZhbGlkIHRhcmdldHMgb3IgaWYgd2UgbmVlZCB0byBicm9hZGNhc3QgdG8gb3RoZXIgcGxheWVyc1xuICAgIGNvbnN0IGhhc1ZhbGlkVGFyZ2V0cyA9IHZhbGlkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNob3VsZEJyb2FkY2FzdCA9IHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFoYXNWYWxpZFRhcmdldHMgJiYgIXNob3VsZEJyb2FkY2FzdCkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfj7kgTm8gdmFsaWQgdGFyZ2V0cyBmb3VuZCwgc2tpcHBpbmcgcHJvamVjdGlsZSBjcmVhdGlvbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZSB1c2luZyB0aGUgUHJvamVjdGlsZVN5c3RlbSB3aXRoIGN1cnJlbnQgd2VhcG9uIGNvbmZpZ1xuICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICBzcGVlZDogMjUsXG4gICAgICBkYW1hZ2U6IDEwLCAvLyBBcnJvdyBkYW1hZ2Ugc2hvdWxkIGJlIDEwXG4gICAgICBsaWZldGltZTogMyxcbiAgICAgIG1heERpc3RhbmNlOiAyNSwgLy8gTGltaXQgYm93IGFycm93cyB0byAyNSB1bml0cyBkaXN0YW5jZVxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlUHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncmVndWxhcl9hcnJvdycsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgcHJvamVjdGlsZUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSB2YWxpZCB0YXJnZXRzIGluIHRoZSB3b3JsZCBiZWZvcmUgY3JlYXRpbmcgcHJvamVjdGlsZXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBjb25zdCB2YWxpZFRhcmdldHMgPSBwb3RlbnRpYWxUYXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gXG4gICAgICB0YXJnZXQuaWQgIT09IHRoaXMucGxheWVyRW50aXR5IS5pZCAmJiAvLyBOb3QgdGhlIHBsYXllciBpdHNlbGZcbiAgICAgICF0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk/LmlzRGVhZCAvLyBOb3QgZGVhZFxuICAgICk7XG4gICAgXG4gICAgLy8gSW4gbXVsdGlwbGF5ZXIgbW9kZSwgb25seSBjcmVhdGUgcHJvamVjdGlsZXMgaWYgdGhlcmUgYXJlIHZhbGlkIHRhcmdldHMgb3IgaWYgd2UgbmVlZCB0byBicm9hZGNhc3QgdG8gb3RoZXIgcGxheWVyc1xuICAgIGNvbnN0IGhhc1ZhbGlkVGFyZ2V0cyA9IHZhbGlkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNob3VsZEJyb2FkY2FzdCA9IHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFoYXNWYWxpZFRhcmdldHMgJiYgIXNob3VsZEJyb2FkY2FzdCkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBObyB2YWxpZCB0YXJnZXRzIGZvdW5kLCBza2lwcGluZyBFbnRyb3BpY0JvbHQgY3JlYXRpb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMTUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RFbnRyb3BpY0JvbHQoKSkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCBFbnRyb3BpYyBCb2x0IChyZXF1aXJlcyAxNSBtYW5hKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoMTApO1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBDb25zdW1lZCAxNSBtYW5hIGZvciBFbnRyb3BpYyBCb2x0Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjc1OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgRW50cm9waWNCb2x0IHByb2plY3RpbGUgdXNpbmcgdGhlIG5ldyBtZXRob2RcbiAgICBjb25zdCBlbnRyb3BpY0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAyMCwgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgICAgZGFtYWdlOiAyMCwgLy8gRW50cm9waWNCb2x0IGRhbWFnZVxuICAgICAgbGlmZXRpbWU6IDUsIC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICAgIHBpZXJjaW5nOiBmYWxzZSwgLy8gTm9uLXBpZXJjaW5nIHNvIHByb2plY3RpbGUgZ2V0cyBkZXN0cm95ZWQgb24gaGl0XG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24gZWZmZWN0XG4gICAgICBleHBsb3Npb25SYWRpdXM6IDAsIC8vIE5vIGV4cGxvc2lvbiByYWRpdXNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgZW50cm9waWNDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdlbnRyb3BpY19ib2x0Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBlbnRyb3BpY0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDQwIG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0Q3Jvc3NlbnRyb3B5Qm9sdCgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIE5vdCBlbm91Z2ggbWFuYSB0byBjYXN0IENyb3NzZW50cm9weSBCb2x0IChyZXF1aXJlcyA0MCBtYW5hKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoNDApO1xuICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBDb25zdW1lZCA0MCBtYW5hIGZvciBDcm9zc2VudHJvcHkgQm9sdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC43NTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSB1c2luZyB0aGUgZXhpc3RpbmcgbWV0aG9kXG4gICAgY29uc3QgY3Jvc3NlbnRyb3B5Q29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDE1LCAvLyBTbG93ZXIgdGhhbiBFbnRyb3BpY0JvbHRcbiAgICAgIGRhbWFnZTogOTAsIC8vIEhpZ2hlciBkYW1hZ2UgZm9yIFIgYWJpbGl0eVxuICAgICAgbGlmZXRpbWU6IDUsIC8vIExvbmdlciBsaWZldGltZVxuICAgICAgcGllcmNpbmc6IGZhbHNlLCAvLyBcbiAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIERpc2FibGVkIGV4cGxvc2lvbiBlZmZlY3QgZm9yIHBlcmZvcm1hbmNlXG4gICAgICBleHBsb3Npb25SYWRpdXM6IDAsIC8vIE5vIGV4cGxvc2lvbiByYWRpdXNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGNyb3NzZW50cm9weUNvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2Nyb3NzZW50cm9weV9ib2x0Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBjcm9zc2VudHJvcHlDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVJlYW5pbWF0ZUFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjYXN0aW5nICgxIHNlY29uZCBjb29sZG93bilcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUgPCAxLjApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6m4IFJlYW5pbWF0ZSBvbiBjb29sZG93biAtIHBsZWFzZSB3YWl0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICgyMCBtYW5hIGNvc3QgLSBkb3VibGVkIGZyb20gMTApXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBjb25zdCBjdXJyZW50TWFuYSA9IGdhbWVVSSA/IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpIDogMDtcbiAgICBcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdFJlYW5pbWF0ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgbWFuYVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGNvbnN0IG1hbmFCZWZvcmUgPSBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKTtcbiAgICAgIGdhbWVVSS5jb25zdW1lTWFuYSgyMCk7XG4gICAgICBjb25zdCBtYW5hQWZ0ZXIgPSBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6m4IFJlYW5pbWF0ZSBtYW5hIGNvbnN1bXB0aW9uIC0gQmVmb3JlOiAke21hbmFCZWZvcmV9LCBBZnRlcjogJHttYW5hQWZ0ZXJ9LCBDb25zdW1lZDogJHttYW5hQmVmb3JlIC0gbWFuYUFmdGVyfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgdHJpZ2dlciB0aGUgdmlzdWFsIGVmZmVjdCBmaXJzdCwgcmVnYXJkbGVzcyBvZiBoZWFsaW5nIHN1Y2Nlc3NcbiAgICBjb25zb2xlLmxvZygn8J+MvyBSZWFuaW1hdGUgYWJpbGl0eSBhY3RpdmF0ZWQgLSB0cmlnZ2VyaW5nIHZpc3VhbCBlZmZlY3RzJyk7XG4gICAgdGhpcy50cmlnZ2VyUmVhbmltYXRlRWZmZWN0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllcidzIGhlYWx0aCBjb21wb25lbnQgYW5kIGhlYWwgZm9yIDIwIEhQIChkb3VibGVkIGZyb20gMTApXG4gICAgY29uc3QgaGVhbHRoQ29tcG9uZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKGhlYWx0aENvbXBvbmVudCkge1xuICAgICAgY29uc3QgZGlkSGVhbCA9IGhlYWx0aENvbXBvbmVudC5oZWFsKDMwKTsgLy8gUkVBTklNQVRFIEhFQUwgQU1PVU5UXG4gICAgICBpZiAoZGlkSGVhbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+puCBSZWFuaW1hdGUgaGVhbGVkIHBsYXllciBmb3IgMjAgSFAuIEN1cnJlbnQgaGVhbHRoOiAke2hlYWx0aENvbXBvbmVudC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aENvbXBvbmVudC5tYXhIZWFsdGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+puCBSZWFuaW1hdGUgY2FzdCBzdWNjZXNzZnVsbHkgYnV0IHBsYXllciBhbHJlYWR5IGF0IGZ1bGwgaGVhbHRoJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyUmVhbmltYXRlRWZmZWN0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gVHJpZ2dlciB0aGUgdmlzdWFsIGhlYWxpbmcgZWZmZWN0XG4gICAgY29uc29sZS5sb2coJ/CfjL8gVHJpZ2dlcmluZyBSZWFuaW1hdGUgaGVhbGluZyBlZmZlY3QnKTtcbiAgICBcbiAgICBpZiAodGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgY29uc29sZS5sb2coYPCfjL8gSGVhbGluZyBlZmZlY3QgYXQgcG9zaXRpb246ICR7cGxheWVyUG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtwbGF5ZXJQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnoudG9GaXhlZCgyKX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUgPCB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3N0IE5vdmEgb24gY29vbGRvd24gZm9yICR7KHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lKSkudG9GaXhlZCgxKX1zYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDI1IG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0RnJvc3ROb3ZhKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYTvuI8gTm90IGVub3VnaCBtYW5hIHRvIGNhc3QgRnJvc3QgTm92YSAocmVxdWlyZXMgMjUgbWFuYSknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDUwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinYTvuI8gQ29uc3VtZWQgMjUgbWFuYSBmb3IgRnJvc3QgTm92YScpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KdhO+4jyBGcm9zdCBOb3ZhIGFiaWxpdHkgYWN0aXZhdGVkIScpO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRnJvc3QgTm92YSBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIGVuZW1pZXMgd2l0aGluIDUgdW5pdCByYWRpdXMgYW5kIGZyZWV6ZSB0aGVtXG4gICAgdGhpcy5mcmVlemVFbmVtaWVzSW5SYWRpdXMocGxheWVyUG9zaXRpb24sIDYuMCwgY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2xvYmFsIGZyb3N0IG5vdmEgdmlzdWFsIGVmZmVjdFxuICAgIHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEocGxheWVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQ29icmFTaG90KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2JyYVNob3RUaW1lIDwgdGhpcy5jb2JyYVNob3RGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYPCfkI0gQ29icmEgU2hvdCBvbiBjb29sZG93biBmb3IgJHsodGhpcy5jb2JyYVNob3RGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENvYnJhU2hvdFRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBlbmVyZ3kgKDQwIGVuZXJneSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RDb2JyYVNob3QoKSkge1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gTm90IGVub3VnaCBlbmVyZ3kgdG8gY2FzdCBDb2JyYSBTaG90IChyZXF1aXJlcyA0MCBlbmVyZ3kpJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+QjSBDb25zdW1lZCA0MCBlbmVyZ3kgZm9yIENvYnJhIFNob3QnKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+QjSBDb2JyYSBTaG90IGFjdGl2YXRlZCAtIHN0YXJ0aW5nIGNoYXJnZSEnKTtcbiAgICB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdENvYnJhU2hvdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gNzUwOyAvLyAwLjc1IHNlY29uZCBjaGFyZ2UgdGltZSAoYmV0d2VlbiBWaXBlciBTdGluZyBhbmQgQmFycmFnZSlcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyBjaGFyZ2VEdXJhdGlvbiwgMS4wKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVDb2JyYVNob3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn5CNIEZpcmluZyBDb2JyYSBTaG90IHByb2plY3RpbGUhJyk7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIChzYW1lIGFzIG90aGVyIHByb2plY3RpbGVzKVxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDE7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWwgbGlrZSBWaXBlciBTdGluZ1xuICAgIFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2FtZSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gYXMgb3RoZXIgcHJvamVjdGlsZXNcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE9mZnNldCBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBcbiAgICAvLyBOb3RlOiBDb2JyYSBTaG90IGRhbWFnZSBpcyBoYW5kbGVkIGJ5IENvYnJhU2hvdE1hbmFnZXIsIG5vdCBFQ1MgcHJvamVjdGlsZXNcbiAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBwcm9qZWN0aWxlcyBhbmQgZGFtYWdlIChzaW1pbGFyIHRvIFZpcGVyIFN0aW5nKVxuICAgIFxuICAgIC8vIFRyaWdnZXIgQ29icmEgU2hvdCBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2soc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJpZ2dlciBnbG9iYWwgY29icmEgc2hvdCB3aXRoIHByb3BlciBwb3NpdGlvbmluZyAoaGFuZGxlcyBsb2NhbCB2aXN1YWwgZWZmZWN0cyBhbmQgZGFtYWdlKVxuICAgIHRyaWdnZXJHbG9iYWxDb2JyYVNob3Qoc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY29icmFfc2hvdF9wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiAxNiwgLy8gQ29uc2lzdGVudCBzcGVlZCBmb3IgUFZQXG4gICAgICAgIGRhbWFnZTogMjksIC8vIFVzZSBjb25zaXN0ZW50IGRhbWFnZSB2YWx1ZVxuICAgICAgICBsaWZldGltZTogOCxcbiAgICAgICAgdmVub21EdXJhdGlvbjogNlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmcmVlemVFbmVtaWVzSW5SYWRpdXMoY2VudGVyUG9zaXRpb246IFZlY3RvcjMsIHJhZGl1czogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGRcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBsZXQgZnJvemVuQ291bnQgPSAwO1xuICAgIGxldCBkYW1hZ2VkUGxheWVycyA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgZW50aXR5SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5SGVhbHRoIHx8IGVudGl0eUhlYWx0aC5pc0RlYWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZW50aXR5UG9zaXRpb24gPSBlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNlbnRlclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaXMgd2l0aGluIGZyZWV6ZSByYWRpdXNcbiAgICAgIGlmIChkaXN0YW5jZSA8PSByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZW5lbXkgLSBmcmVlemUgaXQgKHNpbmdsZSBwbGF5ZXIgbW9kZSlcbiAgICAgICAgICBlbmVteS5mcmVlemUoNi4wLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgZnJvemVuQ291bnQrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3plbiBlbmVteSBhdCBkaXN0YW5jZSAke2Rpc3RhbmNlLnRvRml4ZWQoMil9IHVuaXRzYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIGZyb3plbiB2aXN1YWwgZWZmZWN0IGZvciB0aGlzIGVuZW15XG4gICAgICAgICAgYWRkR2xvYmFsRnJvemVuRW5lbXkoZW50aXR5LmlkLnRvU3RyaW5nKCksIGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhbm90aGVyIHBsYXllciBpbiBQVlAgbW9kZSAtIGRlYWwgZGFtYWdlIGFuZCBmcmVlemVcbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb3N0Tm92YURhbWFnZSA9IDUwOyAvLyBGcm9zdCBOb3ZhIGRhbWFnZVxuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgZnJvc3ROb3ZhRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ2Zyb3N0X25vdmEnKTtcbiAgICAgICAgICAgIGRhbWFnZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3N0IE5vdmEgaGl0IHBsYXllciAke2VudGl0eS5pZH0gZm9yICR7ZnJvc3ROb3ZhRGFtYWdlfSBkYW1hZ2UgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSB1bml0c2ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCcm9hZGNhc3QgZnJlZXplIGVmZmVjdCB0byB0aGUgdGFyZ2V0IHBsYXllciBzbyB0aGV5IGdldCBmcm96ZW4gb24gdGhlaXIgZW5kXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRlYnVmZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYTvuI8gQnJvYWRjYXN0aW5nIGZyZWV6ZSBlZmZlY3QgdG8gUFZQIHBsYXllciAke2VudGl0eS5pZH1gKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gRGVidWc6IENhbGxpbmcgZGVidWZmIGNhbGxiYWNrIHdpdGggZW50aXR5SWQ9JHtlbnRpdHkuaWR9LCB0eXBlPWZyb3plbiwgZHVyYXRpb249MzAwMGApO1xuICAgICAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnZnJvemVuJywgNjAwMCwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIERlYnVnOiBEZWJ1ZmYgY2FsbGJhY2sgY29tcGxldGVkYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBEZWJ1Zzogb25EZWJ1ZmZDYWxsYmFjayBpcyBub3Qgc2V0IWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChmcm96ZW5Db3VudCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinYTvuI8gRnJvc3QgTm92YSBmcm96ZSAke2Zyb3plbkNvdW50fSBlbmVtaWVzIHdpdGhpbiAke3JhZGl1c30gdW5pdCByYWRpdXNgKTtcbiAgICB9XG4gICAgaWYgKGRhbWFnZWRQbGF5ZXJzID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGRhbWFnZWQgJHtkYW1hZ2VkUGxheWVyc30gcGxheWVycyB3aXRoaW4gJHtyYWRpdXN9IHVuaXQgcmFkaXVzYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIGNoYXJnZWQgYXJyb3cgcHJvamVjdGlsZSAtIG1vcmUgcG93ZXJmdWwgdGhhbiByZWd1bGFyIGFycm93c1xuICAgIGNvbnN0IGNoYXJnZWRBcnJvd0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAzNSwgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDI1KVxuICAgICAgZGFtYWdlOiA1MCwgLy8gTXVjaCBoaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3MgKDEwKVxuICAgICAgbGlmZXRpbWU6IDIsIC8vIExvbmdlciBsaWZldGltZSB0aGFuIHJlZ3VsYXIgYXJyb3dzICgzKVxuICAgICAgcGllcmNpbmc6IHRydWUsIC8vIENoYXJnZWQgYXJyb3dzIGNhbiBwaWVyY2UgdGhyb3VnaCBlbmVtaWVzXG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBjb3VsZCBhZGQgc3BlY2lhbCBlZmZlY3RzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGNoYXJnZWRBcnJvd0NvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NoYXJnZWRfYXJyb3cnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNoYXJnZWRBcnJvd0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcGVyZmVjdCBzaG90IHByb2plY3RpbGUgLSBlbmhhbmNlZCBjaGFyZ2VkIGFycm93IHdpdGggc3BlY2lhbCBlZmZlY3RzXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAge1xuICAgICAgICBzcGVlZDogNDAsIC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDM1KVxuICAgICAgICBkYW1hZ2U6IDc1LCAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoNTApXG4gICAgICAgIGxpZmV0aW1lOiA2LCAvLyBMb25nZXIgbGlmZXRpbWUgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICg1KVxuICAgICAgICBwaWVyY2luZzogdHJ1ZSwgLy8gUGVyZmVjdCBzaG90cyBjYW4gcGllcmNlIHRocm91Z2ggZW5lbWllc1xuICAgICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBoYXMgc3BlY2lhbCB2aXN1YWwgZWZmZWN0c1xuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncGVyZmVjdF9zaG90Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiA0MCxcbiAgICAgICAgZGFtYWdlOiA3NSxcbiAgICAgICAgbGlmZXRpbWU6IDYsXG4gICAgICAgIHBpZXJjaW5nOiB0cnVlLFxuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYOKcqCBQZXJmZWN0IHNob3QgcHJvamVjdGlsZSBjcmVhdGVkIHdpdGggZW5oYW5jZWQgc3RhdHMhYCk7XG4gIH1cblxuICAvLyBNZXRob2RzIHRvIGNvbmZpZ3VyZSB3ZWFwb24gZm9yIHRlc3RpbmdcbiAgcHVibGljIHNldFdlYXBvblN1YmNsYXNzKHN1YmNsYXNzOiBXZWFwb25TdWJjbGFzcyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gc3ViY2xhc3M7XG4gICAgY29uc29sZS5sb2coYPCfj7kgV2VhcG9uIHN1YmNsYXNzIGNoYW5nZWQgdG86ICR7c3ViY2xhc3N9YCk7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gc2V0IGJvdyByZWxlYXNlIGNhbGxiYWNrXG4gIHB1YmxpYyBzZXRCb3dSZWxlYXNlQ2FsbGJhY2soY2FsbGJhY2s6IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGl2aW5lU3Rvcm1DYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0UHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjazogKHByb2plY3RpbGVUeXBlOiBzdHJpbmcsIHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGNvbmZpZzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFZpcGVyU3RpbmdDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFycmFnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRSZWFuaW1hdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25SZWFuaW1hdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RnJvc3ROb3ZhQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRDb2JyYVNob3RDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldENoYXJnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFyZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGVmbGVjdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWZsZWN0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFNreWZhbGxDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU2t5ZmFsbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREZWJ1ZmZDYWxsYmFjayhjYWxsYmFjazogKHRhcmdldEVudGl0eUlkOiBudW1iZXIsIGRlYnVmZlR5cGU6ICdmcm96ZW4nIHwgJ3Nsb3dlZCcsIGR1cmF0aW9uOiBudW1iZXIsIHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gdHJpZ2dlciBib3cgcmVsZWFzZSBlZmZlY3RzXG4gIHByaXZhdGUgdHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3M6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHBlcmZlY3Qgc2hvdFxuICAgICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc1OyAvLyA4NSUgY2hhcmdlXG4gICAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICAgIGNvbnN0IGlzUGVyZmVjdFNob3QgPSBmaW5hbENoYXJnZVByb2dyZXNzID49IHBlcmZlY3RTaG90TWluVGhyZXNob2xkICYmIGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPD0gcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQ7XG4gICAgICBcbiAgICAgIHRoaXMub25Cb3dSZWxlYXNlQ2FsbGJhY2soZmluYWxDaGFyZ2VQcm9ncmVzcywgaXNQZXJmZWN0U2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFdlYXBvbkxldmVsKGxldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgIGNvbnNvbGUubG9nKGDirIbvuI8gV2VhcG9uIGxldmVsIGNoYW5nZWQgdG86ICR7bGV2ZWx9YCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudFdlYXBvbkNvbmZpZygpOiB7IHdlYXBvbjogV2VhcG9uVHlwZTsgc3ViY2xhc3M6IFdlYXBvblN1YmNsYXNzOyBsZXZlbDogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB3ZWFwb246IHRoaXMuY3VycmVudFdlYXBvbixcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbFxuICAgIH07XG4gIH1cblxuICAvLyBHZXR0ZXJzIGZvciB3ZWFwb24gc3RhdGUgKGZvciBVSS9yZW5kZXJpbmcpXG4gIHB1YmxpYyBnZXRDdXJyZW50V2VhcG9uKCk6IFdlYXBvblR5cGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRXZWFwb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudFN1YmNsYXNzKCk6IFdlYXBvblN1YmNsYXNzIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3ViY2xhc3M7XG4gIH1cblxuICBwdWJsaWMgaXNXZWFwb25DaGFyZ2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0NoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldENoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNWaXBlclN0aW5nQ2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0VmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzQmFycmFnZUNoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldEJhcnJhZ2VDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc0NvYnJhU2hvdENoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1dlYXBvblN3aW5naW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3dpbmdpbmc7XG4gIH1cblxuICAvLyBTd29yZC1zcGVjaWZpYyBnZXR0ZXJzXG4gIHB1YmxpYyBnZXRTd29yZENvbWJvU3RlcCgpOiAxIHwgMiB8IDMge1xuICAgIHJldHVybiB0aGlzLnN3b3JkQ29tYm9TdGVwO1xuICB9XG5cbiAgcHVibGljIGlzRGl2aW5lU3Rvcm1BY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEaXZpbmVTdG9ybWluZztcbiAgfVxuXG4gIHB1YmxpYyBpc0NoYXJnZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1N3b3JkQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgaXNEZWZsZWN0QWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGVmbGVjdGluZztcbiAgfVxuICBcbiAgcHVibGljIGlzU2t5ZmFsbEFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1NreWZhbGxpbmc7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN3b3JkSW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgc3dvcmQgbWVsZWUgYXR0YWNrc1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvblxuICAgICAgdGhpcy5wZXJmb3JtU3dvcmRNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRGl2aW5lIFN0b3JtIGFiaWxpdHkgd2l0aCAnUicga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncicpICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEZWZsZWN0aW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1EaXZpbmVTdG9ybShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQ2hhcmdlIGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNEZWZsZWN0aW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1DaGFyZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIERlZmxlY3QgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNEZWZsZWN0aW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURlZmxlY3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbWJvIHJlc2V0XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPiB0aGlzLnN3b3JkQ29tYm9SZXNldFRpbWUpIHtcbiAgICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAxO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVN3b3JkTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNsaWNraW5nICh1c2Ugc3dvcmQtc3BlY2lmaWMgZmlyZSByYXRlKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLnN3b3JkRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+Xoe+4jyBTd29yZCBtZWxlZSBhdHRhY2sgLSBDb21ibyBzdGVwICR7dGhpcy5zd29yZENvbWJvU3RlcH1gKTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzd29yZCBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXJcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIE5vdGU6IFN3aW5nIGNvbXBsZXRpb24gYW5kIGNvbWJvIGFkdmFuY2VtZW50IGlzIG5vdyBoYW5kbGVkIGJ5IG9uU3dvcmRTd2luZ0NvbXBsZXRlIGNhbGxiYWNrXG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gc3dpbmcgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICBwdWJsaWMgb25Td29yZFN3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5eh77iPIFN3b3JkIHN3aW5nIGNvbXBsZXRlZCAtIHdhcyBjb21ibyBzdGVwICR7dGhpcy5zd29yZENvbWJvU3RlcH1gKTtcbiAgICBcbiAgICAvLyBSZXNldCBzd2luZ2luZyBzdGF0ZVxuICAgIHRoaXMuaXNTd2luZ2luZyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEFkdmFuY2UgY29tYm8gc3RlcCBmb3IgbmV4dCBhdHRhY2tcbiAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gKHRoaXMuc3dvcmRDb21ib1N0ZXAgJSAzICsgMSkgYXMgMSB8IDIgfCAzO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5eh77iPIE5leHQgY29tYm8gc3RlcCB3aWxsIGJlOiAke3RoaXMuc3dvcmRDb21ib1N0ZXB9YCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNhYnJlc0lucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIGxlZnQgY2xpY2sgZm9yIGR1YWwgc2FicmUgYXR0YWNrXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRSBrZXkgZm9yIFNreWZhbGwgYWJpbGl0eVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4yfIEUga2V5IHByZXNzZWQgZm9yIFNreWZhbGwgLSBhdHRlbXB0aW5nIHRvIHBlcmZvcm0gYWJpbGl0eScpO1xuICAgICAgdGhpcy5wZXJmb3JtU2t5ZmFsbChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgU2t5ZmFsbCBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU2t5ZmFsbE1vdmVtZW50KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNsaWNraW5nICh1c2Ugc2FicmVzLXNwZWNpZmljIGZpcmUgcmF0ZSlcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5zYWJyZXNGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgYXR0YWNrIGluaXRpYXRlZCcpO1xuICAgIFxuICAgIC8vIFNldCBzd2luZ2luZyBzdGF0ZSAtIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXIgKGR1YWwgYXR0YWNrKVxuICAgIHRoaXMucGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc2FicmVzIGNvbXBvbmVudCB3aGVuIHN3aW5nIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uU2FicmVzU3dpbmdDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTd2luZ2luZykgcmV0dXJuOyAvLyBQcmV2ZW50IG11bHRpcGxlIGNhbGxzXG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KalO+4jyBTYWJyZXMgZHVhbCBzd2luZyBjb21wbGV0ZWQnKTtcbiAgICBcbiAgICAvLyBSZXNldCBzd2luZ2luZyBzdGF0ZVxuICAgIHRoaXMuaXNTd2luZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgdGhhdCBjb3VsZCBiZSBkYW1hZ2VkXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IGFsbEVudGl0aWVzLmZpbHRlcihlbnRpdHkgPT4gXG4gICAgICBlbnRpdHkuaGFzQ29tcG9uZW50KEhlYWx0aCkgJiYgXG4gICAgICBlbnRpdHkuaGFzQ29tcG9uZW50KFRyYW5zZm9ybSkgJiZcbiAgICAgIGVudGl0eSAhPT0gdGhpcy5wbGF5ZXJFbnRpdHlcbiAgICApO1xuICAgIFxuICAgIC8vIFNBQlJFUyBEQU1BR0VcbiAgICBjb25zdCBhdHRhY2tSYW5nZSA9IDMuODsgLy8gU2xpZ2h0bHkgbG9uZ2VyIHJhbmdlIHRoYW4gc3dvcmRcbiAgICBjb25zdCBhdHRhY2tBbmdsZSA9IE1hdGguUEkgLyAyOyAvLyA2MCBkZWdyZWUgY29uZSAod2lkZXIgdGhhbiBzd29yZClcbiAgICBjb25zdCBsZWZ0U2FicmVEYW1hZ2UgPSAxOTsgLy8gRGFtYWdlIHBlciBzYWJyZVxuICAgIGNvbnN0IHJpZ2h0U2FicmVEYW1hZ2UgPSAyMztcbiAgICBcbiAgICAvLyBHZXQgY2FtZXJhIGRpcmVjdGlvbiBmb3IgYXR0YWNrIGRpcmVjdGlvblxuICAgIGNvbnN0IGF0dGFja0RpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oYXR0YWNrRGlyZWN0aW9uKTtcbiAgICBhdHRhY2tEaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtIHx8ICF0YXJnZXRIZWFsdGggfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdG8gdGFyZ2V0XG4gICAgICBjb25zdCBkaXJlY3Rpb25Ub1RhcmdldCA9IHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLnN1YihwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgY29uc3QgZGlzdGFuY2VUb1RhcmdldCA9IGRpcmVjdGlvblRvVGFyZ2V0Lmxlbmd0aCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGlzdGFuY2VUb1RhcmdldCA+IGF0dGFja1JhbmdlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHdpdGhpbiBhdHRhY2sgY29uZVxuICAgICAgZGlyZWN0aW9uVG9UYXJnZXQubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBkb3RQcm9kdWN0ID0gYXR0YWNrRGlyZWN0aW9uLmRvdChkaXJlY3Rpb25Ub1RhcmdldCk7XG4gICAgICBjb25zdCBhbmdsZVRvVGFyZ2V0ID0gTWF0aC5hY29zKE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBkb3RQcm9kdWN0KSkpO1xuICAgICAgXG4gICAgICBpZiAoYW5nbGVUb1RhcmdldCA+IGF0dGFja0FuZ2xlIC8gMikgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFRhcmdldCBpcyB3aXRoaW4gcmFuZ2UgYW5kIGNvbmUgLSBhcHBseSBkYW1hZ2UgZnJvbSBib3RoIHNhYnJlc1xuICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgIGlmIChjb21iYXRTeXN0ZW0pIHtcbiAgICAgICAgLy8gTGVmdCBzYWJyZSBoaXQgKGltbWVkaWF0ZSlcbiAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgbGVmdFNhYnJlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSB8fCB1bmRlZmluZWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmlnaHQgc2FicmUgaGl0ICh3aXRoIHNtYWxsIGRlbGF5KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRhcmdldEhlYWx0aC5pc0RlYWQpIHtcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZSh0YXJnZXQsIHJpZ2h0U2FicmVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDApOyAvLyAxMDBtcyBkZWxheSBiZXR3ZWVuIHNhYnJlIGhpdHNcbiAgICAgICAgXG4gICAgICAgIGhpdENvdW50Kys7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gU2FicmVzIGhpdCB0YXJnZXQgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZVRvVGFyZ2V0LnRvRml4ZWQoMil9IGZvciAke2xlZnRTYWJyZURhbWFnZSArIHJpZ2h0U2FicmVEYW1hZ2V9IHRvdGFsIGRhbWFnZWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoaGl0Q291bnQgPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGF0dGFjayBtaXNzZWQgLSBubyB0YXJnZXRzIGluIHJhbmdlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gU2FicmVzIGF0dGFjayBoaXQgJHtoaXRDb3VudH0gdGFyZ2V0KHMpYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2t5ZmFsbCBhYmlsaXR5IGltcGxlbWVudGF0aW9uXG4gIHByaXZhdGUgcGVyZm9ybVNreWZhbGwocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U2t5ZmFsbFRpbWUgPCB0aGlzLnNreWZhbGxDb29sZG93bikge1xuICAgICAgY29uc29sZS5sb2coYPCfjJ8gU2t5ZmFsbCBvbiBjb29sZG93biBmb3IgJHsodGhpcy5za3lmYWxsQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBlbmVyZ3kgY29zdFxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKCFnYW1lVUkgfHwgIWdhbWVVSS5jYW5DYXN0U2t5ZmFsbCgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+MnyBOb3QgZW5vdWdoIGVuZXJneSBmb3IgU2t5ZmFsbCAocmVxdWlyZXMgNDAgZW5lcmd5KScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICBcbiAgICAvLyBTdGFydCBTa3lmYWxsXG4gICAgdGhpcy5pc1NreWZhbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ2FzY2VuZGluZyc7XG4gICAgdGhpcy5za3lmYWxsU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5sYXN0U2t5ZmFsbFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnNreWZhbGxTdGFydFBvc2l0aW9uLmNvcHkocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBTZXQgdGFyZ2V0IGhlaWdodCAoZG91YmxlIGp1bXAgaGVpZ2h0KVxuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHkgPSBwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5O1xuICAgICAgdGhpcy5za3lmYWxsVGFyZ2V0SGVpZ2h0ID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAocGxheWVyTW92ZW1lbnQuanVtcEZvcmNlICogMik7IC8vIERvdWJsZSBqdW1wIGhlaWdodFxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+MnyBTa3lmYWxsIFNldHVwIC0gT3JpZ2luYWwgR3Jhdml0eTogJHt0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHl9LCBKdW1wIEZvcmNlOiAke3BsYXllck1vdmVtZW50Lmp1bXBGb3JjZX0sIFN0YXJ0IFk6ICR7cGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkudG9GaXhlZCgyKX0sIFRhcmdldCBZOiAke3RoaXMuc2t5ZmFsbFRhcmdldEhlaWdodC50b0ZpeGVkKDIpfWApO1xuICAgICAgXG4gICAgICAvLyBBcHBseSB1cHdhcmQgdmVsb2NpdHlcbiAgICAgIHBsYXllck1vdmVtZW50LnZlbG9jaXR5LnkgPSBwbGF5ZXJNb3ZlbWVudC5qdW1wRm9yY2UgKiAxLjg7IC8vIFN0cm9uZ2VyIGluaXRpYWwgdmVsb2NpdHlcbiAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSAwOyAvLyBEaXNhYmxlIGdyYXZpdHkgZHVyaW5nIGFzY2VudFxuICAgICAgLy8gRG9uJ3QgZGlzYWJsZSBjYW5Nb3ZlIGFzIGl0IHByZXZlbnRzIGFsbCBwaHlzaWNzIHVwZGF0ZXMgaW5jbHVkaW5nIGdyYXZpdHlcbiAgICAgIC8vIEluc3RlYWQgd2UnbGwgY29udHJvbCBob3Jpem9udGFsIG1vdmVtZW50IGluIHRoZSBDb250cm9sU3lzdGVtXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIEFwcGxpZWQgdmVsb2NpdHkgWTogJHtwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55LnRvRml4ZWQoMil9LCBTZXQgZ3Jhdml0eSB0bzogJHtwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+MnyBTa3lmYWxsIGluaXRpYXRlZCEgQXNjZW5kaW5nIHRvIGhlaWdodCAke3RoaXMuc2t5ZmFsbFRhcmdldEhlaWdodC50b0ZpeGVkKDIpfWApO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyL3Zpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Ta3lmYWxsQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgdGhpcy5vblNreWZhbGxDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZVNreWZhbGxNb3ZlbWVudChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAoIXBsYXllck1vdmVtZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBEZWJ1ZyBsb2dnaW5nICh0aHJvdHRsZWQgdG8gYXZvaWQgc3BhbSlcbiAgICBpZiAoTWF0aC5mbG9vcihlbGFwc2VkVGltZSAqIDQpICE9PSBNYXRoLmZsb29yKChlbGFwc2VkVGltZSAtIDAuMjUpICogNCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIFNreWZhbGwgVXBkYXRlIC0gUGhhc2U6ICR7dGhpcy5za3lmYWxsUGhhc2V9LCBZOiAke3BsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55LnRvRml4ZWQoMil9LCBUYXJnZXQ6ICR7dGhpcy5za3lmYWxsVGFyZ2V0SGVpZ2h0LnRvRml4ZWQoMil9LCBWZWxvY2l0eSBZOiAke3BsYXllck1vdmVtZW50LnZlbG9jaXR5LnkudG9GaXhlZCgyKX0sIEVsYXBzZWQ6ICR7ZWxhcHNlZFRpbWUudG9GaXhlZCgyKX1zYCk7XG4gICAgfVxuICAgIFxuICAgIHN3aXRjaCAodGhpcy5za3lmYWxsUGhhc2UpIHtcbiAgICAgIGNhc2UgJ2FzY2VuZGluZyc6XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGFyZ2V0IGhlaWdodCBvciBzdGFydGVkIGZhbGxpbmdcbiAgICAgICAgaWYgKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ID49IHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCB8fCBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdkZXNjZW5kaW5nJztcbiAgICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhdCBwZWFrXG4gICAgICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IHRoaXMuc2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSAqIDMwOyAvLyBGYXN0ZXIgZGVzY2VudFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn4yfIFNreWZhbGw6IFJlYWNoZWQgcGVhaywgYmVnaW5uaW5nIGRlc2NlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdkZXNjZW5kaW5nJzpcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgbGFuZGVkIChjbG9zZSB0byBvcmlnaW5hbCBoZWlnaHQgb3Igb24gZ3JvdW5kKVxuICAgICAgICBpZiAocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkgPD0gdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi55ICsgMC41KSB7XG4gICAgICAgICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnbGFuZGluZyc7XG4gICAgICAgICAgdGhpcy5wZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdsYW5kaW5nJzpcbiAgICAgICAgLy8gTGFuZGluZyBwaGFzZSBjb21wbGV0ZVxuICAgICAgICB0aGlzLmNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIC8vIFNhZmV0eSB0aW1lb3V0IChpZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgZW5kIGFmdGVyIDUgc2Vjb25kcylcbiAgICBpZiAoZWxhcHNlZFRpbWUgPiA1LjApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4yfIFNreWZhbGwgdGltZW91dCAtIGZvcmNlIGNvbXBsZXRpbmcnKTtcbiAgICAgIHRoaXMuY29tcGxldGVTa3lmYWxsQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+MnyBTa3lmYWxsOiBMYW5kaW5nIGltcGFjdCEnKTtcbiAgICBcbiAgICAvLyBEZWFsIGRhbWFnZSB0byBlbmVtaWVzIGluIGxhbmRpbmcgYXJlYVxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IGxhbmRpbmdQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBkYW1hZ2VSYWRpdXMgPSA0LjA7IC8vIDQgdW5pdCByYWRpdXNcbiAgICBjb25zdCBza3lmYWxsRGFtYWdlID0gMTUwOyAvLyAxNTAgZGFtYWdlIGFzIHJlcXVlc3RlZFxuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYWxsRW50aXRpZXMpIHtcbiAgICAgIGlmIChlbnRpdHkgPT09IHRoaXMucGxheWVyRW50aXR5KSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBkaXN0YW5jZSB0byBsYW5kaW5nIHBvc2l0aW9uXG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGFuZGluZyA9IGxhbmRpbmdQb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZVRvTGFuZGluZyA8PSBkYW1hZ2VSYWRpdXMpIHtcbiAgICAgICAgLy8gQXBwbHkgU2t5ZmFsbCBkYW1hZ2VcbiAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIHNreWZhbGxEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaGl0Q291bnQrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+MnyBTa3lmYWxsIGhpdCB0YXJnZXQgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZVRvTGFuZGluZy50b0ZpeGVkKDIpfSBmb3IgJHtza3lmYWxsRGFtYWdlfSBkYW1hZ2VgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoaGl0Q291bnQgPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4yfIFNreWZhbGwgbGFuZGluZyBtaXNzZWQgLSBubyB0YXJnZXRzIGluIHJhbmdlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIFNreWZhbGwgbGFuZGluZyBoaXQgJHtoaXRDb3VudH0gdGFyZ2V0KHMpYCk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSZXNldCBhbGwgU2t5ZmFsbCBzdGF0ZXNcbiAgICB0aGlzLmlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ25vbmUnO1xuICAgIFxuICAgIC8vIFJlc3RvcmUgcGxheWVyIG1vdmVtZW50XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHk7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhbnkgcmVtYWluaW5nIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn4yfIFNreWZhbGwgYWJpbGl0eSBjb21wbGV0ZWQnKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybU1lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBNZWxlZSBhdHRhY2sgcGFyYW1ldGVycyAtIGluY3JlYXNlZCBmb3IgUFZQIGNvbWJhdFxuICAgIGNvbnN0IG1lbGVlUmFuZ2UgPSA0LjY7IC8vIEluY3JlYXNlZCBhdHRhY2sgcmFuZ2UgZm9yIFBWUFxuICAgIGNvbnN0IG1lbGVlQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gMTIwIGRlZ3JlZSBjb25lICg2MCBkZWdyZWVzIGVhY2ggc2lkZSlcbiAgICBcbiAgICAvLyBCYXNlIGRhbWFnZSB2YWx1ZXMgYmFzZWQgb24gY29tYm8gc3RlcCAtIHdvcmtzIGZvciBhbGwgc3ViY2xhc3Nlc1xuICAgIGxldCBiYXNlRGFtYWdlID0gNDU7IC8vIEJhc2Ugc3dvcmQgZGFtYWdlXG4gICAgLy8gQ29tYm8gZGFtYWdlIHNjYWxpbmdcbiAgICBzd2l0Y2ggKHRoaXMuc3dvcmRDb21ib1N0ZXApIHtcbiAgICAgIGNhc2UgMTogYmFzZURhbWFnZSA9IDQ1OyBicmVhaztcbiAgICAgIGNhc2UgMjogYmFzZURhbWFnZSA9IDUwOyBicmVhaztcbiAgICAgIGNhc2UgMzogYmFzZURhbWFnZSA9IDYwOyBicmVhazsgLy8gRmluaXNoZXIgZG9lcyBtb3JlIGRhbWFnZVxuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgY29tYmF0IHN5c3RlbSB0byBhcHBseSBkYW1hZ2VcbiAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgIFxuICAgIC8vIFRyYWNrIGVuZW1pZXMgaGl0IGZvciByYWdlIGdlbmVyYXRpb25cbiAgICBsZXQgZW5lbWllc0hpdCA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyBlbmVteSBjb21wb25lbnQgYW5kIGhlYWx0aFxuICAgICAgY29uc3QgZW5lbXlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbmVteUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGlmICghZW5lbXlUcmFuc2Zvcm0gfHwgIWVuZW15SGVhbHRoIHx8IGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZW15UG9zaXRpb24gPSBlbmVteVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IHRvRW5lbXkgPSBlbmVteVBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG9FbmVteS5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgUFZQIGhpdCBkZXRlY3Rpb25cbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBWUCBTd29yZCBjaGVjayAtIEVudGl0eSAke2VudGl0eS5pZH06IFBsYXllciBwb3MgKCR7cGxheWVyUG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtwbGF5ZXJQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnoudG9GaXhlZCgyKX0pLCBFbmVteSBwb3MgKCR7ZW5lbXlQb3NpdGlvbi54LnRvRml4ZWQoMil9LCAke2VuZW15UG9zaXRpb24ueS50b0ZpeGVkKDIpfSwgJHtlbmVteVBvc2l0aW9uLnoudG9GaXhlZCgyKX0pLCBEaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgUmFuZ2U6ICR7bWVsZWVSYW5nZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZW5lbXkgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gbWVsZWVSYW5nZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBlbmVteSBpcyB3aXRoaW4gYXR0YWNrIGNvbmVcbiAgICAgICAgdG9FbmVteS5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBkaXJlY3Rpb24uYW5nbGVUbyh0b0VuZW15KTtcbiAgICAgICAgY29uc3QgYW5nbGVEZWdyZWVzID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBjb25zdCBtYXhBbmdsZURlZ3JlZXMgPSAobWVsZWVBbmdsZSAvIDIpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBWUCBTd29yZCBhbmdsZSBjaGVjayAtIEVudGl0eSAke2VudGl0eS5pZH06IEFuZ2xlICR7YW5nbGVEZWdyZWVzLnRvRml4ZWQoMSl9wrAsIE1heCBhbmdsZTogJHttYXhBbmdsZURlZ3JlZXMudG9GaXhlZCgxKX3CsGApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFuZ2xlIDw9IG1lbGVlQW5nbGUgLyAyKSB7XG4gICAgICAgICAgLy8gRW5lbXkgaXMgd2l0aGluIGF0dGFjayBjb25lIC0gZGVhbCBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfl6HvuI8gUFZQIFN3b3JkIGhpdCBjb25maXJtZWQhIEVudGl0eSAke2VudGl0eS5pZH0gYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgYW5nbGUgJHthbmdsZURlZ3JlZXMudG9GaXhlZCgxKX3CsGApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gKHdoaWNoIHdpbGwgcm91dGUgdG8gbXVsdGlwbGF5ZXIgZm9yIGVuZW1pZXMpXG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBiYXNlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ21lbGVlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+SpSBRdWV1ZWQgJHtiYXNlRGFtYWdlfSBtZWxlZSBkYW1hZ2UgdG8gZW50aXR5ICR7ZW50aXR5LmlkfSAoY29tYm8gc3RlcCAke3RoaXMuc3dvcmRDb21ib1N0ZXB9KWApO1xuICAgICAgICAgICAgZW5lbWllc0hpdCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIFBWUCBTd29yZCBtaXNzZWQgLSBFbnRpdHkgJHtlbnRpdHkuaWR9IG91dHNpZGUgYXR0YWNrIGNvbmUgKCR7YW5nbGVEZWdyZWVzLnRvRml4ZWQoMSl9wrAgPiAke21heEFuZ2xlRGVncmVlcy50b0ZpeGVkKDEpfcKwKWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIFBWUCBTd29yZCBtaXNzZWQgLSBFbnRpdHkgJHtlbnRpdHkuaWR9IG91dCBvZiByYW5nZSAoJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSA+ICR7bWVsZWVSYW5nZX0pYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcmFnZSBvbmx5IGlmIHdlIGhpdCBlbmVtaWVzICg1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nKVxuICAgIGlmIChlbmVtaWVzSGl0ID4gMCkge1xuICAgICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICAgIGlmIChnYW1lVUkpIHtcbiAgICAgICAgY29uc3QgcmFnZUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50UmFnZSA/IGdhbWVVSS5nZXRDdXJyZW50UmFnZSgpIDogJ3Vua25vd24nO1xuICAgICAgICBjb25zdCByYWdlVG9HYWluID0gTWF0aC5taW4oZW5lbWllc0hpdCAqIDUsIDUpOyAvLyA1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nXG4gICAgICAgIGdhbWVVSS5nYWluUmFnZShyYWdlVG9HYWluKTtcbiAgICAgICAgY29uc3QgcmFnZUFmdGVyID0gZ2FtZVVJLmdldEN1cnJlbnRSYWdlID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5eh77iPIEdhaW5lZCAke3JhZ2VUb0dhaW59IHJhZ2UgZnJvbSBoaXR0aW5nICR7ZW5lbWllc0hpdH0gZW5lbWllcyB3aXRoIHN3b3JkIGNvbWJvICR7dGhpcy5zd29yZENvbWJvU3RlcH0gLSBSYWdlOiAke3JhZ2VCZWZvcmV9IOKGkiAke3JhZ2VBZnRlcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yRGFzaElucHV0KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBmb3IgZG91YmxlLXRhcCBvbiBtb3ZlbWVudCBrZXlzXG4gICAgY29uc3QgZGFzaERpcmVjdGlvbnMgPSBbXG4gICAgICB7IGtleTogJ3cnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIC0xKSB9LCAvLyBGb3J3YXJkXG4gICAgICB7IGtleTogJ3MnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIDEpIH0sICAvLyBCYWNrd2FyZFxuICAgICAgeyBrZXk6ICdhJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygtMSwgMCwgMCkgfSwgLy8gTGVmdFxuICAgICAgeyBrZXk6ICdkJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygxLCAwLCAwKSB9ICAgLy8gUmlnaHRcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCB7IGtleSwgZGlyZWN0aW9uIH0gb2YgZGFzaERpcmVjdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5jaGVja0RvdWJsZVRhcChrZXkpKSB7XG4gICAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGRvdWJsZSB0YXAgZGV0ZWN0aW9uXG4gICAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldERvdWJsZVRhcERlYnVnSW5mbyhrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBEb3VibGUgdGFwIGRldGVjdGVkIGZvciBrZXkgJyR7a2V5LnRvVXBwZXJDYXNlKCl9JzpgLCBkZWJ1Z0luZm8pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2UgYmFzZWQgb24gY2FtZXJhIG9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gdGhpcy5nZXRXb3JsZFNwYWNlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN0YXJ0IGRhc2hcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgICAgIGNvbnN0IGRhc2hTdGFydGVkID0gbW92ZW1lbnQuc3RhcnREYXNoKHdvcmxkRGlyZWN0aW9uLCB0cmFuc2Zvcm0ucG9zaXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXNoU3RhcnRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn4+DIERhc2ggc3RhcnRlZCBpbiBkaXJlY3Rpb246ICR7a2V5LnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIGRvdWJsZS10YXAgc3RhdGUgdG8gcHJldmVudCBtdWx0aXBsZSBkYXNoZXNcbiAgICAgICAgICB0aGlzLmlucHV0TWFuYWdlci5yZXNldERvdWJsZVRhcChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihg4p2MIERhc2ggZmFpbGVkIHRvIHN0YXJ0IGZvciBrZXk6ICR7a2V5LnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJyZWFrOyAvLyBPbmx5IHByb2Nlc3Mgb25lIGRhc2ggcGVyIGZyYW1lXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVEYXNoTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNEYXNoaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICBjb25zdCBkYXNoUmVzdWx0ID0gbW92ZW1lbnQudXBkYXRlRGFzaChjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nIChzaW1pbGFyIHRvIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICAgIGNvbnN0IE1BWF9EQVNIX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGRhc2hSZXN1bHQubmV3UG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZUZyb21PcmlnaW4gPD0gTUFYX0RBU0hfQk9VTkRTKSB7XG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGRhc2hSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FuY2VsIGRhc2ggaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIGNvbnNvbGUud2FybihgRGFzaCBjYW5jZWxsZWQ6IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpbiAoJHtkaXN0YW5jZUZyb21PcmlnaW4udG9GaXhlZCgyKX0gPiAke01BWF9EQVNIX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbERhc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5pc0NvbXBsZXRlKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PgSBEYXNoIGNvbXBsZXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhcmdlTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNDaGFyZ2luZykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY2hhcmdlIHdhcyBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgIGlmICh0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgbW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZVJlc3VsdCA9IG1vdmVtZW50LnVwZGF0ZUNoYXJnZShjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKSB7XG4gICAgICAvLyBBcHBseSBib3VuZHMgY2hlY2tpbmdcbiAgICAgIGNvbnN0IE1BWF9DSEFSR0VfQk9VTkRTID0gMjk7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW4gKG1hdGNoZXMgbWFwIGJvdW5kYXJ5KVxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcGlsbGFyIGNvbGxpc2lvblxuICAgICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2VGcm9tT3JpZ2luID4gTUFYX0NIQVJHRV9CT1VORFMpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW5cbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW4gKCR7ZGlzdGFuY2VGcm9tT3JpZ2luLnRvRml4ZWQoMil9ID4gJHtNQVhfQ0hBUkdFX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBjb2xsaWRlIHdpdGggYSBwaWxsYXJcbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBjb2xsaWRlIHdpdGggcGlsbGFyIGF0IFske3BpbGxhckNvbGxpc2lvbi5waWxsYXJDZW50ZXIudG9BcnJheSgpLmpvaW4oJywgJyl9XWApO1xuICAgICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSB3YXMgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgcG9zaXRpb24gaWYgbm90IHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5pc0NvbXBsZXRlIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBtb3ZlbWVudCBjb21wbGV0ZWQnKTtcbiAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2UgaXMgY29tcGxldGVcbiAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGdldFdvcmxkU3BhY2VEaXJlY3Rpb24oaW5wdXREaXJlY3Rpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICAvLyBHZXQgY2FtZXJhIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB3b3JsZERpcmVjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggcmFnZSAobWluaW11bSAyMCByYWdlIHJlcXVpcmVkKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3REaXZpbmVTdG9ybSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqhIE5vdCBlbm91Z2ggcmFnZSB0byBjYXN0IERpdmluZSBTdG9ybSAocmVxdWlyZXMgbWluaW11bSAyMCByYWdlKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUgPCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgRGl2aW5lIFN0b3JtIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCByYWdlIGFtb3VudCBhbmQgY29uc3VtZSBBTEwgcmFnZVxuICAgIGNvbnN0IGN1cnJlbnRSYWdlID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiA0MDsgLy8gRmFsbGJhY2sgdG8gNDAgaWYgZ2FtZVVJIG5vdCBhdmFpbGFibGVcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUFsbFJhZ2UoKTsgLy8gQ29uc3VtZSBhbGwgcmFnZSBpbnN0ZWFkIG9mIGp1c3QgMjBcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgQ29uc3VtZWQgJHtjdXJyZW50UmFnZX0gcmFnZSBmb3IgRGl2aW5lIFN0b3JtYCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGV4dGVuZGVkIGR1cmF0aW9uOiBiYXNlIDQgc2Vjb25kcyArIDEgc2Vjb25kIHBlciAxMCByYWdlIGNvbnN1bWVkXG4gICAgY29uc3QgYmFzZVN0b3JtRHVyYXRpb24gPSAxMDAwOyAvLyA0IHNlY29uZHMgYmFzZVxuICAgIGNvbnN0IGJvbnVzRHVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRSYWdlIC8gMTApICogNTAwOyAvLyAxIHNlY29uZCBwZXIgMTAgcmFnZVxuICAgIGNvbnN0IHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbiA9IGJhc2VTdG9ybUR1cmF0aW9uICsgYm9udXNEdXJhdGlvbjtcblxuICAgIGNvbnNvbGUubG9nKGDimqEgRGl2aW5lIFN0b3JtIGFjdGl2YXRlZCEgRHVyYXRpb246ICR7dG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uIC8gMTAwMH1zIChiYXNlOiA0cyArIGJvbnVzOiAke2JvbnVzRHVyYXRpb24gLyAxMDAwfXMgZnJvbSAke2N1cnJlbnRSYWdlfSByYWdlKWApO1xuICAgIHRoaXMuaXNEaXZpbmVTdG9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGl2aW5lU3Rvcm1UaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBEaXZpbmUgU3Rvcm0gY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gRGl2aW5lIFN0b3JtIGxhc3RzIGZvciBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUubG9nKCfimqEgRGl2aW5lIFN0b3JtIGNvbXBsZXRlZCcpO1xuICAgIH0sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1DaGFyZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSA8IHRoaXMuY2hhcmdlQ29vbGRvd24pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgQ2hhcmdlIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmNoYXJnZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ2hhcmdlIGFjdGl2YXRlZCEnKTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0Q2hhcmdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFJlc2V0IGNvbGxpc2lvbiB0cmFja2luZyBmb3IgbmV3IGNoYXJnZVxuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBDaGFyZ2UgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25DaGFyZ2VDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uQ2hhcmdlQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIEdhaW4gcmFnZSBmb3IgdXNpbmcgY2hhcmdlIGFiaWxpdHkgKCsyMCByYWdlKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmdhaW5SYWdlKDIwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gR2FpbmVkIDIwIHJhZ2UgZnJvbSB1c2luZyBDaGFyZ2UgYWJpbGl0eScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCB0aGUgY2hhcmdlIG1vdmVtZW50IHVzaW5nIHRoZSBzZXBhcmF0ZSBjaGFyZ2Ugc3lzdGVtXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgLy8gR2V0IGNoYXJnZSBkaXJlY3Rpb24gZnJvbSBjYW1lcmFcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSAwOyAvLyBLZWVwIG1vdmVtZW50IGhvcml6b250YWxcbiAgICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgY2hhcmdlIHdpdGggMTAuNSBkaXN0YW5jZSAoc2VwYXJhdGUgZnJvbSBkYXNoIHN5c3RlbSlcbiAgICAgICAgY29uc3QgY2hhcmdlU3RhcnRlZCA9IHBsYXllck1vdmVtZW50LnN0YXJ0Q2hhcmdlKGRpcmVjdGlvbiwgcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhcmdlU3RhcnRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ2hhcmdlIG1vdmVtZW50IHN0YXJ0ZWQgd2l0aCAxMC41IGRpc3RhbmNlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2NoZWR1bGUgY2hhcmdlIGRhbWFnZSBkZXRlY3Rpb24gZHVyaW5nIG1vdmVtZW50XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0sIGRpcmVjdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqU77iPIENoYXJnZSBmYWlsZWQgdG8gc3RhcnQgKGFscmVhZHkgY2hhcmdpbmcgb3IgZGFzaGluZyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNrIGNoYXJnZSBoaXQgZW50aXRpZXMgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzIGFuZCBlbmFibGUgY29sbGlzaW9uIHN0b3BwaW5nXG4gIHByaXZhdGUgY2hhcmdlSGl0RW50aXRpZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcblxuICAvLyBTY2hlZHVsZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBjaGFyZ2UgbW92ZW1lbnRcbiAgcHJpdmF0ZSBzY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgY2hhcmdlRGlyZWN0aW9uOiBWZWN0b3IzLCBzdGFydFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMC43NTsgLy8gQ2hhcmdlIGxhc3RzIGFib3V0IDEuNSBzZWNvbmRzXG4gICAgY29uc3QgZGFtYWdlQ2hlY2tJbnRlcnZhbCA9IDUwOyAvLyBDaGVjayBmb3IgZGFtYWdlIGV2ZXJ5IDUwbXMgZm9yIGJldHRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgY29uc3QgY2hhcmdlRGFtYWdlID0gNDA7IC8vIEhpZ2ggZGFtYWdlIGZvciBjaGFyZ2UgYWJpbGl0eVxuICAgIGNvbnN0IGNoYXJnZVJhZGl1cyA9IDIuNTsgLy8gRGFtYWdlIHJhZGl1cyBhcm91bmQgcGxheWVyIGR1cmluZyBjaGFyZ2VcbiAgICBcbiAgICAvLyBSZXNldCBjaGFyZ2UgaGl0IHRyYWNraW5nXG4gICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5jbGVhcigpO1xuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgZGFtYWdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgXG4gICAgICAvLyBTdG9wIGlmIGNoYXJnZSBpcyBjb21wbGV0ZSwgY2FuY2VsbGVkLCBvciBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgICAgaWYgKCF0aGlzLmlzU3dvcmRDaGFyZ2luZyB8fCBjdXJyZW50VGltZSAtIHN0YXJ0VGltZSA+IGNoYXJnZUR1cmF0aW9uIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZGFtYWdlSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBkYW1hZ2VcbiAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBcbiAgICAgIGxldCBoaXRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gRGVidWc6IExvZyBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIGR1cmluZyBjaGFyZ2VcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENoYXJnZSBjb2xsaXNpb24gY2hlY2sgLSBUb3RhbCBlbnRpdGllcyBpbiB3b3JsZDogJHthbGxFbnRpdGllcy5sZW5ndGh9YCk7XG4gICAgICBcbiAgICAgIC8vIEVOSEFOQ0VEOiBBbHNvIGNoZWNrIGFnYWluc3Qgc2VydmVyIHBsYXllciBwb3NpdGlvbnMgZGlyZWN0bHkgYXMgYSBmYWxsYmFja1xuICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IG1pc3MgY29sbGlzaW9ucyBkdWUgdG8gZW50aXR5IHN5bmMgaXNzdWVzXG4gICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnMgfHwgbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbG9jYWxTb2NrZXRJZCA9ICh3aW5kb3cgYXMgYW55KS5sb2NhbFNvY2tldElkO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBBbHNvIGNoZWNraW5nICR7c2VydmVyUGxheWVycy5zaXplfSBzZXJ2ZXIgcGxheWVycyBkaXJlY3RseSBmb3IgY29sbGlzaW9uYCk7XG4gICAgICBcbiAgICAgIHNlcnZlclBsYXllcnMuZm9yRWFjaCgoc2VydmVyUGxheWVyOiBhbnksIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChwbGF5ZXJJZCA9PT0gbG9jYWxTb2NrZXRJZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGhpdCBwbGF5ZXJzICh1c2UgaGFzaCBvZiBwbGF5ZXIgSUQgZm9yIHRyYWNraW5nKVxuICAgICAgICBjb25zdCBwbGF5ZXJJZEhhc2ggPSBwbGF5ZXJJZC5sZW5ndGggKiAxMDAwICsgcGxheWVySWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKHBsYXllcklkSGFzaCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlcnZlclBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHNlcnZlclBsYXllci5wb3NpdGlvbi54LCBzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueSwgc2VydmVyUGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8oc2VydmVyUGxheWVyUG9zKTtcbiAgICAgICAgY29uc3Qgc3RvcERpc3RhbmNlID0gMC45ICsgMS4wOyAvLyBQbGF5ZXIgY29sbGlzaW9uIHJhZGl1cyArIGJ1ZmZlclxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gRGlyZWN0IHNlcnZlciBwbGF5ZXIgY2hlY2sgLSAke3BsYXllcklkfTogZGlzdGFuY2U9JHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgc3RvcERpc3RhbmNlPSR7c3RvcERpc3RhbmNlLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlICYmIHNlcnZlclBsYXllci5oZWFsdGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKalO+4jyBEaXJlY3Qgc2VydmVyIGNvbGxpc2lvbiBkZXRlY3RlZCB3aXRoIHBsYXllciAke3BsYXllcklkfSFgKTtcbiAgICAgICAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmFkZChwbGF5ZXJJZEhhc2gpO1xuICAgICAgICAgIGhpdFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgZGFtYWdlIHRocm91Z2ggUFZQIHN5c3RlbSBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdzd29yZF9jaGFyZ2VfaGl0JywgcGxheWVyUG9zaXRpb24uY2xvbmUoKSwgY2hhcmdlRGlyZWN0aW9uLmNsb25lKCksIHtcbiAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgIHRhcmdldElkOiBwbGF5ZXJJZCxcbiAgICAgICAgICAgICAgaGl0UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBzZXJ2ZXJQbGF5ZXJQb3MueCxcbiAgICAgICAgICAgICAgICB5OiBzZXJ2ZXJQbGF5ZXJQb3MueSxcbiAgICAgICAgICAgICAgICB6OiBzZXJ2ZXJQbGF5ZXJQb3MuelxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICAgIC8vIFNraXAgc2VsZlxuICAgICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgYWxyZWFkeSBoaXQgZW50aXRpZXNcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKGVudGl0eS5pZCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgdHJhbnNmb3JtIGFuZCBoZWFsdGggKGNvdWxkIGJlIGVuZW15IG9yIHBsYXllcilcbiAgICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICAgIGNvbnN0IGVudGl0eUNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWJ1ZzogTG9nIGVudGl0eSBkZXRhaWxzXG4gICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBDaGVja2luZyBlbnRpdHkgJHtlbnRpdHkuaWR9ICgke2VudGl0eVR5cGV9KTogdHJhbnNmb3JtPSR7ISFlbnRpdHlUcmFuc2Zvcm19LCBoZWFsdGg9JHshIWVudGl0eUhlYWx0aH0sIGNvbGxpZGVyPSR7ISFlbnRpdHlDb2xsaWRlcn0sIGlzRGVhZD0ke2VudGl0eUhlYWx0aD8uaXNEZWFkfWApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFlbnRpdHlUcmFuc2Zvcm0gfHwgIWVudGl0eUhlYWx0aCB8fCBlbnRpdHlIZWFsdGguaXNEZWFkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlbnRpdHlQb3NpdGlvbiA9IGVudGl0eVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBpcyB3aXRoaW4gY2hhcmdlIGRhbWFnZSByYWRpdXNcbiAgICAgICAgLy8gSW4gUFZQLCB3ZSB3YW50IHRvIHN0b3AganVzdCBiZWZvcmUgaGl0dGluZyB0aGUgZW5lbXksIG5vdCBvdmVybGFwIHdpdGggdGhlbVxuICAgICAgICBjb25zdCBzdG9wRGlzdGFuY2UgPSBlbnRpdHlDb2xsaWRlciA/IGVudGl0eUNvbGxpZGVyLnJhZGl1cyArIDEuMCA6IGNoYXJnZVJhZGl1czsgLy8gU3RvcCAxIHVuaXQgYXdheSBmcm9tIGVuZW15IGVkZ2VcbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnOiBMb2cgcG9zaXRpb24gYW5kIGRpc3RhbmNlIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEVudGl0eSAke2VudGl0eS5pZH0gKCR7ZW50aXR5VHlwZX0pOiBwbGF5ZXJQb3M9WyR7cGxheWVyUG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtwbGF5ZXJQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnoudG9GaXhlZCgyKX1dLCBlbnRpdHlQb3M9WyR7ZW50aXR5UG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtlbnRpdHlQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke2VudGl0eVBvc2l0aW9uLnoudG9GaXhlZCgyKX1dLCBkaXN0YW5jZT0ke2Rpc3RhbmNlLnRvRml4ZWQoMil9LCBzdG9wRGlzdGFuY2U9JHtzdG9wRGlzdGFuY2UudG9GaXhlZCgyKX0sIGNvbGxpZGVyUmFkaXVzPSR7ZW50aXR5Q29sbGlkZXI/LnJhZGl1cyB8fCAnbm9uZSd9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gTWFyayBhcyBoaXQgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzXG4gICAgICAgICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5hZGQoZW50aXR5LmlkKTtcbiAgICAgICAgICBoaXRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW1cbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGNoYXJnZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdjaGFyZ2UnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKalO+4jyBDaGFyZ2UgaGl0ICR7ZW50aXR5VHlwZX0gZm9yICR7Y2hhcmdlRGFtYWdlfSBkYW1hZ2UgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCcm9hZGNhc3QgY2hhcmdlIGF0dGFjayBmb3IgUFZQIChpbmNsdWRlcyBkYW1hZ2UgYW5kIGFuaW1hdGlvbilcbiAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnc3dvcmRfY2hhcmdlX2hpdCcsIHBsYXllclBvc2l0aW9uLmNsb25lKCksIGNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLCB7XG4gICAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IGVudGl0eS5pZCxcbiAgICAgICAgICAgICAgICBoaXRQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogZW50aXR5UG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgIHk6IGVudGl0eVBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICB6OiBlbnRpdHlQb3NpdGlvbi56XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJbiBQVlAgbW9kZSwgc3RvcCBjaGFyZ2Ugd2hlbiBoaXR0aW5nIHNvbWV0aGluZ1xuICAgICAgaWYgKGhpdFNvbWV0aGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqU77iPIENoYXJnZSBzdG9wcGVkIGJ5IGNvbGxpc2lvbiAtIGVuZGluZyBjaGFyZ2UgbW92ZW1lbnRgKTtcbiAgICAgICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCB0aGUgY2hhcmdlIG1vdmVtZW50IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgICAgIHBsYXllck1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRhbWFnZSBpbnRlcnZhbCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IGZ1cnRoZXIgaGl0c1xuICAgICAgICBjbGVhckludGVydmFsKGRhbWFnZUludGVydmFsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgY2hhcmdlIGNvbXBsZXRpb25cbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZGFtYWdlQ2hlY2tJbnRlcnZhbCk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gQ2hhcmdlIGNvbXBsZXRlc1xuICBwdWJsaWMgb25DaGFyZ2VDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBjb21wbGV0ZWQnKTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRGVmbGVjdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REZWZsZWN0VGltZSA8IHRoaXMuZGVmbGVjdENvb2xkb3duKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4o+wIERlZmxlY3Qgb24gY29vbGRvd24gZm9yICR7KHRoaXMuZGVmbGVjdENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+boe+4jyBEZWZsZWN0IGFjdGl2YXRlZCEnKTtcbiAgICB0aGlzLmlzRGVmbGVjdGluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGVmbGVjdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIERlZmxlY3QgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5vbkRlZmxlY3RDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHVwIGRlZmxlY3QgYmFycmllciB0aGF0IGJsb2NrcyBkYW1hZ2UgYW5kIHJlZmxlY3RzIHByb2plY3RpbGVzXG4gICAgdGhpcy5zZXR1cERlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gQXV0by1jb21wbGV0ZSBkZWZsZWN0IGFmdGVyIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm9uRGVmbGVjdENvbXBsZXRlKCk7XG4gICAgfSwgdGhpcy5kZWZsZWN0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBWaXBlciBTdGluZyBvbiBjb29sZG93biBmb3IgJHsodGhpcy52aXBlclN0aW5nRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNjAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdFZpcGVyU3RpbmcoKSkge1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gTm90IGVub3VnaCBlbmVyZ3kgdG8gY2FzdCBWaXBlciBTdGluZyAocmVxdWlyZXMgNjAgZW5lcmd5KScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gQ29uc3VtZWQgNjAgZW5lcmd5IGZvciBWaXBlciBTdGluZycpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5CNIFZpcGVyIFN0aW5nIGFjdGl2YXRlZCAtIHN0YXJ0aW5nIGNoYXJnZSEnKTtcbiAgICB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMTAwMDsgLy8gMSBzZWNvbmQgY2hhcmdlIHRpbWVcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn5CNIEZpcmluZyBWaXBlciBTdGluZyBwcm9qZWN0aWxlIScpO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDE7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogVmlwZXIgU3RpbmcgZGFtYWdlIGlzIGhhbmRsZWQgYnkgVmlwZXJTdGluZ01hbmFnZXIsIG5vdCBFQ1MgcHJvamVjdGlsZXNcbiAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBwcm9qZWN0aWxlcyBhbmQgZGFtYWdlXG4gICAgXG4gICAgLy8gVHJpZ2dlciBWaXBlciBTdGluZyBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgZ2xvYmFsIFZpcGVyIFN0aW5nIG1hbmFnZXIgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgY29uc3Qgc3VjY2VzcyA9IHRyaWdnZXJHbG9iYWxWaXBlclN0aW5nKCk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CNIFZpcGVyIFN0aW5nIHZpc3VhbCBlZmZlY3RzIHN1Y2Nlc3NmdWxseSB0cmlnZ2VyZWQhJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCd2aXBlcl9zdGluZ19wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiAxNixcbiAgICAgICAgZGFtYWdlOiA2MSxcbiAgICAgICAgbGlmZXRpbWU6IDUsXG4gICAgICAgIGlzUmV0dXJuaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn4+5IHBlcmZvcm1CYXJyYWdlIGNhbGxlZCEnKTtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFycmFnZVRpbWUgPCB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBCYXJyYWdlIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmJhcnJhZ2VGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lKSkudG9GaXhlZCgxKX1zYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg0MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0QmFycmFnZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PuSBOb3QgZW5vdWdoIGVuZXJneSB0byBjYXN0IEJhcnJhZ2UgKHJlcXVpcmVzIDQwIGVuZXJneSknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4+5IENvbnN1bWVkIDQwIGVuZXJneSBmb3IgQmFycmFnZScpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn4+5IEJhcnJhZ2UgYWN0aXZhdGVkIC0gc3RhcnRpbmcgY2hhcmdlIScpO1xuICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RCYXJyYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA1MDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVCYXJyYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+PuSBGaXJpbmcgQmFycmFnZSBwcm9qZWN0aWxlcyEnKTtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAxOyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgY29tcGVuc2F0aW9uIGFzIHByb2plY3RpbGUgc3lzdGVtXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIDUgYXJyb3dzOiBjZW50ZXIgKDDCsCksIGxlZnQgKDE1wrAsIDMwwrApLCByaWdodCAoLTE1wrAsIC0zMMKwKSB1c2luZyBwcm9wZXIgRUNTIHByb2plY3RpbGVzXG4gICAgY29uc3QgYW5nbGVzID0gWzAsIE1hdGguUEkgLyAxMiwgLU1hdGguUEkgLyAxMiwgTWF0aC5QSSAvIDYsIC1NYXRoLlBJIC8gNl07IC8vIDDCsCwgMTXCsCwgLTE1wrAsIDMwwrAsIC0zMMKwXG4gICAgXG4gICAgYW5nbGVzLmZvckVhY2goYW5nbGUgPT4ge1xuICAgICAgLy8gUm90YXRlIHRoZSBiYXNlIGRpcmVjdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCkubWFrZVJvdGF0aW9uWShhbmdsZSk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgc3Bhd25Qb3NpdGlvbi5hZGQocHJvamVjdGlsZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHByb3BlciBFQ1MgcHJvamVjdGlsZSBlbnRpdHlcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiAyMiwgLy8gU2xpZ2h0bHkgZmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDIwKVxuICAgICAgICBkYW1hZ2U6IDMwLCAvLyBIaWdoIGRhbWFnZSBmb3IgYmFycmFnZSBhcnJvd3NcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIG1heERpc3RhbmNlOiAyNSwgLy8gTGltaXQgYmFycmFnZSBhcnJvd3MgdG8gMjUgdW5pdHMgZGlzdGFuY2UgKHNhbWUgYXMgcmVndWxhciBhcnJvd3MpXG4gICAgICAgIHBpZXJjaW5nOiBmYWxzZSxcbiAgICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24sXG4gICAgICAgIHRoaXMucGxheWVyRW50aXR5IS5pZCxcbiAgICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBhcyBiYXJyYWdlIGFycm93IGZvciB2aXN1YWwgaWRlbnRpZmljYXRpb25cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpIGFzIFJlbmRlcmVyO1xuICAgICAgaWYgKHJlbmRlcmVyPy5tZXNoKSB7XG4gICAgICAgIHJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNCYXJyYWdlQXJyb3cgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gZmFsc2U7IC8vIE92ZXJyaWRlIHJlZ3VsYXIgYXJyb3cgbWFya2luZ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2JhcnJhZ2VfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIHByb2plY3RpbGVEaXJlY3Rpb24sIHByb2plY3RpbGVDb25maWcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+PuSBDcmVhdGVkIEJhcnJhZ2UgYXJyb3cgJHtwcm9qZWN0aWxlRW50aXR5LmlkfSBhdCBhbmdsZSAkeyhhbmdsZSAqIDE4MCAvIE1hdGguUEkpLnRvRml4ZWQoMSl9wrBgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIEJhcnJhZ2UgY2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgdmlzdWFsIGVmZmVjdHMgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMub25CYXJyYWdlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn4+5IEJhcnJhZ2Ugc3VjY2Vzc2Z1bGx5IGZpcmVkIHdpdGggNSBFQ1MgcHJvamVjdGlsZXMhJyk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBBY3RpdmF0ZSB0aGUgZGVmbGVjdCBiYXJyaWVyXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBsYXllclJvdGF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgXG4gICAgLy8gVXNlIFNBTUUgcm90YXRpb24gbG9naWMgYXMgRHJhZ29uUmVuZGVyZXIgZm9yIGNvbnNpc3RlbmN5IHdpdGggdmlzdWFsIHNoaWVsZFxuICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgaWYgKG1vdmVtZW50ICYmIG1vdmVtZW50LmlucHV0U3RyZW5ndGggPiAwLjEpIHtcbiAgICAgICAgLy8gUGxheWVyIGlzIGFjdGl2ZWx5IG1vdmluZyAtIHVzZSBtb3ZlbWVudCBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIpXG4gICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICBpZiAobW92ZURpci5sZW5ndGgoKSA+IDAuMSkge1xuICAgICAgICAgIGNvbnN0IG1vdmVBbmdsZSA9IE1hdGguYXRhbjIobW92ZURpci54LCBtb3ZlRGlyLnopO1xuICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5hY3RpdmF0ZShwbGF5ZXJQb3NpdGlvbiwgcGxheWVyUm90YXRpb24sIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGRlZmxlY3QgYmFycmllciBwb3NpdGlvbiBpZiBpdCdzIGFjdGl2ZVxuICAgIGlmICh0aGlzLmRlZmxlY3RCYXJyaWVyLmlzQmFycmllckFjdGl2ZSgpKSB7XG4gICAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBwbGF5ZXJSb3RhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBVc2UgU0FNRSByb3RhdGlvbiBsb2dpYyBhcyBEcmFnb25SZW5kZXJlciBmb3IgY29uc2lzdGVuY3kgd2l0aCB2aXN1YWwgc2hpZWxkXG4gICAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDAuMSkge1xuICAgICAgICAgIC8vIFBsYXllciBpcyBhY3RpdmVseSBtb3ZpbmcgLSB1c2UgbW92ZW1lbnQgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyKVxuICAgICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICAgIGlmIChtb3ZlRGlyLmxlbmd0aCgpID4gMC4xKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlQW5nbGUgPSBNYXRoLmF0YW4yKG1vdmVEaXIueCwgbW92ZURpci56KTtcbiAgICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYmFycmllciBwb3NpdGlvbiB0byBmb2xsb3cgcGxheWVyXG4gICAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLnVwZGF0ZVBvc2l0aW9uKHBsYXllclBvc2l0aW9uLCBwbGF5ZXJSb3RhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIERlZmxlY3QgY29tcGxldGVzXG4gIHB1YmxpYyBvbkRlZmxlY3RDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+boe+4jyBEZWZsZWN0IGNvbXBsZXRlZCcpO1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvLyBQdWJsaWMgbWV0aG9kcyB0byBnZXQgY29vbGRvd24gaW5mb3JtYXRpb24gZm9yIFVJXG4gIHB1YmxpYyBnZXRXZWFwb25Td2l0Y2hDb29sZG93bigpOiB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUpKSxcbiAgICAgIG1heDogdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93blxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0QWJpbGl0eUNvb2xkb3ducygpOiBSZWNvcmQ8c3RyaW5nLCB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXI7IGlzQWN0aXZlOiBib29sZWFuIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIGNvbnN0IGNvb2xkb3duczogUmVjb3JkPHN0cmluZywgeyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyOyBpc0FjdGl2ZTogYm9vbGVhbiB9PiA9IHt9O1xuICAgIFxuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRlZmxlY3RDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERlZmxlY3RUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5kZWZsZWN0Q29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGVmbGVjdGluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNoYXJnZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY2hhcmdlQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzU3dvcmRDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGl2aW5lU3Rvcm1pbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5iYXJyYWdlRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuYmFycmFnZUZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNvYnJhU2hvdEZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY29icmFTaG90RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy52aXBlclN0aW5nRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIDEuMCAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUpKSxcbiAgICAgICAgbWF4OiAxLjAsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q3Jvc3NlbnRyb3B5VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiAwLCAvLyBObyBRIGFiaWxpdHkgeWV0XG4gICAgICAgIG1heDogMCxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuc2t5ZmFsbENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U2t5ZmFsbFRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLnNreWZhbGxDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNTa3lmYWxsaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IDAsIC8vIE5vIFIgYWJpbGl0eSB5ZXRcbiAgICAgICAgbWF4OiAwLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb29sZG93bnM7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMyIsIk1hdHJpeDQiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkhlYWx0aCIsIkVuZW15IiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbWJhdFN5c3RlbSIsIldlYXBvblN1YmNsYXNzIiwiV2VhcG9uVHlwZSIsIkRlZmxlY3RCYXJyaWVyIiwidHJpZ2dlckdsb2JhbEZyb3N0Tm92YSIsImFkZEdsb2JhbEZyb3plbkVuZW15IiwidHJpZ2dlckdsb2JhbENvYnJhU2hvdCIsInRyaWdnZXJHbG9iYWxWaXBlclN0aW5nIiwiQ29udHJvbFN5c3RlbSIsInNldFBsYXllciIsImVudGl0eSIsInBsYXllckVudGl0eSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicGxheWVyVHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwicGxheWVyTW92ZW1lbnQiLCJ1cGRhdGVEZWJ1ZmZzIiwiY29uc29sZSIsIndhcm4iLCJoYW5kbGVXZWFwb25Td2l0Y2hpbmciLCJoYW5kbGVEYXNoTW92ZW1lbnQiLCJoYW5kbGVDaGFyZ2VNb3ZlbWVudCIsImlzRGFzaGluZyIsImlzQ2hhcmdpbmciLCJpc0Zyb3plbiIsImlzU2t5ZmFsbGluZyIsImhhbmRsZU1vdmVtZW50SW5wdXQiLCJoYW5kbGVDb21iYXRJbnB1dCIsInVwZGF0ZURlZmxlY3RCYXJyaWVyIiwibW92ZW1lbnQiLCJjaGVja0ZvckRhc2hJbnB1dCIsImlucHV0RGlyZWN0aW9uIiwiaGFzSW5wdXQiLCJpbnB1dE1hbmFnZXIiLCJpc0tleVByZXNzZWQiLCJ6IiwieCIsImxlbmd0aCIsIm5vcm1hbGl6ZSIsImNhbWVyYURpcmVjdGlvbiIsImNhbWVyYSIsImdldFdvcmxkRGlyZWN0aW9uIiwiY2FtZXJhUmlnaHQiLCJjcm9zc1ZlY3RvcnMiLCJjYW1lcmFGb3J3YXJkIiwid29ybGREaXJlY3Rpb24iLCJhZGRTY2FsZWRWZWN0b3IiLCJzZXRNb3ZlRGlyZWN0aW9uIiwianVtcCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RXZWFwb25Td2l0Y2hUaW1lIiwid2VhcG9uU3dpdGNoQ29vbGRvd24iLCJjdXJyZW50V2VhcG9uIiwiU1dPUkQiLCJjdXJyZW50U3ViY2xhc3MiLCJESVZJTklUWSIsImZpcmVSYXRlIiwic3dvcmRGaXJlUmF0ZSIsInN3b3JkQ29tYm9TdGVwIiwibG9nIiwiQk9XIiwiRUxFTUVOVEFMIiwiU0NZVEhFIiwiQ0hBT1MiLCJzY3l0aGVGaXJlUmF0ZSIsIlNBQlJFUyIsIkZST1NUIiwic2FicmVzRmlyZVJhdGUiLCJoYW5kbGVCb3dJbnB1dCIsImhhbmRsZVNjeXRoZUlucHV0IiwiaGFuZGxlU3dvcmRJbnB1dCIsImhhbmRsZVNhYnJlc0lucHV0IiwiaXNWaXBlclN0aW5nQ2hhcmdpbmciLCJwZXJmb3JtVmlwZXJTdGluZyIsImlzQmFycmFnZUNoYXJnaW5nIiwicGVyZm9ybUJhcnJhZ2UiLCJpc0NvYnJhU2hvdENoYXJnaW5nIiwicGVyZm9ybUNvYnJhU2hvdCIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiY2hhcmdlUHJvZ3Jlc3MiLCJNYXRoIiwibWluIiwiZmluYWxDaGFyZ2VQcm9ncmVzcyIsImZpcmVQcm9qZWN0aWxlIiwidHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzIiwiZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJmaXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHkiLCJwZXJmb3JtUmVhbmltYXRlQWJpbGl0eSIsInBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5IiwibGFzdEZpcmVUaW1lIiwiZGlyZWN0aW9uIiwiY29tcGVuc2F0aW9uQW5nbGUiLCJQSSIsInJvdGF0aW9uTWF0cml4IiwibWFrZVJvdGF0aW9uQXhpcyIsImFwcGx5TWF0cml4NCIsInBlcmZlY3RTaG90TWluVGhyZXNob2xkIiwicGVyZmVjdFNob3RNYXhUaHJlc2hvbGQiLCJpc1BlcmZlY3RTaG90IiwiY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZSIsInBvc2l0aW9uIiwiY2xvbmUiLCJjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUiLCJhbmdsZSIsImF0YW4yIiwidG9GaXhlZCIsImNyZWF0ZVByb2plY3RpbGUiLCJzcGluU3RhdHVzIiwiY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZSIsImxhc3RDcm9zc2VudHJvcHlUaW1lIiwiY3Jvc3NlbnRyb3B5RmlyZVJhdGUiLCJjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZSIsInBvdGVudGlhbFRhcmdldHMiLCJ3b3JsZCIsInF1ZXJ5RW50aXRpZXMiLCJ2YWxpZFRhcmdldHMiLCJmaWx0ZXIiLCJ0YXJnZXQiLCJpZCIsImlzRGVhZCIsImhhc1ZhbGlkVGFyZ2V0cyIsInNob3VsZEJyb2FkY2FzdCIsIm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayIsInVuZGVmaW5lZCIsInNwYXduUG9zaXRpb24iLCJhZGQiLCJtdWx0aXBseVNjYWxhciIsInkiLCJwcm9qZWN0aWxlQ29uZmlnIiwic3BlZWQiLCJkYW1hZ2UiLCJsaWZldGltZSIsIm1heERpc3RhbmNlIiwic3ViY2xhc3MiLCJsZXZlbCIsImN1cnJlbnRMZXZlbCIsIm9wYWNpdHkiLCJwcm9qZWN0aWxlU3lzdGVtIiwiZ2FtZVVJIiwid2luZG93IiwiY2FuQ2FzdEVudHJvcGljQm9sdCIsImNvbnN1bWVNYW5hIiwiZW50cm9waWNDb25maWciLCJwaWVyY2luZyIsImV4cGxvc2l2ZSIsImV4cGxvc2lvblJhZGl1cyIsImNhbkNhc3RDcm9zc2VudHJvcHlCb2x0IiwiY3Jvc3NlbnRyb3B5Q29uZmlnIiwibGFzdFJlYW5pbWF0ZVRpbWUiLCJjdXJyZW50TWFuYSIsImdldEN1cnJlbnRNYW5hIiwiY2FuQ2FzdFJlYW5pbWF0ZSIsIm1hbmFCZWZvcmUiLCJtYW5hQWZ0ZXIiLCJ0cmlnZ2VyUmVhbmltYXRlRWZmZWN0IiwiaGVhbHRoQ29tcG9uZW50IiwiZGlkSGVhbCIsImhlYWwiLCJjdXJyZW50SGVhbHRoIiwibWF4SGVhbHRoIiwib25SZWFuaW1hdGVDYWxsYmFjayIsInBsYXllclBvc2l0aW9uIiwibGFzdEZyb3N0Tm92YVRpbWUiLCJmcm9zdE5vdmFGaXJlUmF0ZSIsImNhbkNhc3RGcm9zdE5vdmEiLCJnZXRXb3JsZFBvc2l0aW9uIiwib25Gcm9zdE5vdmFDYWxsYmFjayIsImZyZWV6ZUVuZW1pZXNJblJhZGl1cyIsImxhc3RDb2JyYVNob3RUaW1lIiwiY29icmFTaG90RmlyZVJhdGUiLCJjYW5DYXN0Q29icmFTaG90IiwiY29uc3VtZUVuZXJneSIsImNvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiY2hhcmdlU3RhcnRUaW1lIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VJbnRlcnZhbCIsInNldEludGVydmFsIiwiZWxhcHNlZCIsImNsZWFySW50ZXJ2YWwiLCJmaXJlQ29icmFTaG90Iiwib25Db2JyYVNob3RDYWxsYmFjayIsInZlbm9tRHVyYXRpb24iLCJjZW50ZXJQb3NpdGlvbiIsInJhZGl1cyIsImFsbEVudGl0aWVzIiwiZ2V0QWxsRW50aXRpZXMiLCJmcm96ZW5Db3VudCIsImRhbWFnZWRQbGF5ZXJzIiwiZm9yRWFjaCIsImVudGl0eVRyYW5zZm9ybSIsImVudGl0eUhlYWx0aCIsImVudGl0eVBvc2l0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZW5lbXkiLCJmcmVlemUiLCJ0b1N0cmluZyIsImNvbWJhdFN5c3RlbSIsImdldFN5c3RlbSIsImZyb3N0Tm92YURhbWFnZSIsInF1ZXVlRGFtYWdlIiwib25EZWJ1ZmZDYWxsYmFjayIsImNoYXJnZWRBcnJvd0NvbmZpZyIsInNldFdlYXBvblN1YmNsYXNzIiwic2V0Qm93UmVsZWFzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvbkJvd1JlbGVhc2VDYWxsYmFjayIsInNldERpdmluZVN0b3JtQ2FsbGJhY2siLCJvbkRpdmluZVN0b3JtQ2FsbGJhY2siLCJzZXRQcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrIiwic2V0VmlwZXJTdGluZ0NhbGxiYWNrIiwib25WaXBlclN0aW5nQ2FsbGJhY2siLCJzZXRCYXJyYWdlQ2FsbGJhY2siLCJvbkJhcnJhZ2VDYWxsYmFjayIsInNldFJlYW5pbWF0ZUNhbGxiYWNrIiwic2V0RnJvc3ROb3ZhQ2FsbGJhY2siLCJzZXRDb2JyYVNob3RDYWxsYmFjayIsInNldENoYXJnZUNhbGxiYWNrIiwib25DaGFyZ2VDYWxsYmFjayIsInNldERlZmxlY3RDYWxsYmFjayIsIm9uRGVmbGVjdENhbGxiYWNrIiwic2V0U2t5ZmFsbENhbGxiYWNrIiwib25Ta3lmYWxsQ2FsbGJhY2siLCJzZXREZWJ1ZmZDYWxsYmFjayIsInNldFdlYXBvbkxldmVsIiwiZ2V0Q3VycmVudFdlYXBvbkNvbmZpZyIsIndlYXBvbiIsImdldEN1cnJlbnRXZWFwb24iLCJnZXRDdXJyZW50U3ViY2xhc3MiLCJpc1dlYXBvbkNoYXJnaW5nIiwiZ2V0Q2hhcmdlUHJvZ3Jlc3MiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZ0FjdGl2ZSIsImdldFZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsInZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsImlzQmFycmFnZUNoYXJnaW5nQWN0aXZlIiwiZ2V0QmFycmFnZUNoYXJnZVByb2dyZXNzIiwiYmFycmFnZUNoYXJnZVByb2dyZXNzIiwiaXNDb2JyYVNob3RDaGFyZ2luZ0FjdGl2ZSIsImdldENvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiaXNXZWFwb25Td2luZ2luZyIsImlzU3dpbmdpbmciLCJnZXRTd29yZENvbWJvU3RlcCIsImlzRGl2aW5lU3Rvcm1BY3RpdmUiLCJpc0RpdmluZVN0b3JtaW5nIiwiaXNDaGFyZ2VBY3RpdmUiLCJpc1N3b3JkQ2hhcmdpbmciLCJpc0RlZmxlY3RBY3RpdmUiLCJpc0RlZmxlY3RpbmciLCJpc1NreWZhbGxBY3RpdmUiLCJwZXJmb3JtU3dvcmRNZWxlZUF0dGFjayIsInBlcmZvcm1EaXZpbmVTdG9ybSIsInBlcmZvcm1DaGFyZ2UiLCJwZXJmb3JtRGVmbGVjdCIsImxhc3RTd29yZEF0dGFja1RpbWUiLCJzd29yZENvbWJvUmVzZXRUaW1lIiwicGVyZm9ybU1lbGVlRGFtYWdlIiwib25Td29yZFN3aW5nQ29tcGxldGUiLCJwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2siLCJwZXJmb3JtU2t5ZmFsbCIsInVwZGF0ZVNreWZhbGxNb3ZlbWVudCIsInBlcmZvcm1TYWJyZXNNZWxlZURhbWFnZSIsIm9uU2FicmVzU3dpbmdDb21wbGV0ZSIsImhhc0NvbXBvbmVudCIsImF0dGFja1JhbmdlIiwiYXR0YWNrQW5nbGUiLCJsZWZ0U2FicmVEYW1hZ2UiLCJyaWdodFNhYnJlRGFtYWdlIiwiYXR0YWNrRGlyZWN0aW9uIiwiaGl0Q291bnQiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJ0YXJnZXRIZWFsdGgiLCJkaXJlY3Rpb25Ub1RhcmdldCIsInN1YiIsImRpc3RhbmNlVG9UYXJnZXQiLCJkb3RQcm9kdWN0IiwiZG90IiwiYW5nbGVUb1RhcmdldCIsImFjb3MiLCJtYXgiLCJzZXRUaW1lb3V0IiwibGFzdFNreWZhbGxUaW1lIiwic2t5ZmFsbENvb2xkb3duIiwiY2FuQ2FzdFNreWZhbGwiLCJza3lmYWxsUGhhc2UiLCJza3lmYWxsU3RhcnRUaW1lIiwic2t5ZmFsbFN0YXJ0UG9zaXRpb24iLCJjb3B5Iiwic2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSIsImdyYXZpdHkiLCJza3lmYWxsVGFyZ2V0SGVpZ2h0IiwianVtcEZvcmNlIiwidmVsb2NpdHkiLCJlbGFwc2VkVGltZSIsImZsb29yIiwicGVyZm9ybVNreWZhbGxMYW5kaW5nIiwiY29tcGxldGVTa3lmYWxsQWJpbGl0eSIsImxhbmRpbmdQb3NpdGlvbiIsImRhbWFnZVJhZGl1cyIsInNreWZhbGxEYW1hZ2UiLCJkaXN0YW5jZVRvTGFuZGluZyIsIm1lbGVlUmFuZ2UiLCJtZWxlZUFuZ2xlIiwiYmFzZURhbWFnZSIsImVuZW1pZXNIaXQiLCJlbmVteVRyYW5zZm9ybSIsImVuZW15SGVhbHRoIiwiZW5lbXlQb3NpdGlvbiIsInRvRW5lbXkiLCJhbmdsZVRvIiwiYW5nbGVEZWdyZWVzIiwibWF4QW5nbGVEZWdyZWVzIiwicmFnZUJlZm9yZSIsImdldEN1cnJlbnRSYWdlIiwicmFnZVRvR2FpbiIsImdhaW5SYWdlIiwicmFnZUFmdGVyIiwidHJhbnNmb3JtIiwiZGFzaERpcmVjdGlvbnMiLCJrZXkiLCJjaGVja0RvdWJsZVRhcCIsImRlYnVnSW5mbyIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsInRvVXBwZXJDYXNlIiwiZ2V0V29ybGRTcGFjZURpcmVjdGlvbiIsImRhc2hTdGFydGVkIiwic3RhcnREYXNoIiwicmVzZXREb3VibGVUYXAiLCJkYXNoUmVzdWx0IiwidXBkYXRlRGFzaCIsIm5ld1Bvc2l0aW9uIiwiTUFYX0RBU0hfQk9VTkRTIiwiZGlzdGFuY2VGcm9tT3JpZ2luIiwiY2FuY2VsRGFzaCIsImlzQ29tcGxldGUiLCJjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24iLCJjYW5jZWxDaGFyZ2UiLCJjaGFyZ2VSZXN1bHQiLCJ1cGRhdGVDaGFyZ2UiLCJNQVhfQ0hBUkdFX0JPVU5EUyIsInBpbGxhckNvbGxpc2lvbiIsImNoZWNrUGlsbGFyQ29sbGlzaW9uIiwib25DaGFyZ2VDb21wbGV0ZSIsImhhc0NvbGxpc2lvbiIsInBpbGxhckNlbnRlciIsInRvQXJyYXkiLCJqb2luIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiUElMTEFSX1JBRElVUyIsIm5vcm1hbCIsInNldCIsImNhbkNhc3REaXZpbmVTdG9ybSIsImxhc3REaXZpbmVTdG9ybVRpbWUiLCJkaXZpbmVTdG9ybUNvb2xkb3duIiwiY3VycmVudFJhZ2UiLCJjb25zdW1lQWxsUmFnZSIsImJhc2VTdG9ybUR1cmF0aW9uIiwiYm9udXNEdXJhdGlvbiIsInRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbiIsImxhc3RDaGFyZ2VUaW1lIiwiY2hhcmdlQ29vbGRvd24iLCJjaGFyZ2VTdGFydGVkIiwic3RhcnRDaGFyZ2UiLCJzY2hlZHVsZUNoYXJnZURhbWFnZSIsImNoYXJnZURpcmVjdGlvbiIsInN0YXJ0VGltZSIsImRhbWFnZUNoZWNrSW50ZXJ2YWwiLCJjaGFyZ2VEYW1hZ2UiLCJjaGFyZ2VSYWRpdXMiLCJjaGFyZ2VIaXRFbnRpdGllcyIsImNsZWFyIiwiZGFtYWdlSW50ZXJ2YWwiLCJoaXRTb21ldGhpbmciLCJzZXJ2ZXJQbGF5ZXJzIiwicHZwUGxheWVycyIsIk1hcCIsImxvY2FsU29ja2V0SWQiLCJzaXplIiwic2VydmVyUGxheWVyIiwicGxheWVySWQiLCJwbGF5ZXJJZEhhc2giLCJjaGFyQ29kZUF0IiwiaGFzIiwic2VydmVyUGxheWVyUG9zIiwic3RvcERpc3RhbmNlIiwiaGVhbHRoIiwidGFyZ2V0SWQiLCJoaXRQb3NpdGlvbiIsImVudGl0eUNvbGxpZGVyIiwiZW50aXR5VHlwZSIsImdldERpc3BsYXlOYW1lIiwibGFzdERlZmxlY3RUaW1lIiwiZGVmbGVjdENvb2xkb3duIiwic2V0dXBEZWZsZWN0QmFycmllciIsIm9uRGVmbGVjdENvbXBsZXRlIiwiZGVmbGVjdER1cmF0aW9uIiwibGFzdFZpcGVyU3RpbmdUaW1lIiwidmlwZXJTdGluZ0ZpcmVSYXRlIiwiY2FuQ2FzdFZpcGVyU3RpbmciLCJmaXJlVmlwZXJTdGluZyIsInN1Y2Nlc3MiLCJpc1JldHVybmluZyIsImxhc3RCYXJyYWdlVGltZSIsImJhcnJhZ2VGaXJlUmF0ZSIsImNhbkNhc3RCYXJyYWdlIiwiZmlyZUJhcnJhZ2UiLCJhbmdsZXMiLCJwcm9qZWN0aWxlRGlyZWN0aW9uIiwibWFrZVJvdGF0aW9uWSIsInByb2plY3RpbGVFbnRpdHkiLCJyZW5kZXJlciIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwiaXNSZWd1bGFyQXJyb3ciLCJwbGF5ZXJSb3RhdGlvbiIsImlucHV0U3RyZW5ndGgiLCJtb3ZlRGlyIiwibW92ZURpcmVjdGlvbiIsIm1vdmVBbmdsZSIsImRlZmxlY3RCYXJyaWVyIiwiYWN0aXZhdGUiLCJpc0JhcnJpZXJBY3RpdmUiLCJ1cGRhdGVQb3NpdGlvbiIsImRlYWN0aXZhdGUiLCJnZXRXZWFwb25Td2l0Y2hDb29sZG93biIsImN1cnJlbnQiLCJnZXRBYmlsaXR5Q29vbGRvd25zIiwiY29vbGRvd25zIiwiaXNBY3RpdmUiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInJlYW5pbWF0ZUZpcmVSYXRlIiwiU2V0IiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n                console.warn(\" Movement component missing updateDebuffs method:\", movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar collisions first\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no pillar collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO2dCQUNMQyxRQUFRQyxJQUFJLENBQUMsdURBQXVETDtZQUN0RTtZQUVBLElBQUksQ0FBQ00sY0FBYyxDQUFDUixXQUFXRSxVQUFVSjtRQUMzQztJQUNGO0lBRU9XLFlBQVlaLFFBQWtCLEVBQUVhLGNBQXNCLEVBQVE7UUFDbkUsMENBQTBDO1FBQzFDLEtBQUssTUFBTVgsVUFBVUYsU0FBVTtZQUM3QixNQUFNRyxZQUFZRCxPQUFPRSxZQUFZLENBQUNQLGdFQUFTQTtZQUMvQyxNQUFNUSxXQUFXSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUU3QywwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDSyxhQUFhLENBQUNFLFVBQVU7Z0JBQzNCO1lBQ0Y7WUFFQSxJQUFJLENBQUNGLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLElBQUks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Q0FBQ1MsQ0FBQyxHQUFHO1lBQ3RCcEIsU0FBU1csUUFBUSxDQUFDVSxDQUFDLEdBQUc7UUFDeEI7UUFFQSwyREFBMkQ7UUFDM0RyQixTQUFTVyxRQUFRLENBQUNNLEdBQUcsQ0FBQ2pCLFNBQVNpRSxZQUFZLENBQUNyRCxLQUFLLEdBQUdDLGNBQWMsQ0FBQ2pCO1FBRW5FLG9DQUFvQztRQUNwQ0ksU0FBU2lFLFlBQVksQ0FBQ2IsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUVoQyx5RUFBeUU7UUFDekUsTUFBTWMsZUFBZSxLQUFLLHVCQUF1QjtRQUNqRCxNQUFNQyxjQUFjRCxjQUFjLHdEQUF3RDtRQUUxRixJQUFJcEUsVUFBVWlCLFFBQVEsQ0FBQ29CLENBQUMsSUFBSWdDLGVBQWVuRSxTQUFTVyxRQUFRLENBQUN3QixDQUFDLElBQUksR0FBRztZQUNuRXJDLFVBQVVpQixRQUFRLENBQUNvQixDQUFDLEdBQUdnQztZQUN2Qm5FLFNBQVNXLFFBQVEsQ0FBQ3dCLENBQUMsR0FBRztZQUN0Qm5DLFNBQVNvRSxVQUFVLEdBQUc7UUFDeEIsT0FBTztZQUNMcEUsU0FBU29FLFVBQVUsR0FBRztRQUN4QjtJQUNGO0lBaE5BQyxhQUFjO1FBQ1osS0FBSzthQUhTQyxxQkFBcUI7WUFBQzlFLGdFQUFTQTtZQUFFQyw4REFBUUE7U0FBQztRQTZHMUQsdURBQXVEO2FBQ3RDcUQsbUJBQW1CO1lBQ2xDLElBQUl6RCx5REFBT0EsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQixJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLE1BQU0sR0FBRztZQUN0QixJQUFJQSx5REFBT0EsQ0FBQyxNQUFNLEdBQUcsS0FBUyxlQUFlO1NBQzlDO2FBQ2dCOEQsZ0JBQWdCLElBQUssOEJBQThCOztRQS9HbEUsSUFBSSxDQUFDb0IsUUFBUSxHQUFHLElBQUksZ0RBQWdEO0lBQ3RFO0FBOE1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHM/MGNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaHlzaWNzIHN5c3RlbSBmb3IgaGFuZGxpbmcgbW92ZW1lbnQgcGh5c2ljc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIGFzIEJhc2VQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgUGh5c2ljc1N5c3RlbSBleHRlbmRzIEJhc2VQaHlzaWNzU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIE1vdmVtZW50XTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxNTsgLy8gUnVuIGFmdGVyIGNvbnRyb2wgc3lzdGVtIGJ1dCBiZWZvcmUgcmVuZGVyaW5nXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgZXZlcnkgZnJhbWUgZm9yIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXNcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcblxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBjb21wb25lbnRzIGFyZSBtaXNzaW5nXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhbW92ZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIW1vdmVtZW50LmVuYWJsZWQgfHwgIW1vdmVtZW50LmNhbk1vdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIChmcm96ZW4sIHNsb3dlZCwgZXRjLilcbiAgICAgIGlmICh0eXBlb2YgbW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBNb3ZlbWVudCBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVEZWJ1ZmZzIG1ldGhvZDonLCBtb3ZlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtLCBtb3ZlbWVudCwgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGx5UGh5c2ljcyh0cmFuc2Zvcm0sIG1vdmVtZW50LCBmaXhlZERlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3ZlbWVudCh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eVxuICAgIGNvbnN0IGRlbHRhUG9zaXRpb24gPSBtb3ZlbWVudC52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBvdGVudGlhbCBuZXcgcG9zaXRpb25cbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0cmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICBjb25zdCBwb3RlbnRpYWxQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkZWx0YVBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBtYXAgYm91bmRhcnkgY29uc3RyYWludHMgd2l0aCBzbW9vdGggc2xpZGluZyAocmFkaXVzIG9mIDI5IHVuaXRzIGZyb20gb3JpZ2luKVxuICAgIGNvbnN0IE1BUF9SQURJVVMgPSAyOTtcbiAgICBcbiAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZIGZvciBib3VuZGFyeSlcbiAgICBjb25zdCBob3Jpem9udGFsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhwb3RlbnRpYWxQb3NpdGlvbi54LCAwLCBwb3RlbnRpYWxQb3NpdGlvbi56KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBob3Jpem9udGFsUG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBjb2xsaXNpb25zIGZpcnN0XG4gICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihwb3RlbnRpYWxQb3NpdGlvbik7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlRnJvbUNlbnRlciA+PSBNQVBfUkFESVVTKSB7XG4gICAgICAvLyBJZiB3ZSBoaXQgdGhlIGJvdW5kYXJ5LCBjYWxjdWxhdGUgdGFuZ2VudCBtb3ZlbWVudCBmb3Igc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IGN1cnJlbnRIb3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMoY3VycmVudFBvc2l0aW9uLngsIDAsIGN1cnJlbnRQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRvQ2VudGVyID0gY3VycmVudEhvcml6b250YWxQb3MuY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIHJhZGl1cylcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtdG9DZW50ZXIueiwgMCwgdG9DZW50ZXIueCk7XG4gICAgICBcbiAgICAgIC8vIFByb2plY3Qgb3VyIGhvcml6b250YWwgbW92ZW1lbnQgb250byB0aGUgdGFuZ2VudFxuICAgICAgY29uc3QgaG9yaXpvbnRhbE1vdmVtZW50ID0gbmV3IFZlY3RvcjMoZGVsdGFQb3NpdGlvbi54LCAwLCBkZWx0YVBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcihob3Jpem9udGFsTW92ZW1lbnQuZG90KHRhbmdlbnQpKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdGhlIHRhbmdlbnRpYWwgbW92ZW1lbnQgd2hpbGUga2VlcGluZyBkaXN0YW5jZSB0byBjZW50ZXIgY29uc3RhbnRcbiAgICAgIGNvbnN0IG5ld0hvcml6b250YWxQb3NpdGlvbiA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmFkZCh0YW5nZW50TW92ZW1lbnQpO1xuICAgICAgbmV3SG9yaXpvbnRhbFBvc2l0aW9uLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKE1BUF9SQURJVVMpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb24gd2l0aCB0YW5nZW50IG1vdmVtZW50IGFuZCBwcmVzZXJ2ZSBZIG1vdmVtZW50XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oXG4gICAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi54LCBcbiAgICAgICAgY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksIC8vIEFsbG93IHZlcnRpY2FsIG1vdmVtZW50IChqdW1waW5nLCBmYWxsaW5nKVxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24uelxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgIC8vIEhhbmRsZSBwaWxsYXIgY29sbGlzaW9uIHdpdGggc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uLCBkZWx0YVBvc2l0aW9uLCBwaWxsYXJDb2xsaXNpb24pO1xuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKHNsaWRlUG9zaXRpb24ueCwgc2xpZGVQb3NpdGlvbi55LCBzbGlkZVBvc2l0aW9uLnopO1xuICAgICAgXG4gICAgICAvLyBSZWR1Y2UgdmVsb2NpdHkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlsbGFyIHRvIHByZXZlbnQgYm91bmNpbmdcbiAgICAgIGNvbnN0IHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50ID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IocGlsbGFyQ29sbGlzaW9uLm5vcm1hbCk7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS5zdWIodmVsb2NpdHlOb3JtYWxDb21wb25lbnQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdpdGhpbiBib3VuZHMgYW5kIG5vIHBpbGxhciBjb2xsaXNpb24sIG1vdmUgbm9ybWFsbHlcbiAgICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoZGVsdGFQb3NpdGlvbi54LCBkZWx0YVBvc2l0aW9uLnksIGRlbHRhUG9zaXRpb24ueik7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0cmFuc2Zvcm0gbWF0cml4IGFzIG5lZWRpbmcgdXBkYXRlXG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBkZWx0YVBvc2l0aW9uOiBWZWN0b3IzLCBjb2xsaXNpb246IHsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSk6IFZlY3RvcjMge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFuZ2VudCB2ZWN0b3IgKHBlcnBlbmRpY3VsYXIgdG8gbm9ybWFsIGluIFhaIHBsYW5lKVxuICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtY29sbGlzaW9uLm5vcm1hbC56LCAwLCBjb2xsaXNpb24ubm9ybWFsLngpO1xuICAgIFxuICAgIC8vIFByb2plY3QgdGhlIG1vdmVtZW50IHZlY3RvciBvbnRvIHRoZSB0YW5nZW50IGZvciBzbGlkaW5nXG4gICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gZGVsdGFQb3NpdGlvbi5jbG9uZSgpLnByb2plY3RPblZlY3Rvcih0YW5nZW50KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiB3aXRoIHNsaWRpbmcgbW92ZW1lbnRcbiAgICBjb25zdCBzbGlkZVBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uLmNsb25lKCkuYWRkKHRhbmdlbnRNb3ZlbWVudCk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlIG1haW50YWluIG1pbmltdW0gZGlzdGFuY2UgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueCwgMCwgY29sbGlzaW9uLnBpbGxhckNlbnRlci56KTtcbiAgICBjb25zdCBzbGlkZUhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhzbGlkZVBvc2l0aW9uLngsIDAsIHNsaWRlUG9zaXRpb24ueik7XG4gICAgY29uc3QgZGlzdGFuY2VBZnRlclNsaWRlID0gc2xpZGVIb3Jpem9udGFsLmRpc3RhbmNlVG8ocGlsbGFySG9yaXpvbnRhbCk7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlQWZ0ZXJTbGlkZSA8IHRoaXMuUElMTEFSX1JBRElVUykge1xuICAgICAgLy8gUHVzaCB0aGUgcG9zaXRpb24gdG8gbWFpbnRhaW4gbWluaW11bSBkaXN0YW5jZVxuICAgICAgY29uc3QgcHVzaERpcmVjdGlvbiA9IHNsaWRlSG9yaXpvbnRhbC5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChwdXNoRGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHB1c2hEaXJlY3Rpb24uc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgfVxuICAgICAgY29uc3QgY29ycmVjdGVkSG9yaXpvbnRhbCA9IHBpbGxhckhvcml6b250YWwuY2xvbmUoKS5hZGQocHVzaERpcmVjdGlvbi5tdWx0aXBseVNjYWxhcih0aGlzLlBJTExBUl9SQURJVVMpKTtcbiAgICAgIHNsaWRlUG9zaXRpb24ueCA9IGNvcnJlY3RlZEhvcml6b250YWwueDtcbiAgICAgIHNsaWRlUG9zaXRpb24ueiA9IGNvcnJlY3RlZEhvcml6b250YWwuejtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNsaWRlUG9zaXRpb247XG4gIH1cblxuICBwcml2YXRlIGFwcGx5UGh5c2ljcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEFwcGx5IGdyYXZpdHkgKG9ubHkgYWZmZWN0cyBZIHZlbG9jaXR5KVxuICAgIG1vdmVtZW50LmFwcGx5R3Jhdml0eShkZWx0YVRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGhvcml6b250YWwgbW92ZW1lbnQgZGlyZWN0bHkgZm9yIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIGlmIChtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMCkge1xuICAgICAgLy8gVXNlIGVmZmVjdGl2ZSBtYXggc3BlZWQgd2hpY2ggYWNjb3VudHMgZm9yIGZyb3plbi9zbG93ZWQgc3RhdGVzXG4gICAgICBjb25zdCBlZmZlY3RpdmVNYXhTcGVlZCA9IG1vdmVtZW50LmdldEVmZmVjdGl2ZU1heFNwZWVkKCk7XG4gICAgICBcbiAgICAgIC8vIERpcmVjdCB2ZWxvY2l0eSBzZXR0aW5nIGZvciByZXNwb25zaXZlIG1vdmVtZW50XG4gICAgICBjb25zdCB0YXJnZXRWZWxvY2l0eSA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgIHRhcmdldFZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKGVmZmVjdGl2ZU1heFNwZWVkICogbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIFNldCBob3Jpem9udGFsIHZlbG9jaXR5IGRpcmVjdGx5IChwcmVzZXJ2ZSBZIHZlbG9jaXR5IGZvciBncmF2aXR5L2p1bXBpbmcpXG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS54ID0gdGFyZ2V0VmVsb2NpdHkueDtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnogPSB0YXJnZXRWZWxvY2l0eS56O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBpbnB1dCAtIHN0b3AgaG9yaXpvbnRhbCBtb3ZlbWVudCBpbW1lZGlhdGVseSBmb3IgcmVzcG9uc2l2ZSBjb250cm9sc1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueCA9IDA7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS56ID0gMDtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhbnkgYWRkaXRpb25hbCBmb3JjZXMgKGxpa2Uga25vY2tiYWNrLCB3aW5kLCBldGMuKVxuICAgIG1vdmVtZW50LnZlbG9jaXR5LmFkZChtb3ZlbWVudC5hY2NlbGVyYXRpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpKTtcblxuICAgIC8vIFJlc2V0IGFjY2VsZXJhdGlvbiBmb3IgbmV4dCBmcmFtZVxuICAgIG1vdmVtZW50LmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG5cbiAgICAvLyBTaW1wbGUgZ3JvdW5kIGNoZWNrIChZID0gMCBpcyBncm91bmQgbGV2ZWwsIGFjY291bnQgZm9yIHNwaGVyZSByYWRpdXMpXG4gICAgY29uc3Qgc3BoZXJlUmFkaXVzID0gMC41OyAvLyBQbGF5ZXIgc3BoZXJlIHJhZGl1c1xuICAgIGNvbnN0IGdyb3VuZExldmVsID0gc3BoZXJlUmFkaXVzOyAvLyBTcGhlcmUgY2VudGVyIHNob3VsZCBiZSBhdCByYWRpdXMgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgIFxuICAgIGlmICh0cmFuc2Zvcm0ucG9zaXRpb24ueSA8PSBncm91bmRMZXZlbCAmJiBtb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gZ3JvdW5kTGV2ZWw7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS55ID0gMDtcbiAgICAgIG1vdmVtZW50LmlzR3JvdW5kZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudC5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlBoeXNpY3NTeXN0ZW0iLCJCYXNlUGh5c2ljc1N5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJtb3ZlbWVudCIsImVuYWJsZWQiLCJjYW5Nb3ZlIiwidXBkYXRlRGVidWZmcyIsImNvbnNvbGUiLCJ3YXJuIiwidXBkYXRlTW92ZW1lbnQiLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwiYXBwbHlQaHlzaWNzIiwiZGVsdGFQb3NpdGlvbiIsInZlbG9jaXR5IiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwicG90ZW50aWFsUG9zaXRpb24iLCJhZGQiLCJNQVBfUkFESVVTIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwieCIsInoiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJsZW5ndGgiLCJwaWxsYXJDb2xsaXNpb24iLCJjaGVja1BpbGxhckNvbGxpc2lvbiIsImN1cnJlbnRIb3Jpem9udGFsUG9zIiwidG9DZW50ZXIiLCJub3JtYWxpemUiLCJ0YW5nZW50IiwiaG9yaXpvbnRhbE1vdmVtZW50IiwidGFuZ2VudE1vdmVtZW50IiwiZG90IiwibmV3SG9yaXpvbnRhbFBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJ5IiwiaGFzQ29sbGlzaW9uIiwic2xpZGVQb3NpdGlvbiIsImNhbGN1bGF0ZVBpbGxhclNsaWRpbmciLCJ2ZWxvY2l0eU5vcm1hbENvbXBvbmVudCIsInByb2plY3RPblZlY3RvciIsIm5vcm1hbCIsInN1YiIsInRyYW5zbGF0ZSIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiUElMTEFSX1JBRElVUyIsInNldCIsInBpbGxhckNlbnRlciIsImNvbGxpc2lvbiIsInNsaWRlSG9yaXpvbnRhbCIsImRpc3RhbmNlQWZ0ZXJTbGlkZSIsInB1c2hEaXJlY3Rpb24iLCJjb3JyZWN0ZWRIb3Jpem9udGFsIiwiYXBwbHlHcmF2aXR5IiwiaW5wdXRTdHJlbmd0aCIsImVmZmVjdGl2ZU1heFNwZWVkIiwiZ2V0RWZmZWN0aXZlTWF4U3BlZWQiLCJ0YXJnZXRWZWxvY2l0eSIsIm1vdmVEaXJlY3Rpb24iLCJhY2NlbGVyYXRpb24iLCJzcGhlcmVSYWRpdXMiLCJncm91bmRMZXZlbCIsImlzR3JvdW5kZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        const projectilePos = transform.position;\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                // console.log(` Projectile ${projectileEntity.id} skipping owner ${projectile.owner} (target ${target.id})`);\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 15; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\" Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\" Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 2;\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        projectile.setStartPosition(position);\n        // Set max distance if specified (for bow arrows)\n        if ((config === null || config === void 0 ? void 0 : config.maxDistance) !== undefined) {\n            projectile.setMaxDistance(config.maxDistance);\n        }\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n            console.warn(\" Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        console.log(\"\\uD83E\\uDDF9 Cleaning up ProjectileSystem pools:\", this.getPoolStats());\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FO0FBQytCO0FBQzdEO0FBRWlCO0FBQ0U7QUFDUjtBQUNJO0FBQ2dCO0FBR3JCO0FBTXpDLE1BQU1hLHlCQUF5QlIsK0NBQU1BO0lBOEJuQ1MsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixhQUFhSCxPQUFPRSxZQUFZLENBQUNoQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZSxVQUFVRyxPQUFPLElBQUksQ0FBQ0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM3QztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXUixNQUFNLENBQUNFO1lBRWxCLGtDQUFrQztZQUNsQyxJQUFJTSxXQUFXRSxTQUFTLElBQUk7Z0JBQzFCLElBQUksQ0FBQ1Asb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDeEM7WUFDRjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLGNBQWMsQ0FBQ1AsV0FBV0UsWUFBWU47WUFFM0MsNEVBQTRFO1lBQzVFLG1EQUFtRDtZQUVuRCxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDWSxlQUFlLENBQUNULFFBQVFDLFdBQVdFO1lBRXhDLHlCQUF5QjtZQUN6QixJQUFJLENBQUNPLGdCQUFnQixDQUFDVixRQUFRQztRQUNoQztRQUVBLDhCQUE4QjtRQUM5QixLQUFLLE1BQU1VLFlBQVksSUFBSSxDQUFDYixvQkFBb0IsQ0FBRTtZQUNoRCxJQUFJLENB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QkFBcUI7UUFJekMsMENBQTBDO1FBQzFDLElBQUksQ0FBQ1IsV0FBVyxHQUFHLElBQUlqSSx5REFBVUEsQ0FDL0IsSUFBTSxJQUFJWix5REFBT0EsSUFDakIsQ0FBQ3NKLFNBQVdBLE9BQU9DLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFDN0I7SUFFSjtBQXFpQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUHJvamVjdGlsZVN5c3RlbS50cz8wMGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2plY3RpbGUgc3lzdGVtIGZvciBoYW5kbGluZyBwcm9qZWN0aWxlIG1vdmVtZW50IGFuZCBjb2xsaXNpb25zXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgU3BoZXJlR2VvbWV0cnksIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUHJvamVjdGlsZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuaW1wb3J0IHsgV2VhcG9uU3ViY2xhc3MgfSBmcm9tICdAL2NvbXBvbmVudHMvZHJhZ29uL3dlYXBvbnMnO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuaW1wb3J0IENyb3NzZW50cm9weUJvbHQgZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0Nyb3NzZW50cm9weUJvbHQnO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlsZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBQcm9qZWN0aWxlXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwcm9qZWN0aWxlc1RvRGVzdHJveTogbnVtYmVyW10gPSBbXTtcbiAgXG5cbiAgXG4gIC8vIE9iamVjdCBwb29scyBmb3IgcGVyZm9ybWFuY2UgKGtlZXBpbmcgdmVjdG9yIHBvb2wgZm9yIGNhbGN1bGF0aW9ucylcbiAgcHJpdmF0ZSB2ZWN0b3IzUG9vbDogT2JqZWN0UG9vbDxWZWN0b3IzPjtcbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIG1vdmVtZW50XG4gICAgXG5cbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlY3RvciBwb29sIGZvciBjYWxjdWxhdGlvbnNcbiAgICB0aGlzLnZlY3RvcjNQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiBuZXcgVmVjdG9yMygpLFxuICAgICAgKHZlY3RvcikgPT4gdmVjdG9yLnNldCgwLCAwLCAwKSxcbiAgICAgIDEwMFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29tYmF0U3lzdGVtKGNvbWJhdFN5c3RlbTogQ29tYmF0U3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5jb21iYXRTeXN0ZW0gPSBjb21iYXRTeXN0ZW07XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICAgIGNvbnN0IHByb2plY3RpbGUgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcHJvamVjdGlsZS5lbmFibGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcHJvamVjdGlsZVxuICAgICAgcHJvamVjdGlsZS51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBoYXMgZXhwaXJlZFxuICAgICAgaWYgKHByb2plY3RpbGUuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIHByb2plY3RpbGVcbiAgICAgIHRoaXMubW92ZVByb2plY3RpbGUodHJhbnNmb3JtLCBwcm9qZWN0aWxlLCBkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBBcnJvdyBvcmllbnRhdGlvbiBpcyBzZXQgb25jZSBhdCBjcmVhdGlvbiAtIG5vIG5lZWQgdG8gdXBkYXRlIGV2ZXJ5IGZyYW1lXG4gICAgICAvLyB0aGlzLnVwZGF0ZUFycm93T3JpZW50YXRpb24oZW50aXR5LCBwcm9qZWN0aWxlKTtcblxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xuICAgICAgdGhpcy5jaGVja0NvbGxpc2lvbnMoZW50aXR5LCB0cmFuc2Zvcm0sIHByb2plY3RpbGUpO1xuXG4gICAgICAvLyBDaGVjayB3b3JsZCBib3VuZGFyaWVzXG4gICAgICB0aGlzLmNoZWNrV29ybGRCb3VuZHMoZW50aXR5LCB0cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3kgZXhwaXJlZCBwcm9qZWN0aWxlc1xuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveSkge1xuICAgICAgdGhpcy53b3JsZC5kZXN0cm95RW50aXR5KGVudGl0eUlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1vdmVQcm9qZWN0aWxlKHRyYW5zZm9ybTogVHJhbnNmb3JtLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVzZSB0ZW1wIHZlY3RvciB0byBhdm9pZCBhbGxvY2F0aW9uc1xuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHByb2plY3RpbGUudmVsb2NpdHkpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9uXG4gICAgdHJhbnNmb3JtLnRyYW5zbGF0ZSh0aGlzLnRlbXBWZWN0b3IueCwgdGhpcy50ZW1wVmVjdG9yLnksIHRoaXMudGVtcFZlY3Rvci56KTtcbiAgICB0cmFuc2Zvcm0ubWF0cml4TmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cblxuXG4gIHByaXZhdGUgY2hlY2tDb2xsaXNpb25zKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHByb2plY3RpbGU6IFByb2plY3RpbGUpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9qZWN0aWxlUG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyB0aGF0IGNvdWxkIGJlIGhpdCAtIHNwZWNpZmljYWxseSBsb29rIGZvciBlbmVtaWVzIHdpdGggY29sbGlkZXJzXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG5cbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIHRhcmdldHNcbiAgICBpZiAocG90ZW50aWFsVGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIC8vIFNraXAgc2VsZiBhbmQgb3duZXJcbiAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGVFbnRpdHkuaWQgfHwgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIG93bmVyIGNvbGxpc2lvbiBwcmV2ZW50aW9uXG4gICAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGUub3duZXIpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+aqyBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gc2tpcHBpbmcgb3duZXIgJHtwcm9qZWN0aWxlLm93bmVyfSAodGFyZ2V0ICR7dGFyZ2V0LmlkfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGhpdCBhbmQgbm90IHBpZXJjaW5nXG4gICAgICBpZiAoIXByb2plY3RpbGUuY2FuSGl0VGFyZ2V0KHRhcmdldC5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG4gICAgICBcbiAgICAgIC8vIFNraXAgaWYgdGFyZ2V0IGlzIGRlYWRcbiAgICAgIGlmICh0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGNhbiBoaXQgdGhpcyB0YXJnZXQgKGxheWVyLWJhc2VkIGNvbGxpc2lvbilcbiAgICAgIC8vIEluIFBWUCBtb2RlLCBwcm9qZWN0aWxlcyBjYW4gaGl0IGJvdGggRU5FTVkgKHJlbW90ZSBwbGF5ZXJzKSBhbmQgUExBWUVSIChsb2NhbCBwbGF5ZXIpIGxheWVyc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5FTkVNWSAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRpdGlvbmFsIHNhZmV0eSBjaGVjazogcHJldmVudCBwcm9qZWN0aWxlcyBmcm9tIGhpdHRpbmcgdGhlaXIgb3duZXIgaW4gUFZQIG1vZGVcbiAgICAgIC8vIFRoaXMgaXMgYSBiYWNrdXAgY2hlY2sgaW4gY2FzZSB0aGUgb3duZXIgY29tcGFyaXNvbiBhYm92ZSBmYWlsc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIgJiYgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYPCfmqsgRXh0cmEgc2FmZXR5OiBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gcHJldmVudGVkIGZyb20gaGl0dGluZyBvd25lciAke3Byb2plY3RpbGUub3duZXJ9IChQVlAgbW9kZSlgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRhcmdldFRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG5cbiAgICAgIC8vIFVzZSBjb2xsaWRlciByYWRpdXMgZm9yIG1vcmUgYWNjdXJhdGUgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgY29uc3QgcHJvamVjdGlsZVJhZGl1cyA9IDAuMjsgLy8gSW5jcmVhc2VkIGZyb20gMC4xIGZvciBtb3JlIGZvcmdpdmluZyBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICBjb25zdCB0YXJnZXRSYWRpdXMgPSB0YXJnZXRDb2xsaWRlci5yYWRpdXM7XG5cbiAgICAgIC8vIFVzZSBzcXVhcmVkIGRpc3RhbmNlIGZvciBwZXJmb3JtYW5jZSAoYXZvaWQgc3FydClcbiAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IHByb2plY3RpbGVQb3MuZGlzdGFuY2VUb1NxdWFyZWQodGFyZ2V0UG9zKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblJhZGl1c1NxdWFyZWQgPSAocHJvamVjdGlsZVJhZGl1cyArIHRhcmdldFJhZGl1cykgKiogMjtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8PSBjb2xsaXNpb25SYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSGl0KHByb2plY3RpbGVFbnRpdHksIHRhcmdldCwgcHJvamVjdGlsZSwgdGFyZ2V0SGVhbHRoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vdCBwaWVyY2luZywgZGVzdHJveSBwcm9qZWN0aWxlXG4gICAgICAgIGlmICghcHJvamVjdGlsZS5waWVyY2luZykge1xuICAgICAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChwcm9qZWN0aWxlRW50aXR5LmlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlSGl0KFxuICAgIHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIHByb2plY3RpbGU6IFByb2plY3RpbGUsIFxuICAgIHRhcmdldEhlYWx0aDogSGVhbHRoXG4gICk6IHZvaWQge1xuICAgIC8vIE1hcmsgdGFyZ2V0IGFzIGhpdFxuICAgIHByb2plY3RpbGUuYWRkSGl0VGFyZ2V0KHRhcmdldC5pZCk7XG5cbiAgICAvLyBEZWFsIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZGlyZWN0bHlcbiAgICBpZiAodGhpcy5jb21iYXRTeXN0ZW0pIHtcbiAgICAgIC8vIENoZWNrIHByb2plY3RpbGUgdHlwZSBmb3Igc3BlY2lhbCBkYW1hZ2UgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgY29uc3QgaXNDcm9zc2VudHJvcHlCb2x0ID0gcmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5pc0Nyb3NzZW50cm9weUJvbHQ7XG4gICAgICBjb25zdCBpc0VudHJvcGljQm9sdCA9IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNFbnRyb3BpY0JvbHQ7XG4gICAgICBcbiAgICAgIGxldCBkYW1hZ2VUeXBlID0gJ3Byb2plY3RpbGUnO1xuICAgICAgaWYgKGlzQ3Jvc3NlbnRyb3B5Qm9sdCkge1xuICAgICAgICBkYW1hZ2VUeXBlID0gJ2Nyb3NzZW50cm9weSc7XG4gICAgICB9IGVsc2UgaWYgKGlzRW50cm9waWNCb2x0KSB7XG4gICAgICAgIGRhbWFnZVR5cGUgPSAnZW50cm9waWMnO1xuICAgICAgfVxuICAgICAgXG5cbiAgICAgIFxuICAgICAgdGhpcy5jb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBwcm9qZWN0aWxlLmRhbWFnZSwgcHJvamVjdGlsZUVudGl0eSwgZGFtYWdlVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCBkYW1hZ2UgKHBhc3MgZW50aXR5IGZvciBzaGllbGQgYWJzb3JwdGlvbilcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKHByb2plY3RpbGUuZGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICAgIFxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBleHBsb3Npb24gaWYgZXhwbG9zaXZlXG4gICAgaWYgKHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzID4gMCkge1xuICAgICAgdGhpcy5oYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eSwgcHJvamVjdGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eTogRW50aXR5LCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVRyYW5zZm9ybSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IGV4cGxvc2lvbkNlbnRlciA9IHByb2plY3RpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBFbWl0IGV4cGxvc2lvbiBldmVudCBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICB0aGlzLndvcmxkLmVtaXRFdmVudCgnZXhwbG9zaW9uJywge1xuICAgICAgcG9zaXRpb246IGV4cGxvc2lvbkNlbnRlci5jbG9uZSgpLFxuICAgICAgY29sb3I6IG5ldyBDb2xvcignIzAwZmY0NCcpLFxuICAgICAgc2l6ZTogcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMsXG4gICAgICBkdXJhdGlvbjogMC41XG4gICAgfSk7XG5cbiAgICAvLyBGaW5kIGFsbCBlbnRpdGllcyB3aXRoaW4gZXhwbG9zaW9uIHJhZGl1c1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoXSk7XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSBjb250aW51ZTsgLy8gRG9uJ3QgZGFtYWdlIG93bmVyXG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBleHBsb3Npb25DZW50ZXIuZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRhbWFnZSBmYWxsb2ZmIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IGRhbWFnZUZhbGxvZmYgPSAxIC0gKGRpc3RhbmNlIC8gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpO1xuICAgICAgICBjb25zdCBleHBsb3Npb25EYW1hZ2UgPSBNYXRoLmZsb29yKHByb2plY3RpbGUuZGFtYWdlICogZGFtYWdlRmFsbG9mZik7XG5cbiAgICAgICAgaWYgKGV4cGxvc2lvbkRhbWFnZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgIHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKGV4cGxvc2lvbkRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrV29ybGRCb3VuZHMoZW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgcG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IG1heERpc3RhbmNlID0gNDA7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW5cbiAgICBjb25zdCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBtYXhEaXN0YW5jZSAqIG1heERpc3RhbmNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyB0b28gZmFyIGZyb20gb3JpZ2luICh1c2luZyBzcXVhcmVkIGRpc3RhbmNlKVxuICAgIGlmIChwb3MubGVuZ3RoU3EoKSA+IG1heERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICByZXR1cm47IC8vIEVhcmx5IGV4aXRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGlzIGJlbG93IGdyb3VuZCAoc2ltcGxlIGdyb3VuZCBjaGVjaylcbiAgICBpZiAocG9zLnkgPCAtMTApIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENoYXJnZWRBcnJvdyBwcm9qZWN0aWxlIGZvciBmdWxseSBjaGFyZ2VkIGJvd1xuICBwdWJsaWMgY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBjaGFyZ2VkIGFycm93LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAzNTsgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDI1OyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCA1OyAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBDaGFyZ2VkQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDaGFyZ2VkQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNDaGFyZ2VkQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIFxuICAgIHJlbmRlcmVyLm1lc2ggPSBwbGFjZWhvbGRlck1lc2g7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG5cbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlXG4gIHB1YmxpYyBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBzY3l0aGUtc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDE1OyAvLyBTbG93ZXIgdGhhbiBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDMwOyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgMS43NTsgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIGNvbnN0IHJlbmRlcmVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgcGxhY2Vob2xkZXIgbWVzaCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIFJlYWN0IGNvbXBvbmVudFxuICAgIGNvbnN0IHBsYWNlaG9sZGVyR2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoMC4yOCwgOCwgOCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogJyMwMGZmNDQnLFxuICAgICAgZW1pc3NpdmU6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDcm9zc2VudHJvcHlCb2x0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlIGxlZnQgY2xpY2tcbiAgcHVibGljIGNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggRW50cm9waWNCb2x0LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgMjA7IC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fDEuNzU7IC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBFbnRyb3BpY0JvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDYsIDYpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMCxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMCAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGFuIEVudHJvcGljQm9sdCBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc0VudHJvcGljQm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG5cbiAgICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IHRoZSBlbnRpdHkgaXMgcmVhZHlcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgcHJvamVjdGlsZVxuICBwdWJsaWMgY3JlYXRlUHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgICBtYXhEaXN0YW5jZT86IG51bWJlcjtcbiAgICB9XG4gICk6IEVudGl0eSB7XG4gICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHdvcmxkLmNyZWF0ZUVudGl0eSgpO1xuXG4gICAgLy8gQWRkIFRyYW5zZm9ybSBjb21wb25lbnRcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBQcm9qZWN0aWxlIGNvbXBvbmVudFxuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMjA7XG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCA1OyAvLyBTZXQgZGVmYXVsdCBkYW1hZ2UgdG8gNSBhcyByZXF1ZXN0ZWRcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCAyO1xuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgcHJvamVjdGlsZS5zZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBTZXQgbWF4IGRpc3RhbmNlIGlmIHNwZWNpZmllZCAoZm9yIGJvdyBhcnJvd3MpXG4gICAgaWYgKGNvbmZpZz8ubWF4RGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvamVjdGlsZS5zZXRNYXhEaXN0YW5jZShjb25maWcubWF4RGlzdGFuY2UpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgUmVndWxhckFycm93XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA4LCA4KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZTogJyNmZmFhMDAnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDMsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuMSAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgUmVndWxhckFycm93IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnN1YmNsYXNzID0gY29uZmlnPy5zdWJjbGFzcztcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEubGV2ZWwgPSBjb25maWc/LmxldmVsO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5vcGFjaXR5ID0gY29uZmlnPy5vcGFjaXR5IHx8IDEuMDtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7IC8vIFByb2plY3RpbGVzIGRvbid0IG5lZWQgdG8gY2FzdCBzaGFkb3dzXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5ICh0aGlzIHdpbGwgdHJpZ2dlciBSZW5kZXJTeXN0ZW0ub25FbnRpdHlBZGRlZClcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cblxuXG4gIC8vIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UG9vbFN0YXRzKCk6IHsgXG4gICAgdmVjdG9yMzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVjdG9yMzogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIERpc3Bvc2Ugb2YgYWxsIHBvb2xzIHdoZW4gc3lzdGVtIGlzIGRlc3Ryb3llZFxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFuaW5nIHVwIFByb2plY3RpbGVTeXN0ZW0gcG9vbHM6JywgdGhpcy5nZXRQb29sU3RhdHMoKSk7XG4gICAgdGhpcy52ZWN0b3IzUG9vbC5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbG9yIiwiU3BoZXJlR2VvbWV0cnkiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIk1lc2giLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJQcm9qZWN0aWxlIiwiSGVhbHRoIiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbGxpc2lvbkxheWVyIiwiT2JqZWN0UG9vbCIsIlByb2plY3RpbGVTeXN0ZW0iLCJzZXRDb21iYXRTeXN0ZW0iLCJjb21iYXRTeXN0ZW0iLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsInByb2plY3RpbGVzVG9EZXN0cm95IiwibGVuZ3RoIiwiZW50aXR5IiwidHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwicHJvamVjdGlsZSIsImVuYWJsZWQiLCJpc0V4cGlyZWQiLCJwdXNoIiwiaWQiLCJtb3ZlUHJvamVjdGlsZSIsImNoZWNrQ29sbGlzaW9ucyIsImNoZWNrV29ybGRCb3VuZHMiLCJlbnRpdHlJZCIsIndvcmxkIiwiZGVzdHJveUVudGl0eSIsInRlbXBWZWN0b3IiLCJjb3B5IiwidmVsb2NpdHkiLCJtdWx0aXBseVNjYWxhciIsInRyYW5zbGF0ZSIsIngiLCJ5IiwieiIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicHJvamVjdGlsZUVudGl0eSIsInByb2plY3RpbGVQb3MiLCJwb3NpdGlvbiIsInBvdGVudGlhbFRhcmdldHMiLCJxdWVyeUVudGl0aWVzIiwidGFyZ2V0Iiwib3duZXIiLCJjYW5IaXRUYXJnZXQiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJ0YXJnZXRIZWFsdGgiLCJ0YXJnZXRDb2xsaWRlciIsImlzRGVhZCIsImxheWVyIiwiRU5FTVkiLCJQTEFZRVIiLCJ0YXJnZXRQb3MiLCJnZXRXb3JsZFBvc2l0aW9uIiwicHJvamVjdGlsZVJhZGl1cyIsInRhcmdldFJhZGl1cyIsInJhZGl1cyIsImRpc3RhbmNlU3F1YXJlZCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiY29sbGlzaW9uUmFkaXVzU3F1YXJlZCIsImhhbmRsZUhpdCIsInBpZXJjaW5nIiwiYWRkSGl0VGFyZ2V0IiwicmVuZGVyZXIiLCJpc0Nyb3NzZW50cm9weUJvbHQiLCJtZXNoIiwidXNlckRhdGEiLCJpc0VudHJvcGljQm9sdCIsImRhbWFnZVR5cGUiLCJxdWV1ZURhbWFnZSIsImRhbWFnZSIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsImV4cGxvc2lvblJhZGl1cyIsImhhbmRsZUV4cGxvc2lvbiIsInByb2plY3RpbGVUcmFuc2Zvcm0iLCJleHBsb3Npb25DZW50ZXIiLCJlbWl0RXZlbnQiLCJjbG9uZSIsImNvbG9yIiwic2l6ZSIsImR1cmF0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZGFtYWdlRmFsbG9mZiIsImV4cGxvc2lvbkRhbWFnZSIsIk1hdGgiLCJmbG9vciIsInBvcyIsIm1heERpc3RhbmNlIiwibWF4RGlzdGFuY2VTcXVhcmVkIiwibGVuZ3RoU3EiLCJjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlIiwiZGlyZWN0aW9uIiwib3duZXJJZCIsImNvbmZpZyIsImNyZWF0ZUVudGl0eSIsImNyZWF0ZUNvbXBvbmVudCIsImFkZENvbXBvbmVudCIsInNwZWVkIiwibWF4TGlmZXRpbWUiLCJsaWZldGltZSIsInNldERpcmVjdGlvbiIsInNldFBpZXJjaW5nIiwiZXhwbG9zaXZlIiwic2V0RXhwbG9zaXZlIiwicGxhY2Vob2xkZXJHZW9tZXRyeSIsInBsYWNlaG9sZGVyTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwicGxhY2Vob2xkZXJNZXNoIiwiaXNDaGFyZ2VkQXJyb3ciLCJzdWJjbGFzcyIsImxldmVsIiwiY29sbGlkZXIiLCJQUk9KRUNUSUxFIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJzZXRDYXN0U2hhZG93IiwiY29uc29sZSIsIndhcm4iLCJub3RpZnlFbnRpdHlBZGRlZCIsImNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJjcmVhdGVQcm9qZWN0aWxlIiwic2V0U3RhcnRQb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldE1heERpc3RhbmNlIiwiaXNSZWd1bGFyQXJyb3ciLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImxvZyIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n                console.warn(\" Renderer component missing updateAnimations method:\", rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n                console.warn(\" Renderer component missing updateMesh method:\", rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            console.log(\"\\uD83C\\uDFA8 RenderSystem: Adding entity \".concat(entity.id, \" to scene\"));\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                console.log(\"\\uD83C\\uDFF9 Adding pre-built mesh/group for entity \".concat(entity.id));\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                console.log(\"\\uD83D\\uDD37 Creating mesh from geometry + material for entity \".concat(entity.id));\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n                console.log(\" Entity \".concat(entity.id, \" has Renderer but no geometry/material - skipping mesh creation\"));\n            }\n        } else {\n            console.log(\" RenderSystem: Entity \".concat(entity.id, \" has no Renderer component\"));\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87Z0JBQ0xPLFFBQVFDLElBQUksQ0FBQywwREFBMERKO1lBQ3pFO1lBRUEsd0JBQXdCO1lBQ3hCLElBQUksQ0FBQ0ssZ0JBQWdCLENBQUNSLFFBQVFDLFdBQVdFO1FBQzNDO0lBQ0Y7SUFFT00sT0FBT1gsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLG9CQUFvQkgsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFdEQsSUFBSSxDQUFDSyxVQUFVRyxPQUFPLElBQUksQ0FBQ0Qsa0JBQWtCQyxPQUFPLEVBQUU7Z0JBQ3BEO1lBQ0Y7WUFFQSxJQUFJLENBQUNNLHFCQUFxQixDQUFDVixRQUFRQyxXQUFXRTtRQUNoRDtRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNRLFFBQVEsQ0FBQ0Ys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QUNILE9BQU8sQ0FBQ3dELEtBQUs7UUFFbEIsbUJBQW1CO1FBQ25CLElBQUksQ0FBQzVELFFBQVEsQ0FBQzRCLE9BQU87SUFDdkI7SUExTUFpQyxZQUFZNUQsS0FBWSxFQUFFQyxNQUFjLEVBQUVGLFFBQXVCLENBQUU7UUFDakUsS0FBSzthQVBTOEQscUJBQXFCO1lBQUM5RSxnRUFBU0E7WUFBRUMsOERBQVFBO1NBQUM7YUFJbERtQixVQUFVLElBQUkyRCxNQUE2QixrQ0FBa0M7O1FBSW5GLElBQUksQ0FBQzlELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDZ0UsUUFBUSxHQUFHLE1BQU0saUNBQWlDO0lBQ3pEO0FBcU1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cz9iMzA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlciBzeXN0ZW0gZm9yIDNEIHJlbmRlcmluZyB3aXRoIFRocmVlLmpzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBXZWJHTFJlbmRlcmVyLCBNZXNoLCBHcm91cCwgTGlnaHQsIE9iamVjdDNELCBDb2xvciwgVGV4dHVyZSwgUENGU29mdFNoYWRvd01hcCwgUGVyc3BlY3RpdmVDYW1lcmEsIEZvZywgRm9nRXhwMiwgQ3ViZVRleHR1cmUgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUmVuZGVyU3lzdGVtIGFzIEJhc2VSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJTeXN0ZW0gZXh0ZW5kcyBCYXNlUmVuZGVyU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFJlbmRlcmVyXTtcbiAgcHJpdmF0ZSBzY2VuZTogU2NlbmU7XG4gIHByaXZhdGUgY2FtZXJhOiBDYW1lcmE7XG4gIHByaXZhdGUgcmVuZGVyZXI6IFdlYkdMUmVuZGVyZXI7XG4gIHByaXZhdGUgbWVzaE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBNZXNoIHwgR3JvdXA+KCk7IC8vIEVudGl0eSBJRCAtPiBNZXNoL0dyb3VwIG1hcHBpbmdcblxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIGNhbWVyYTogQ2FtZXJhLCByZW5kZXJlcjogV2ViR0xSZW5kZXJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwMDsgLy8gUmVuZGVyIHN5c3RlbXMgc2hvdWxkIHJ1biBsYXN0XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgYW5pbWF0aW9ucyBhbmQgcmVuZGVyZXIgY29tcG9uZW50c1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUFuaW1hdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyhkZWx0YVRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlQW5pbWF0aW9ucyBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbWVzaCBpZiBuZWVkZWRcbiAgICAgIHRoaXMudXBkYXRlRW50aXR5TWVzaChlbnRpdHksIHRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbGwgZW50aXR5IHRyYW5zZm9ybXMgYW5kIG1lc2hlc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5TWVzaChlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nTWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcblxuICAgIC8vIEhhbmRsZSBwcmUtYnVpbHQgbWVzaC9ncm91cCAobGlrZSBhcnJvd3MpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQubWVzaCkge1xuICAgICAgdGhpcy5tZXNoTWFwLnNldChlbnRpdHkuaWQsIHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG1lc2ggaWYgaXQgZG9lc24ndCBleGlzdCBvciBuZWVkcyB1cGRhdGUgKHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWwpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IG1lc2ggPSByZW5kZXJlckNvbXBvbmVudC5jcmVhdGVNZXNoKCk7XG4gICAgICBpZiAobWVzaCkge1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG1lc2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdNZXNoKSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgbWVzaCB3aXRoIHNhZmV0eSBjaGVja1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC51cGRhdGVNZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHVwZGF0ZU1lc2ggbWV0aG9kOicsIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUVudGl0eVRyYW5zZm9ybShlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IG1lc2hPckdyb3VwID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuICAgIGlmICghbWVzaE9yR3JvdXApIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgdHJhbnNmb3JtLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtIHRvIG1lc2ggb3IgZ3JvdXBcbiAgICBtZXNoT3JHcm91cC5wb3NpdGlvbi5jb3B5KHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgbWVzaE9yR3JvdXAucXVhdGVybmlvbi5jb3B5KHRyYW5zZm9ybS5xdWF0ZXJuaW9uKTtcbiAgICBtZXNoT3JHcm91cC5zY2FsZS5jb3B5KHRyYW5zZm9ybS5zY2FsZSk7XG5cbiAgICAvLyBIYW5kbGUgaW5zdGFuY2VkIHJlbmRlcmluZyAob25seSBmb3IgbWVzaGVzKVxuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5pc0luc3RhbmNlZCAmJiBtZXNoT3JHcm91cCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUluc3RhbmNlTWF0cml4KHRyYW5zZm9ybS5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIFJlbmRlclN5c3RlbTogQWRkaW5nIGVudGl0eSAke2VudGl0eS5pZH0gdG8gc2NlbmVgKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cyBhbmQgZWxpdGUgZW5lbWllcylcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn4+5IEFkZGluZyBwcmUtYnVpbHQgbWVzaC9ncm91cCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0cmFkaXRpb25hbCBnZW9tZXRyeSArIG1hdGVyaWFsXG4gICAgICBpZiAocmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflLcgQ3JlYXRpbmcgbWVzaCBmcm9tIGdlb21ldHJ5ICsgbWF0ZXJpYWwgZm9yIGVudGl0eSAke2VudGl0eS5pZH1gKTtcbiAgICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgICAgaWYgKG1lc2gpIHtcbiAgICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgUmVuZGVyZXIgYnV0IG5vIGdlb21ldHJ5L21hdGVyaWFsIC0gc2tpcHBpbmcgbWVzaCBjcmVhdGlvbmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFJlbmRlclN5c3RlbTogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgbm8gUmVuZGVyZXIgY29tcG9uZW50YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IG1lc2ggPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKG1lc2gpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgICAgdGhpcy5tZXNoTWFwLmRlbGV0ZShlbnRpdHkuaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyQ29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcik7XG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50ICYmIHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1lc2goZW50aXR5SWQ6IG51bWJlcik6IE1lc2ggfCBHcm91cCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubWVzaE1hcC5nZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGdldFNjZW5lKCk6IFNjZW5lIHtcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogQ2FtZXJhIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmE7XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVuZGVyZXIoKTogV2ViR0xSZW5kZXJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG1hbmFnaW5nIHRoZSBzY2VuZVxuICBwdWJsaWMgYWRkTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUxpZ2h0KGxpZ2h0OiBMaWdodCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKGxpZ2h0KTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlT2JqZWN0KG9iamVjdDogT2JqZWN0M0QpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLnJlbW92ZShvYmplY3QpO1xuICB9XG5cbiAgcHVibGljIHNldEZvZyhmb2c6IEZvZyB8IEZvZ0V4cDIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5mb2cgPSBmb2c7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFja2dyb3VuZChiYWNrZ3JvdW5kOiBDb2xvciB8IFRleHR1cmUgfCBDdWJlVGV4dHVyZSB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVNoYWRvd3MoZW5hYmxlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBlbmFibGU7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFBDRlNvZnRTaGFkb3dNYXA7XG4gIH1cblxuICBwdWJsaWMgc2V0UGl4ZWxSYXRpbyhyYXRpbz86IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhyYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIH1cblxuICBwdWJsaWMgc2V0U2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICBpZiAodGhpcy5jYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIG1lc2hlc1xuICAgIGZvciAoY29uc3QgW2VudGl0eUlkLCBtZXNoXSBvZiBBcnJheS5mcm9tKHRoaXMubWVzaE1hcC5lbnRyaWVzKCkpKSB7XG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZShtZXNoKTtcbiAgICB9XG4gICAgdGhpcy5tZXNoTWFwLmNsZWFyKCk7XG5cbiAgICAvLyBEaXNwb3NlIHJlbmRlcmVyXG4gICAgdGhpcy5yZW5kZXJlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJNZXNoIiwiUENGU29mdFNoYWRvd01hcCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiUmVuZGVyU3lzdGVtIiwiQmFzZVJlbmRlclN5c3RlbSIsIlRyYW5zZm9ybSIsIlJlbmRlcmVyIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJyZW5kZXJlckNvbXBvbmVudCIsImVuYWJsZWQiLCJ1cGRhdGVBbmltYXRpb25zIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwibG9nIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider\n        ]);\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            return false;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    return shouldTarget;\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate direction to target\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(towerTransform.position);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Normalize direction\n        this.tempVector.normalize();\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 2,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (projectileRenderer) {\n                // Add metadata to identify this as a tower projectile\n                projectileEntity.isTowerProjectile = true;\n                projectileEntity.towerOwnerId = tower.ownerId;\n            }\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0U7QUFDbEI7QUFDVjtBQUVpQjtBQUNOO0FBQ0Y7QUFDc0I7QUFJOUQsTUFBTU8sb0JBQW9CTiwrQ0FBTUE7SUFzQjlCTyxvQkFBb0JDLGdCQUFrQyxFQUFRO1FBQ25FLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBO0lBQzFCO0lBRU9DLHVCQUF1QkMsUUFBdUcsRUFBUTtRQUMzSSxJQUFJLENBQUNDLHFCQUFxQixHQUFHRDtJQUMvQjtJQUVPRSxpQkFBaUJDLG9CQUF5QyxFQUFFQyxhQUFxQixFQUFRO1FBQzlGLElBQUksQ0FBQ0Qsb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUN2QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsS0FBSyxNQUFNLHFCQUFxQjtRQUU1RCxLQUFLLE1BQU1DLFVBQVVMLFNBQVU7WUFDN0IsTUFBTU0sWUFBWUQsT0FBT0UsWUFBWSxDQUFDdEIsZ0VBQVNBO1lBQy9DLE1BQU11QixRQUFRSCxPQUFPRSxZQUFZLENBQUNwQix3REFBS0E7WUFDdkMsTUFBTXNCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQ3JCLDBEQUFNQTtZQUV6QyxJQUFJLENBQUNvQixhQUFhLENBQUNFLFNBQVMsQ0FBQ0MsUUFBUTtZQUVyQyx5QkFBeUI7WUFDekIsSUFBSUEsT0FBT0MsTUFBTSxJQUFJLENBQUNGLE1BQU1FLE1BQU0sRUFBRTtnQkFDbENGLE1BQU1HLEdBQUcsQ0FBQ1Q7Z0JBQ1Y7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixJQUFJLENBQUNNLE1BQU1JLFFBQVEsSUFBSUosTUFBTUUsTUFBTSxFQUFFO1lBRXJDLGtDQUFrQztZQUNsQyxJQUFJRixNQUFNSyxtQkFBbUIsQ0FBQ1gsY0FBYztnQkFDMUMsSUFBSSxD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QUN4REssdUJBQTRDLElBQUl1RjthQUNoRHRGLGdCQUErQjtRQUV2Qyx5Q0FBeUM7YUFDakN3RCxhQUFhLElBQUl2RSx5REFBT0E7YUFDeEI2RSxjQUFjLElBQUk3RSx5REFBT0E7UUFJL0IsSUFBSSxDQUFDa0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ29FLFFBQVEsR0FBRyxJQUFJLHFDQUFxQztJQUMzRDtBQW1QRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Ub3dlclN5c3RlbS50cz82YjIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIHN5c3RlbSBmb3IgbWFuYWdpbmcgUFZQIHRvd2VyIEFJLCB0YXJnZXRpbmcsIGFuZCBzaG9vdGluZ1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFRvd2VyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Ub3dlcic7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlclN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJyb2FkY2FzdGluZyB0b3dlciBhdHRhY2tzIGluIG11bHRpcGxheWVyXG4gIHByaXZhdGUgb25Ub3dlckF0dGFja0NhbGxiYWNrPzogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gUGxheWVyIGVudGl0eSBtYXBwaW5nIGZvciBpZGVudGlmeWluZyB0b3dlciBvd25lcnMgdnMgZW5lbWllc1xuICBwcml2YXRlIHNlcnZlclBsYXllckVudGl0aWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGxvY2FsU29ja2V0SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnQgYW5kIHByb2plY3RpbGVzXG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlU3lzdGVtKHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VG93ZXJBdHRhY2tDYWxsYmFjayhjYWxsYmFjazogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFBsYXllck1hcHBpbmcoc2VydmVyUGxheWVyRW50aXRpZXM6IE1hcDxzdHJpbmcsIG51bWJlcj4sIGxvY2FsU29ja2V0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMgPSBzZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICB0aGlzLmxvY2FsU29ja2V0SWQgPSBsb2NhbFNvY2tldElkO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICF0b3dlciB8fCAhaGVhbHRoKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdG93ZXIgaXMgZGVhZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQgJiYgIXRvd2VyLmlzRGVhZCkge1xuICAgICAgICB0b3dlci5kaWUoY3VycmVudFRpbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHRvd2Vyc1xuICAgICAgaWYgKCF0b3dlci5pc0FjdGl2ZSB8fCB0b3dlci5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBTZWFyY2ggZm9yIHRhcmdldHMgcGVyaW9kaWNhbGx5XG4gICAgICBpZiAodG93ZXIuY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGb3JUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGN1cnJlbnQgdGFyZ2V0IChjaGVjayBpZiBzdGlsbCBhbGl2ZSBhbmQgaW4gcmFuZ2UpXG4gICAgICBpZiAodG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eSh0b3dlci5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYXJnZXQodGFyZ2V0RW50aXR5IHx8IG51bGwsIHRyYW5zZm9ybSwgdG93ZXIpKSB7XG4gICAgICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdHRhY2sgY3VycmVudCB0YXJnZXQgaWYgcG9zc2libGVcbiAgICAgIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0ICYmIHRvd2VyLmNhbkF0dGFjayhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHNlYXJjaEZvclRhcmdldCh0b3dlckVudGl0eTogRW50aXR5LCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0b3dlci51cGRhdGVUYXJnZXRTZWFyY2goY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIEdldCBhbGwgcG90ZW50aWFsIHRhcmdldHMgKHBsYXllcnMgdGhhdCBhcmUgbm90IHRoZSB0b3dlciBvd25lcilcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBcbiAgICBcbiAgICBsZXQgY2xvc2VzdFRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCB2YWxpZFRhcmdldENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIgJiYgdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhcmdldCh0YXJnZXQsIHRvd2VyVHJhbnNmb3JtLCB0b3dlcikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICB2YWxpZFRhcmdldENvdW50Kys7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0yID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0yKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybTIucG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdG93ZXIudGFyZ2V0U2VhcmNoUmFuZ2UgJiYgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGlmIChjbG9zZXN0VGFyZ2V0KSB7XG4gICAgICB0b3dlci5zZXRUYXJnZXQoY2xvc2VzdFRhcmdldC5pZCk7XG4gICAgfSBlbHNlIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhciB0YXJnZXQgaWYgbm8gdmFsaWQgdGFyZ2V0cyBmb3VuZFxuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgaXNWYWxpZFRhcmdldCh0YXJnZXQ6IEVudGl0eSB8IG51bGwsIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBcbiAgICAvLyBNdXN0IGhhdmUgcmVxdWlyZWQgY29tcG9uZW50cyBhbmQgYmUgYWxpdmVcbiAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8ICF0YXJnZXRDb2xsaWRlciB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIE11c3QgYmUgYSBwbGF5ZXIgKG5vdCBhbiBlbmVteSBvciBvdGhlciB0b3dlcilcbiAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUiAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdGFyZ2V0IG90aGVyIHRvd2Vyc1xuICAgIGlmICh0YXJnZXQuaGFzQ29tcG9uZW50KFRvd2VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbiBQVlAgbW9kZSwgaWRlbnRpZnkgaWYgdGhpcyBpcyBhbiBlbmVteSBwbGF5ZXJcbiAgICBpZiAodGhpcy5sb2NhbFNvY2tldElkICYmIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMuc2l6ZSA+IDApIHtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgbG9jYWwgcGxheWVyIChQTEFZRVIgbGF5ZXIpXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLlBMQVlFUikge1xuICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0aGlzLmxvY2FsU29ja2V0SWQ7XG4gICAgICAgIHJldHVybiBzaG91bGRUYXJnZXQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSByZW1vdGUgcGxheWVyIChFTkVNWSBsYXllcilcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgICAgLy8gRmluZCB3aGljaCBwbGF5ZXIgdGhpcyBlbnRpdHkgYmVsb25ncyB0b1xuICAgICAgICBsZXQgdGFyZ2V0UGxheWVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzLmZvckVhY2goKGVudGl0eUlkLCBwbGF5ZXJJZCkgPT4ge1xuICAgICAgICAgIGlmIChlbnRpdHlJZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICB0YXJnZXRQbGF5ZXJJZCA9IHBsYXllcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0YXJnZXRQbGF5ZXJJZDtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHByaXZhdGUgYXR0YWNrVGFyZ2V0KHRvd2VyRW50aXR5OiBFbnRpdHksIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQhKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgdGhpcy50ZW1wVmVjdG9yLnN1Yih0b3dlclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHN0aWxsIGluIHJhbmdlXG4gICAgaWYgKGRpc3RhbmNlID4gdG93ZXIuYXR0YWNrUmFuZ2UpIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb25cbiAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gKHNsaWdodGx5IGFib3ZlIHRvd2VyIGNlbnRlcilcbiAgICB0aGlzLnRlbXBWZWN0b3IyLmNvcHkodG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3RvcjIueSArPSAyOyAvLyBTcGF3biBwcm9qZWN0aWxlcyAyIHVuaXRzIGFib3ZlIHRvd2VyIGJhc2VcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLnByb2plY3RpbGVTeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiB0b3dlci5wcm9qZWN0aWxlU3BlZWQsXG4gICAgICAgIGRhbWFnZTogdG93ZXIuYXR0YWNrRGFtYWdlLFxuICAgICAgICBsaWZldGltZTogMiwgLy8gNSBzZWNvbmQgbGlmZXRpbWVcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHRoaXMudGVtcFZlY3RvcjIsIC8vIHNwYXduIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudGVtcFZlY3RvciwgIC8vIGRpcmVjdGlvblxuICAgICAgICB0b3dlckVudGl0eS5pZCwgICAvLyB0b3dlciBhcyBvd25lclxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIHByb2plY3RpbGUgYXMgdG93ZXIgcHJvamVjdGlsZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgY29uc3QgcHJvamVjdGlsZVJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmIChwcm9qZWN0aWxlUmVuZGVyZXIpIHtcbiAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIGlkZW50aWZ5IHRoaXMgYXMgYSB0b3dlciBwcm9qZWN0aWxlXG4gICAgICAgIChwcm9qZWN0aWxlRW50aXR5IGFzIGFueSkuaXNUb3dlclByb2plY3RpbGUgPSB0cnVlO1xuICAgICAgICAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLnRvd2VyT3duZXJJZCA9IHRvd2VyLm93bmVySWQ7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IGF0dGFjayB0byBtdWx0aXBsYXllciBpZiBjYWxsYmFjayBpcyBzZXRcbiAgICBpZiAodGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFwIHRoZSB0YXJnZXQgZW50aXR5IGJhY2sgdG8gYSBwbGF5ZXIgSURcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHVzZSBhIHBsYWNlaG9sZGVyIC0gdGhpcyB3aWxsIG5lZWQgdG8gYmUgaW1wcm92ZWQgd2l0aCBwcm9wZXIgcGxheWVyIG1hcHBpbmdcbiAgICAgIGNvbnN0IHRhcmdldFBsYXllcklkID0gYHBsYXllcl8ke3Rvd2VyLmN1cnJlbnRUYXJnZXR9YDtcbiAgICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrKHRvd2VyLm93bmVySWQsIHRhcmdldFBsYXllcklkLCB0aGlzLnRlbXBWZWN0b3IyLCB0aGlzLnRlbXBWZWN0b3IpO1xuICAgIH1cbiAgICBcbiAgICB0b3dlci5wZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lKTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IGFsbCB0b3dlcnMgb3duZWQgYnkgYSBzcGVjaWZpYyBwbGF5ZXJcbiAgcHVibGljIGdldFRvd2Vyc0J5T3duZXIob3duZXJJZDogc3RyaW5nKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGFsbFRvd2VycyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXSk7XG4gICAgcmV0dXJuIGFsbFRvd2Vycy5maWx0ZXIoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICByZXR1cm4gdG93ZXIgJiYgdG93ZXIub3duZXJJZCA9PT0gb3duZXJJZDtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IHRvd2VyIGNvdW50IGZvciBhIHBsYXllclxuICBwdWJsaWMgZ2V0VG93ZXJDb3VudChvd25lcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCkubGVuZ3RoO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjaGVjayBpZiBhIHBsYXllciBoYXMgYW55IGFjdGl2ZSB0b3dlcnNcbiAgcHVibGljIGhhc0FjdGl2ZVRvd2Vycyhvd25lcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCk7XG4gICAgcmV0dXJuIHRvd2Vycy5zb21lKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgcmV0dXJuIHRvd2VyICYmIGhlYWx0aCAmJiB0b3dlci5pc0FjdGl2ZSAmJiAhdG93ZXIuaXNEZWFkICYmICFoZWFsdGguaXNEZWFkO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkhlYWx0aCIsIlRvd2VyIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlRvd2VyU3lzdGVtIiwic2V0UHJvamVjdGlsZVN5c3RlbSIsInByb2plY3RpbGVTeXN0ZW0iLCJzZXRUb3dlckF0dGFja0NhbGxiYWNrIiwiY2FsbGJhY2siLCJvblRvd2VyQXR0YWNrQ2FsbGJhY2siLCJzZXRQbGF5ZXJNYXBwaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJsb2NhbFNvY2tldElkIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ0b3dlciIsImhlYWx0aCIsImlzRGVhZCIsImRpZSIsImlzQWN0aXZlIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsInNlYXJjaEZvclRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRFbnRpdHkiLCJ3b3JsZCIsImdldEVudGl0eSIsImlzVmFsaWRUYXJnZXQiLCJjbGVhclRhcmdldCIsImNhbkF0dGFjayIsImF0dGFja1RhcmdldCIsInRvd2VyRW50aXR5IiwidG93ZXJUcmFuc2Zvcm0iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsImNsb3Nlc3RUYXJnZXQiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInZhbGlkVGFyZ2V0Q291bnQiLCJ0YXJnZXQiLCJ0YXJnZXRDb2xsaWRlciIsInRhcmdldFRyYW5zZm9ybSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwidGFyZ2V0VHJhbnNmb3JtMiIsInRhcmdldFNlYXJjaFJhbmdlIiwic2V0VGFyZ2V0IiwiaWQiLCJ0YXJnZXRIZWFsdGgiLCJsYXllciIsIlBMQVlFUiIsIkVORU1ZIiwiaGFzQ29tcG9uZW50Iiwic2l6ZSIsInNob3VsZFRhcmdldCIsIm93bmVySWQiLCJ0YXJnZXRQbGF5ZXJJZCIsImZvckVhY2giLCJlbnRpdHlJZCIsInBsYXllcklkIiwidGVtcFZlY3RvciIsImNvcHkiLCJzdWIiLCJsZW5ndGgiLCJhdHRhY2tSYW5nZSIsIm5vcm1hbGl6ZSIsInRlbXBWZWN0b3IyIiwieSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsInByb2plY3RpbGVTcGVlZCIsImRhbWFnZSIsImF0dGFja0RhbWFnZSIsImxpZmV0aW1lIiwib3BhY2l0eSIsInByb2plY3RpbGVFbnRpdHkiLCJjcmVhdGVQcm9qZWN0aWxlIiwicHJvamVjdGlsZVJlbmRlcmVyIiwiaXNUb3dlclByb2plY3RpbGUiLCJ0b3dlck93bmVySWQiLCJwZXJmb3JtQXR0YWNrIiwiZ2V0VG93ZXJzQnlPd25lciIsImFsbFRvd2VycyIsImZpbHRlciIsImdldFRvd2VyQ291bnQiLCJoYXNBY3RpdmVUb3dlcnMiLCJ0b3dlcnMiLCJzb21lIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJNYXAiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);